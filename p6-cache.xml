<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "December">
  <!ENTITY ID-YEAR "2012">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY architecture                "<xref target='Part1' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conformance                 "<xref target='Part1' x:rel='#conformance' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                    "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                        "<xref target='Part1' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                  "<xref target='Part1' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components            "<xref target='Part1' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                         "<xref target='Part1' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri       "<xref target='Part1' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                   "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY semantics                   "<xref target='Part2' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conditional                 "<xref target='Part4' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY partial                     "<xref target='Part5' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY combining-byte-ranges       "<xref target='Part5' x:rel='#combining.byte.ranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                   "<xref target='Part2' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-authorization        "<xref target='Part7' x:rel='#header.authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-connection           "<xref target='Part1' x:rel='#header.connection' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                 "<xref target='Part2' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified        "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-vary                 "<xref target='Part2' x:rel='#header.vary' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-via                  "<xref target='Part1' x:rel='#header.via' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-fields               "<xref target='Part1' x:rel='#header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods                "<xref target='Part2' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-tags                 "<xref target='Part4' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY weak-and-strong             "<xref target='Part4' x:rel='#weak.and.strong.validators' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY lastmod-comparison          "<xref target='Part4' x:rel='#lastmod.comparison' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes                "<xref target='Part2' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status.2xx                  "<xref target='Part2' x:rel='#status.2xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transformations             "<xref target='Part1' x:rel='#message.transformations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc category="std" docName="draft-ietf-httpbis-p6-cache-&ID-VERSION;" ipr="pre5378Trust200902"
  obsoletes="2616" x:maturity-level="proposed" xmlns:x="http://purl.org/net/xml2rfc/ext">
<x:link rel="prev" basename="p5-range"/>
<x:link rel="next" basename="p7-auth"/>
<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
<front>

  <title abbrev="HTTP/1.1 Caching">Hypertext Transfer Protocol (HTTP/1.1): Caching</title>

  <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
    <organization>Akamai</organization>
    <address>
      <email>mnot@mnot.net</email>
      <uri>http://www.mnot.net/</uri>
    </address>
  </author>

  <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;" />
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. This document
   defines requirements on HTTP caches and the associated header fields
   that control cache behavior or indicate cacheable response messages.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft takes place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.21"/>.
  </t>
</note>

   </front>
   <middle>

<section anchor="caching" title="Introduction">
<t>
   HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. This document
   defines aspects of HTTP/1.1 related to caching and reusing response
   messages.
</t>

<section anchor="intro.purpose" title="Purpose">
<iref item="cache" />
<t>
   An HTTP <x:dfn>cache</x:dfn> is a local store of response messages and the
   subsystem that controls its message storage, retrieval, and deletion. A
   cache stores cacheable responses in order to reduce the response time and
   network bandwidth consumption on future, equivalent requests. Any client or
   server &MAY; employ a cache, though a cache cannot be used by a server that
   is acting as a tunnel.
</t>
<t>
   The goal of caching in HTTP/1.1 is to significantly improve performance
   by reusing a prior response message to satisfy a current request.
   A stored response is considered "fresh", as defined in
   <xref target="expiration.model" />, if the response can be reused without
   "validation" (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh cache response can therefore
   reduce both latency and network transfers each time it is reused.
   When a cached response is not fresh, it might still be reusable if it can
   be freshened by validation (<xref target="validation.model" />) or if the
   origin is unavailable.
</t>
</section>

<section anchor="intro.terminology" title="Terminology">
<t>
   This specification uses a number of terms to refer to the roles played by
   participants in, and objects of, HTTP caching.
</t>
<t>
   <iref item="cache" />
   <x:dfn>cache</x:dfn>
   <list>
      <t>A conformant implementation of an HTTP cache. Note that this implies
        an HTTP/1.1 cache; this specification does not define conformance
        for HTTP/1.0 caches.</t>
   </list>
</t>
<t anchor="shared.and.non-shared.caches">
   <iref item="shared cache" />
   <x:dfn>shared cache</x:dfn>
   <list>
      <t>A cache that stores responses to be reused by more than one user;
         usually (but not always) deployed as part of an intermediary.</t>
   </list>
</t>
<t>
   <iref item="private cache" />
   <x:dfn>private cache</x:dfn>
   <list>
      <t>A cache that is dedicated to a single user.</t>
   </list>
</t>
<t>
   <iref item="cacheable" />
   <x:dfn>cacheable</x:dfn>
   <list>
      <t>A response is cacheable if a cache is allowed to store a copy of the
      response message for use in answering subsequent requests. Even when a
      response is cacheable, there might be additional constraints on whether
      a cache can use the stored copy to satisfy a particular request.</t>
   </list>
</t>
<t>
   <iref item="explicit expiration time" />
   <x:dfn>explicit expiration time</x:dfn>
   <list>
      <t>The time at which the origin server intends that a representation
      no longer be returned by a cache without further validation.</t>
   </list>
</t>
<t>
   <iref item="heuristic expiration time" />
   <x:dfn>heuristic expiration time</x:dfn>
   <list>
      <t>An expiration time assigned by a cache when no explicit expiration
      time is available.</t>
   </list>
</t>
<t>
   <iref item="age" />
   <x:dfn>age</x:dfn>
   <list>
      <t>The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.</t>
   </list>
</t>
<t>
   <iref item="first-hand" />
   <x:dfn>first-hand</x:dfn>
   <list>
      <t>A response is first-hand if the freshness model is not in use; i.e.,
      its age is 0.</t>
   </list>
</t>
<t>
   <iref item="freshness lifetime" />
   <x:dfn>freshness lifetime</x:dfn>
   <list>
      <t>The length of time between the generation of a response and its
      expiration time.</t>
   </list>
</t>
<t>
   <iref item="fresh" />
   <x:dfn>fresh</x:dfn>
   <list>
      <t>A response is fresh if its age has not yet exceeded its freshness
      lifetime.</t>
   </list>
</t>
<t>
   <iref item="stale" />
   <x:dfn>stale</x:dfn>
   <list>
      <t>A response is stale if its age has passed its freshness lifetime
      (either explicit or heuristic).</t>
   </list>
</t>
<t>
   <iref item="validator" />
   <x:dfn>validator</x:dfn>
   <list>
      <t>A protocol element (e.g., an entity-tag or a <x:ref>Last-Modified</x:ref>
      time) that is used to find out whether a stored response is an equivalent
      copy of a representation. See &weak-and-strong;.</t>
   </list>
</t>
<t>
   <iref item="strong validator" />
   <iref item="validator" subitem="strong" />
   <x:dfn>strong validator</x:dfn>
   <list>
      <t>A validator that is defined by the origin server such that its
         current value will change if the representation data changes; i.e.,
         an entity-tag that is not marked as weak (&entity-tags;) or,
         if no entity-tag is provided, a <x:ref>Last-Modified</x:ref> value
         that is strong in the sense defined by &lastmod-comparison;.</t>
   </list>
</t>
</section>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in &conformance;.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation
   of <xref target="RFC5234"/> with the list rule extension defined in
   &notation;. <xref target="imported.abnf"/> describes rules imported from
   other documents. <xref target="collected.abnf"/> shows the collected ABNF
   with the list rule expanded.
</t>

<section title="Delta Seconds" anchor="delta-seconds">
<t>
   The delta-seconds rule specifies a non-negative integer, representing time
   in seconds.
</t>
<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" subitem="delta-seconds" />
  <x:ref>delta-seconds</x:ref>  = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   If an implementation receives a delta-seconds value larger than the largest
   positive integer it can represent, or if any of its subsequent calculations
   overflows, it &MUST; consider the value to be 2147483648
   (2<x:sup>31</x:sup>). Recipients parsing a delta-seconds value &MUST; use
   an arithmetic type of at least 31 bits of range, and senders &MUST-NOT;
   send delta-seconds with a value greater than 2147483648.
</t>
</section>

</section>
</section>

<section anchor="caching.overview" title="Overview of Cache Operation">
<iref item="cache entry" />
<iref item="cache key" />
<t>
   Proper cache operation preserves the semantics of HTTP transfers
   (&semantics;) while eliminating the transfer of information already held
   in the cache.  Although caching is an entirely &OPTIONAL; feature of HTTP,
   we assume that reusing the cached response is desirable and that such
   reuse is the default behavior when no requirement or locally-desired
   configuration prevents it.  Therefore, HTTP cache requirements are focused
   on preventing a cache from either storing a non-reusable response or
   reusing a stored response inappropriately.
</t>
<t>
   Each <x:dfn>cache entry</x:dfn> consists of a cache key and one or more
   HTTP responses corresponding to prior requests that used the same key. The
   most common form of cache entry is a successful result of a retrieval
   request: i.e., a <x:ref>200 (OK)</x:ref> response containing a
   representation of the resource identified by the request target. However,
   it is also possible to cache negative results (e.g., <x:ref>404 (Not
   Found)</x:ref>, incomplete results (e.g., <x:ref>206 (Partial
   Content)</x:ref>), and responses to methods other than GET if the method's
   definition allows such caching and defines something suitable for use as a
   cache key.
</t>
<t>
   The default <x:dfn>cache key</x:dfn> consists of the request method and
   target URI.  However, since HTTP caches in common use today are typically
   limited to caching responses to GET, many implementations simply decline
   other methods and use only the URI as the key.
</t>
<t>
   If a request target is subject to content negotiation, its cache entry
   might consist of multiple stored responses, each differentiated by a
   secondary key for the values of the original request's selecting header
   fields (<xref target="caching.negotiated.responses"/>).
</t>
</section>

<section anchor="response.cacheability" title="Storing Responses in Caches">
<t>
   A cache &MUST-NOT; store a response to any request, unless:
   <list style="symbols">
      <t>The request method is understood by the cache and defined as being
      cacheable, and</t>
      <t>the response status code is understood by the cache, and</t>
      <t>the "no-store" cache directive (see <xref
      target="header.cache-control" />) does not appear in request or response
      header fields, and</t>
      <t>the "private" cache response directive (see <xref
      target="cache-response-directive.private" />) does not appear in the
      response, if the cache is shared, and</t>
      <t>the <x:ref>Authorization</x:ref> header field (see
      &header-authorization;) does not appear in the request, if the cache is
      shared, unless the response explicitly allows it (see <xref
      target="caching.authenticated.responses" />), and</t>
      <t>the response either:
         <list style="symbols">
            <t>contains an <x:ref>Expires</x:ref> header field (see
            <xref target="header.expires"/>), or</t>
            <t>contains a max-age response cache directive (see <xref
            target="cache-response-directive.max-age" />), or</t>
            <t>contains a s-maxage response cache directive and the cache is
            shared, or</t>
            <t>contains a Cache Control Extension (see <xref
            target="cache.control.extensions" />) that allows it to be cached,
            or</t>
            <t>has a status code that can be served with heuristic freshness
            (see <xref target="heuristic.freshness" />).</t>
         </list>
      </t>
   </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions" />.
</t>
<t>
   In this context, a cache has "understood" a request method or a response
   status code if it recognizes it and implements any cache-specific
   behavior.
</t>
<t>
   Note that, in normal operation, many caches will not store a response that
   has neither a cache validator nor an explicit expiration time, as such
   responses are not usually useful to store. However, caches are not
   prohibited from storing such responses.
</t>

<section anchor="incomplete.responses" title="Storing Incomplete Responses">
<t>
   A response message is considered complete when all of the octets indicated
   by the message framing (&messaging;) are received prior to the connection
   being closed. If the request is GET, the response status is <x:ref>200
   (OK)</x:ref>, and the entire response header block has been received, a
   cache &MAY; store an incomplete response message body if the cache entry is
   recorded as incomplete. Likewise, a <x:ref>206 (Partial Content)</x:ref>
   response &MAY; be stored as if it were an incomplete <x:ref>200
   (OK)</x:ref> cache entry. However, a cache &MUST-NOT; store incomplete or
   partial content responses if it does not support the <x:ref>Range</x:ref>
   and <x:ref>Content-Range</x:ref> header fields or if it does not understand
   the range units used in those fields.
</t>
<t>
   A cache &MAY; complete a stored incomplete response by making a subsequent
   range request (&partial;) and combining the successful response with the
   stored entry, as defined in <xref target="combining.responses"/>. A cache
   &MUST-NOT; use an incomplete response to answer requests unless the
   response has been made complete or the request is partial and specifies a
   range that is wholly within the incomplete response. A cache &MUST-NOT;
   send a partial response to a client without explicitly marking it as such
   using the <x:ref>206 (Partial Content)</x:ref> status code.
</t>
</section>


<section anchor="caching.authenticated.responses" 
   title="Storing Responses to Authenticated Requests">
<t>
   A shared cache &MUST-NOT; use a cached response to a request with an
   <x:ref>Authorization</x:ref> header field (&header-authorization;) to
   satisfy any subsequent request unless a cache directive that allows such
   responses to be stored is present in the response.
</t>
<t>
   In this specification, the following <x:ref>Cache-Control</x:ref> response
   directives (<xref target="cache-response-directive"/>) have such an effect:
   must-revalidate, public, s-maxage.
</t>
<t>
   Note that cached responses that contain the "must-revalidate" and/or
   "s-maxage" response directives are not allowed to be served stale (<xref
   target="serving.stale.responses"/>) by shared caches. In particular, a
   response with either "max-age=0, must-revalidate" or "s-maxage=0" cannot be
   used to satisfy a subsequent request without revalidating it on the origin
   server.
</t>
</section>
</section>


<section anchor="constructing.responses.from.caches" 
   title="Constructing Responses from Caches">
<t>
   For a presented request, a cache &MUST-NOT; return a stored response,
   unless:
   <list style="symbols">
      <t>The presented effective request URI (&effective-request-uri;) and
      that of the stored response match, and</t>
      <t>the request method associated with the stored response allows it to
      be used for the presented request, and</t>
      <t>selecting header fields nominated by the stored response (if any)
      match those presented (see <xref target="caching.negotiated.responses"
      />), and</t>
      <t>the presented request does not contain the no-cache pragma (<xref
      target="header.pragma"/>), nor the no-cache cache directive (<xref
      target="cache-request-directive"/>), unless the stored response is
      successfully validated (<xref target="validation.model"/>), and</t>
      <t>the stored response does not contain the no-cache cache directive
      (<xref target="cache-response-directive.no-cache"/>), unless it is
      successfully validated (<xref target="validation.model"/>), and</t>
      <t>the stored response is either:
         <list style="symbols">
            <t>fresh (see <xref target="expiration.model" />), or</t>
            <t>allowed to be served stale (see <xref
            target="serving.stale.responses" />), or</t>
            <t>successfully validated (see <xref target="validation.model"
            />).</t>
         </list>
      </t>
  </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions" />.
</t>
<t>
   When a stored response is used to satisfy a request without validation,
   a cache &MUST; include a single <x:ref>Age</x:ref> header field
   (<xref target="header.age"/>) in the response with a value equal to the
   stored response's current_age; see <xref target="age.calculations" />.
</t>
<t>
   A cache &MUST; write through requests with methods that are unsafe
   (&safe-methods;) to the origin server; i.e., a cache is not allowed to
   generate a reply to such a request before having forwarded the request and
   having received a corresponding response.
</t>
<t>
   Also, note that unsafe requests might invalidate already stored responses;
   see <xref target="invalidation.after.updates.or.deletions" />.
</t>
<t>
   When more than one suitable response is stored, a cache &MUST; use the 
   most recent response (as determined by the <x:ref>Date</x:ref> header
   field). It can also forward a request with "Cache-Control: max-age=0" or
   "Cache-Control: no-cache" to disambiguate which response to use.
</t>
<t>
   A cache that does not have a clock available &MUST-NOT; use stored
   responses without revalidating them on every use. A cache, especially a
   shared cache, &SHOULD; use a mechanism, such as NTP <xref
   target="RFC1305"/>, to synchronize its clock with a reliable external
   standard.
</t>


<section anchor="expiration.model" title="Freshness Model">
<t>
   When a response is "fresh" in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby improving
   efficiency.
</t>
<t>
   The primary mechanism for determining freshness is for an origin server to
   provide an explicit expiration time in the future, using either the
   <x:ref>Expires</x:ref> header field (<xref target="header.expires" />) or
   the max-age response cache directive (<xref
   target="cache-response-directive.max-age" />). Generally, origin servers will
   assign future explicit expiration times to responses in the belief that the
   representation is not likely to change in a semantically significant way
   before the expiration time is reached.
</t>
<t>
   If an origin server wishes to force a cache to validate every request, it
   can assign an explicit expiration time in the past to indicate that the
   response is already stale. Compliant caches will normally validate a stale
   cached response before reusing it for subsequent requests (see <xref
   target="serving.stale.responses" />).
</t>
<t>
   Since origin servers do not always provide explicit expiration times, a
   cache &MAY; assign a heuristic expiration time when an explicit time is not
   specified, employing algorithms that use other header field values (such as
   the <x:ref>Last-Modified</x:ref> time) to estimate a plausible expiration
   time. This specification does not provide specific algorithms, but does
   impose worst-case constraints on their results.
</t>
<figure>
<preamble>
  The calculation to determine if a response is fresh is:
</preamble>
<artwork type="code">
   response_is_fresh = (freshness_lifetime &gt; current_age)
</artwork>
</figure>
<t>
   The freshness_lifetime is defined in <xref
   target="calculating.freshness.lifetime" />; the current_age is defined in
   <xref target="age.calculations" />.
</t>
<t>
   Clients can send the max-age or min-fresh cache directives in a request to
   constrain or relax freshness calculations for the corresponding response
   (<xref target="cache-request-directive" />). 
</t>
<t>
   Note that freshness applies only to cache operation; it cannot be used to
   force a user agent to refresh its display or reload a resource. See <xref
   target="history.lists" /> for an explanation of the difference between
   caches and history mechanisms.
</t>

<section anchor="calculating.freshness.lifetime" 
   title="Calculating Freshness Lifetime">
<t>
   A cache can calculate the freshness lifetime (denoted as
   freshness_lifetime) of a response by using the first match of:
   <list style="symbols">
      <t>If the cache is shared and the s-maxage response cache directive
      (<xref target="cache-response-directive.s-maxage" />) is present, use its value,
      or</t>
      <t>If the max-age response cache directive (<xref
      target="cache-response-directive.max-age" />) is present, use its value, or</t>
      <t>If the <x:ref>Expires</x:ref> response header field
      (<xref target="header.expires" />) is present, use its value minus the
      value of the <x:ref>Date</x:ref> response header field, or</t>
      <t>Otherwise, no explicit expiration time is present in the response. A
      heuristic freshness lifetime might be applicable; see <xref
      target="heuristic.freshness" />.</t>
   </list>
</t>
<t>
   Note that this calculation is not vulnerable to clock skew, since all of
   the information comes from the origin server.
</t>
<t>
   When there is more than one value present for a given directive (e.g., two
   <x:ref>Expires</x:ref> header fields, multiple Cache-Control: max-age
   directives), it is considered invalid. Caches are encouraged to consider
   responses that have invalid freshness information to be stale.
</t>
</section>

<section anchor="heuristic.freshness" title="Calculating Heuristic Freshness">
<t>
   If no explicit expiration time is present in a stored response that has a
   status code whose definition allows heuristic freshness to be used
   (including the following in &status-codes;: <x:ref>200 (OK)</x:ref>,
   <x:ref>203 (Non-Authoritative Information)</x:ref>, <x:ref>206 (Partial
   Content)</x:ref>, <x:ref>300 (Multiple Choices)</x:ref>, <x:ref>301 (Moved
   Permanently)</x:ref> and <x:ref>410 (Gone)</x:ref>), a cache &MAY;
   calculate a heuristic expiration time. A cache &MUST-NOT; use heuristics to
   determine freshness for responses with status codes that do not explicitly
   allow it.
</t>
<t>
   When a heuristic is used to calculate freshness lifetime, a cache &SHOULD;
   attach a <x:ref>Warning</x:ref> header field with a 113 warn-code to the
   response if its current_age is more than 24 hours and such a warning is not
   already present.
</t>
<t>
   Also, if the response has a <x:ref>Last-Modified</x:ref> header field
   (&header-last-modified;), caches are encouraged to use a heuristic
   expiration value that is no more than some fraction of the interval since
   that time. A typical setting of this fraction might be 10%.
</t>
<x:note>
   <t>
      &Note; <xref target="RFC2616" x:fmt="of" x:sec="13.9"/> prohibited caches
      from calculating heuristic freshness for URIs with query components
      (i.e., those containing '?'). In practice, this has not been widely
      implemented. Therefore, servers are encouraged to send explicit
      directives (e.g., Cache-Control: no-cache) if they wish to preclude
      caching.
   </t>
</x:note>
</section>

<section anchor="age.calculations" title="Calculating Age">
<t>
   HTTP/1.1 uses the <x:ref>Age</x:ref> header field to convey the estimated
   age of the response message when obtained from a cache. The Age field value
   is the cache's estimate of the amount of time since the response was
   generated or validated by the origin server. In essence, the Age value is
   the sum of the time that the response has been resident in each of the
   caches along the path from the origin server, plus the amount of time it
   has been in transit along network paths.
</t>
<t>
   The following data is used for the age calculation:
</t>
<t>
   <x:dfn>age_value</x:dfn>
   <list>
      <t>
         The term "age_value" denotes the value of the <x:ref>Age</x:ref>
         header field (<xref target="header.age"/>), in a form appropriate for
         arithmetic operation; or 0, if not available.
      </t>
   </list>
</t>
<t>
   <x:dfn>date_value</x:dfn>
   <list>
      <t>
         HTTP/1.1 requires origin servers to send a <x:ref>Date</x:ref> header
         field, if possible, with every response, giving the time at which the
         response was generated. The term "date_value" denotes the value of
         the Date header field, in a form appropriate for arithmetic
         operations. See &header-date; for the definition of the Date header
         field, and for requirements regarding responses without it.
      </t>
   </list>
</t>
<t>
   <x:dfn>now</x:dfn>
   <list>
      <t>
         The term "now" means "the current value of the clock at the host
         performing the calculation". A cache &SHOULD; use NTP (<xref
         target="RFC1305"/>) or some similar protocol to synchronize its
         clocks to a globally accurate time standard.
      </t>
   </list>
</t>
<t>
   <x:dfn>request_time</x:dfn>
   <list>
      <t>
         The current value of the clock at the host at the time the request
         resulting in the stored response was made.
      </t>
   </list>
</t>
<t>
   <x:dfn>response_time</x:dfn>
   <list>
      <t>
         The current value of the clock at the host at the time the response
         was received.
      </t>
   </list>
</t>
<t>
   A response's age can be calculated in two entirely independent ways:
   <list style="numbers">
      <t>the "apparent_age": response_time minus date_value, if the local
      clock is reasonably well synchronized to the origin server's clock. If
      the result is negative, the result is replaced by zero.</t>
      <t>the "corrected_age_value", if all of the caches along the response
      path implement HTTP/1.1. A cache &MUST; interpret this value relative
      to the time the request was initiated, not the time that the response
      was received.</t>
   </list>
</t>
<figure>
<artwork type="code">
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;  
</artwork>
</figure>
<figure>
<preamble>These &SHOULD; be combined as</preamble>
<artwork type="code">
  corrected_initial_age = max(apparent_age, corrected_age_value);
</artwork></figure>
<t>
   unless the cache is confident in the value of the <x:ref>Age</x:ref> header
   field (e.g., because there are no HTTP/1.0 hops in the <x:ref>Via</x:ref>
   header field), in which case the corrected_age_value &MAY; be used as the
   corrected_initial_age.</t>
<t>
   The current_age of a stored response can then be calculated by adding the
   amount of time (in seconds) since the stored response was last validated by
   the origin server to the corrected_initial_age.
</t>
<figure><artwork type="code">
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
</artwork></figure>
<t>
   Additionally, to avoid common problems in date parsing:
</t>
<t>
  <list style="symbols">
     <t>Recipients &SHOULD; assume that an RFC-850 date
        which appears to be more than 50 years in the future is in fact
        in the past (this helps solve the "year 2000" problem).</t>

     <t>Although all date formats are specified to be case-sensitive, 
        recipients &SHOULD; match day, week and timezone names
        case-insensitively.</t>
             
     <t>An implementation &MAY; internally represent a parsed
        <x:ref>Expires</x:ref> date as earlier than the proper value, but
        &MUST-NOT; internally represent a parsed Expires date as later than the
        proper value.</t>

     <t>Recipients &MUST; perform all expiration-related calculations in GMT.
        The local time zone &MUST-NOT; influence the calculation or comparison
        of an age or expiration time.</t>

     <t>Caches &SHOULD; consider dates with time zones other than "GMT"
        invalid.</t>
  </list>
</t>
</section>

<section anchor="serving.stale.responses" title="Serving Stale Responses">
<t>
   A "stale" response is one that either has explicit expiry information or is
   allowed to have heuristic expiry calculated, but is not fresh according to
   the calculations in <xref target="expiration.model" />.
</t>
<t>
   A cache &MUST-NOT; return a stale response if it is prohibited by an
   explicit in-protocol directive (e.g., by a "no-store" or "no-cache" cache
   directive, a "must-revalidate" cache-response-directive, or an applicable
   "s-maxage" or "proxy-revalidate" cache-response-directive; see <xref
   target="cache-response-directive"/>).
</t>
<t>
   A cache &MUST-NOT; return stale responses unless it is disconnected
   (i.e., it cannot contact the origin server or otherwise find a forward
   path) or doing so is explicitly allowed (e.g., by the max-stale request
   directive; see <xref target="cache-request-directive" />).
</t>
<t>
   A cache &SHOULD; append a <x:ref>Warning</x:ref> header field with the 110
   warn-code (see <xref target="header.warning"/>) to stale responses.
   Likewise, a cache &SHOULD; add the 112 warn-code to stale responses if the
   cache is disconnected.
</t>
<t>
   If a cache receives a first-hand response (either an entire response, or a
   <x:ref>304 (Not Modified)</x:ref> response) that it would normally forward
   to the requesting client, and the received response is no longer fresh, the
   cache can forward it to the requesting client without adding a new
   <x:ref>Warning</x:ref> (but without removing any existing Warning header
   fields). A cache shouldn't attempt to validate a response simply because
   that response became stale in transit.
</t>
</section>
</section>

<section anchor="validation.model" title="Validation Model">
<t>
   When a cache has one or more stored responses for a requested URI, but
   cannot serve any of them (e.g., because they are not fresh, or one cannot
   be selected; see <xref target="caching.negotiated.responses"/>), it can use
   the conditional request mechanism &conditional; in the forwarded request to
   give the origin server an opportunity to both select a valid stored
   response to be used, and to update it. This process is known as
   "validating" or "revalidating" the stored response.
</t>
<t>
   When sending such a conditional request, a cache adds an
   <x:ref>If-Modified-Since</x:ref> header field whose value is that of the
   <x:ref>Last-Modified</x:ref> header field from the selected
   (see <xref target="caching.negotiated.responses"/>) stored response, if
   available.
</t>
<t>
   Additionally, a cache can add an <x:ref>If-None-Match</x:ref> header field
   whose value is that of the <x:ref>ETag</x:ref> header field(s) from all
   responses stored for the requested URI, if present. However, if any of the
   stored responses contains only partial content, the cache shouldn't
   include its entity-tag in the If-None-Match header field unless the request
   is for a range that would be fully satisfied by that stored response.
</t>

<t>Cache handling of a response to a conditional request is dependent upon its
status code:</t>

<t>
   <list style="symbols">
      <t>
         A <x:ref>304 (Not Modified)</x:ref> response status code indicates
         that the stored response can be updated and reused; see <xref
         target="freshening.responses"/>.
      </t>
      <t>
         A full response (i.e., one with a payload body) indicates that none
         of the stored responses nominated in the conditional request is
         suitable. Instead, the cache can use the full response to
         satisfy the request and &MAY; replace the stored response(s).
      </t>
      <t>
         However, if a cache receives a <x:ref>5xx (Server Error)</x:ref>
         response while attempting to validate a response, it can either
         forward this response to the requesting client, or act as if the
         server failed to respond. In the latter case, it can return a
         previously stored response (see <xref
         target="serving.stale.responses" />).
      </t>
   </list>
</t>

<section anchor="freshening.responses" title="Freshening Responses with 304 Not Modified">
<t>
   When a cache receives a <x:ref>304 (Not Modified)</x:ref> response and
   already has one or more stored <x:ref>200 (OK)</x:ref> responses for the
   same cache key, the cache needs to identify which of the stored responses
   are updated by this new response and then update the stored response(s)
   with the new information provided in the <x:ref>304</x:ref> response.
   <list style="symbols">
    <t>
     If the new response contains a strong validator, then that strong
     validator identifies the selected representation.  All of the stored
     responses with the same strong validator are selected.
     If none of the stored responses contain the same strong validator, 
     then the new response &MUST-NOT; be used to update any stored responses.
    </t>
    <t>
     If the new response contains a weak validator and that validator
     corresponds to one of the cache's stored responses, then the most
     recent of those matching stored responses is selected.
    </t>
    <t>
     If the new response does not include any form of validator, there is
     only one stored response, and that stored response also lacks a
     validator, then that stored response is selected.
    </t>
   </list>
</t>
<t>
   If a stored response is selected for update, the cache &MUST;:
   <list style="symbols">
      <t>delete any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning" />);</t>
      <t>retain any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the <x:ref>304 (Not Modified)</x:ref>
         response to replace all instances of the corresponding header
         fields in the stored response.</t>
   </list>
</t>
</section>

</section>

<section anchor="caching.negotiated.responses" 
   title="Using Negotiated Responses">
<t>
   When a cache receives a request that can be satisfied by a stored response
   that has a <x:ref>Vary</x:ref> header field (&header-vary;),
   it &MUST-NOT; use that response unless all of the selecting header fields
   nominated by the Vary header field match in both the original request
   (i.e., that associated with the stored response), and the presented
   request.
</t>
<t>
   The selecting header fields from two requests are defined to match if and
   only if those in the first request can be transformed to those in the
   second request by applying any of the following:
   <list style="symbols">
      <t>
         adding or removing whitespace, where allowed in the header field's
         syntax
      </t>
      <t>
         combining multiple header fields with the same field name
         (see &header-fields;)
      </t>
      <t>
         normalizing both header field values in a way that is known to have
         identical semantics, according to the header field's specification
         (e.g., re-ordering field values when order is not significant;
         case-normalization, where values are defined to be case-insensitive)
      </t>
  </list>
</t>
<t>
   If (after any normalization that might take place) a header field is absent
   from a request, it can only match another request if it is also absent
   there.
</t>
<t>
   A <x:ref>Vary</x:ref> header field-value of "*" always fails to match, and
   subsequent requests to that resource can only be properly interpreted by the
   origin server.
</t>
<t>
   The stored response with matching selecting header fields is known as the
   selected response.
</t>
<t>
   If multiple selected responses are available, the most recent response 
   (as determined by the <x:ref>Date</x:ref> header field) is used; see <xref 
   target="constructing.responses.from.caches"/>.
</t>
<t>
   If no selected response is available, the cache cannot satisfy the 
   presented request. Typically, it is forwarded to the origin server 
   in a (possibly conditional; see <xref target="validation.model"/>) request.
</t>
</section>


<section anchor="combining.responses" title="Combining Partial Content">
<t>
   A response might transfer only a partial representation if the
   connection closed prematurely or if the request used one or more Range
   specifiers (&partial;).  After several such transfers, a cache might have
   received several ranges of the same representation.  A cache &MAY; combine
   these ranges into a single stored response, and reuse that response to
   satisfy later requests, if they all share the same strong validator and
   the cache complies with the client requirements in &combining-byte-ranges;.
</t>
<t>
   When combining the new response with one or more stored responses, a
   cache &MUST;:
   <list style="symbols">
      <t>delete any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning" />);</t>
      <t>retain any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the new response, aside
         from <x:ref>Content-Range</x:ref>, to replace all instances of the
         corresponding header fields in the stored response.</t>
   </list>
</t>
</section>
</section>


<section anchor="head.effects" title="Updating Caches with HEAD Responses">
<t>
   A response to the HEAD method is identical to what an equivalent request
   made with a GET would have been, except it lacks a body. This property
   of HEAD responses is used to both invalidate and update cached GET
   responses.
</t>
<t>
   If one or more stored GET responses can be selected (as per <xref
   target="caching.negotiated.responses"/>) for a HEAD request, and the
   <x:ref>Content-Length</x:ref>, <x:ref>ETag</x:ref> or
   <x:ref>Last-Modified</x:ref> value of a HEAD response differs from that in a
   selected GET response, the cache &MUST; consider that selected response to
   be stale.
</t>
<t>
   If the <x:ref>Content-Length</x:ref>, <x:ref>ETag</x:ref> and
   <x:ref>Last-Modified</x:ref> values of a HEAD response (when present) are
   the same as that in a selected GET response (as per
   <xref target="caching.negotiated.responses"/>), the cache &SHOULD; update
   the remaining header fields in the stored response using the following
   rules:
   <list style="symbols">
      <t>delete any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning" />);</t>
      <t>retain any <x:ref>Warning</x:ref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the response to replace
         all instances of the corresponding header fields in the stored
         response.</t>
   </list>
</t>

</section>


<section anchor="invalidation.after.updates.or.deletions" 
   title="Request Methods that Invalidate">
<t>
   Because unsafe request methods (&safe-methods;) such as PUT, POST or DELETE
   have the potential for changing state on the origin server, intervening
   caches can use them to keep their contents up-to-date.
</t>
<t>
   A cache &MUST; invalidate the effective Request URI
   (&effective-request-uri;) as well as the URI(s) in the
   <x:ref>Location</x:ref> and <x:ref>Content-Location</x:ref> response header
   fields (if present) when a non-error response to a request with an unsafe
   method is received.
</t>
<t>
   However, a cache &MUST-NOT; invalidate a URI from a <x:ref>Location</x:ref>
   or <x:ref>Content-Location</x:ref> response header field if the host part of
   that URI differs from the host part in the effective request URI
   (&effective-request-uri;). This helps prevent denial of service attacks.
</t>
<t>
   A cache &MUST; invalidate the effective request URI 
   (&effective-request-uri;) when it receives a non-error response 
   to a request with a method whose safety is unknown.
</t>
<t>
   Here, a "non-error response" is one with a <x:ref>2xx (Successful)</x:ref>
   or <x:ref>3xx (Redirection)</x:ref> status code. "Invalidate" means that
   the cache will either remove all stored responses related to the effective
   request URI, or will mark these as "invalid" and in need of a mandatory
   validation before they can be returned in response to a subsequent request.
</t>
<t>
   Note that this does not guarantee that all appropriate responses are
   invalidated. For example, the request that caused the change at the origin
   server might not have gone through the cache where a response is stored.
</t>
</section>




<section anchor="header.field.definitions" title="Header Field Definitions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to caching.
</t>

<section anchor="header.age" title="Age">
   <iref item="Age header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="Age"/>
   <x:anchor-alias value="age-value"/>
<t>
   The "Age" header field conveys the sender's estimate of the amount
   of time since the response was generated or successfully validated at the
   origin server. Age values are calculated as specified in <xref
   target="age.calculations" />.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Age"/>
  <x:ref>Age</x:ref> = <x:ref>delta-seconds</x:ref>
</artwork></figure>
<t>
  Age field-values are non-negative integers, representing time in seconds
  (see <xref target="delta-seconds"/>).
</t>
<t>
   The presence of an Age header field in a response implies that a response
   is not first-hand. However, the converse is not true, since HTTP/1.0 caches
   might not implement the Age header field.
</t>
</section>

<section anchor="header.cache-control" title="Cache-Control">
   <iref item="Cache-Control header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="Cache-Control"/>
   <x:anchor-alias value="cache-directive"/>
<t>
   The "Cache-Control" header field is used to specify directives for
   caches along the request/response chain. Such cache directives are
   unidirectional in that the presence of a directive in a request does not
   imply that the same directive is to be given in the response.
</t>
<t>
   A cache &MUST; obey the requirements of the Cache-Control
   directives defined in this section. See <xref
   target="cache.control.extensions"/> for information about how Cache-Control
   directives defined elsewhere are handled.
</t>
<x:note>
   <t>
       &Note; HTTP/1.0 caches might not implement Cache-Control and
       might only implement Pragma: no-cache (see <xref target="header.pragma"
       />).
   </t>
</x:note>
<t>
   A proxy, whether or not it implements a cache, &MUST; pass cache directives
   through in forwarded messages, regardless of their 
   significance to that application, since the directives might be applicable 
   to all recipients along the request/response chain. It is not possible to 
   target a directive to a specific cache.
</t>
<t>
   Cache directives are identified by a token, to be compared case-insensitively,
   and have an optional argument, that can use both token and quoted-string
   syntax. For the directives defined below that define arguments, recipients
   ought to accept both forms, even if one is documented to be preferred. For
   any directive not defined by this specification, recipients &MUST; accept
   both forms. 
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Cache-Control"/><iref primary="true" item="Grammar" subitem="cache-directive"/>
  <x:ref>Cache-Control</x:ref>   = 1#<x:ref>cache-directive</x:ref>

  <x:ref>cache-directive</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   For the cache directives defined below, no argument is defined (nor allowed)
   otherwise stated otherwise.
</t>

<section title="Request Cache-Control Directives" anchor="cache-request-directive">

<section title="no-cache" anchor="cache-request-directive.no-cache">
   <iref item="no-cache (cache directive)" primary="true" />
<t>
   The "no-cache" request directive indicates that a cache &MUST-NOT; 
   use a stored response to satisfy the request without successful 
   validation on the origin server.
</t>
</section>
 
<section title="no-store" anchor="cache-request-directive.no-store">
   <iref item="no-store (cache directive)" primary="true" />
<t>
   The "no-store" request directive indicates that a cache &MUST-NOT;
   store any part of either this request or any response to it. This
   directive applies to both private and shared caches. "&MUST-NOT;
   store" in this context means that the cache &MUST-NOT; intentionally
   store the information in non-volatile storage, and &MUST; make a
   best-effort attempt to remove the information from volatile storage as
   promptly as possible after forwarding it.
</t>
<t>
   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy. In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might be
   vulnerable to eavesdropping.
</t>
<t>
   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.
</t>
</section>

<section title="max-age" anchor="cache-request-directive.max-age">
   <iref item="max-age (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        <x:ref>delta-seconds</x:ref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-age" request directive indicates that the client is unwilling to
   accept a response whose age is greater than the specified number of
   seconds. Unless the max-stale request directive is also present, the
   client is not willing to accept a stale response.
</t>
<t>
   &Note; This directive uses the token form of the argument syntax;
   e.g., 'max-age=5', not 'max-age="5"'. Senders &SHOULD-NOT; use the
   quoted-string form.
</t>
</section>

<section title="max-stale" anchor="cache-request-directive.max-stale">
   <iref item="max-stale (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        <x:ref>delta-seconds</x:ref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-stale" request directive indicates that the client is willing
   to accept a response that has exceeded its expiration time. If max-stale
   is assigned a value, then the client is willing to accept a response
   that has exceeded its expiration time by no more than the specified
   number of seconds. If no value is assigned to max-stale, then the client
   is willing to accept a stale response of any age.
</t>
<t>
   &Note; This directive uses the token form of the argument syntax;
   e.g., 'max-stale=10', not 'max-stale="10"'. Senders &SHOULD-NOT; use the
   quoted-string form.
</t>
</section>

<section title="min-fresh" anchor="cache-request-directive.min-fresh">
   <iref item="min-fresh (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        <x:ref>delta-seconds</x:ref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "min-fresh" request directive indicates that the client is willing
   to accept a response whose freshness lifetime is no less than its
   current age plus the specified time in seconds. That is, the client
   wants a response that will still be fresh for at least the specified
   number of seconds.
</t>
<t>
   &Note; This directive uses the token form of the argument syntax;
   e.g., 'min-fresh=20', not 'min-fresh="20"'. Senders &SHOULD-NOT; use the
   quoted-string form.
</t>
</section>

<section title="no-transform" anchor="cache-request-directive.no-transform">
   <iref item="no-transform (cache directive)" primary="true" />
<t>
   The "no-transform" request directive indicates that an intermediary
   (whether or not it implements a cache) &MUST-NOT; transform the payload,
   as defined in &transformations;.
</t>
</section>

<section title="only-if-cached" anchor="cache-request-directive.only-if-cached">
   <iref item="only-if-cached (cache directive)" primary="true" />
<t>
   The "only-if-cached" request directive indicates that the client only wishes
   to obtain a stored response. If it receives this directive, a cache &SHOULD;
   either respond using a stored response that is consistent with the other
   constraints of the request, or respond with a <x:ref>504 (Gateway
   Timeout)</x:ref> status code. If a group of caches is being operated as a
   unified system with good internal connectivity, a member cache &MAY;
   forward such a request within that group of caches.
</t>
</section>
</section>

<section anchor="cache-response-directive" 
   title="Response Cache-Control Directives">
   <x:anchor-alias value="cache-response-directive" />

<section title="public" anchor="cache-response-directive.public">
   <iref item="public (cache directive)" primary="true" />
<t>
   The "public" response directive indicates that a response whose 
   associated request contains an 'Authentication' header &MAY; be 
   stored (see <xref target="caching.authenticated.responses" />).
</t>
</section>

<section title="private" anchor="cache-response-directive.private">
   <iref item="private (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        #<x:ref>field-name</x:ref>
      </t>
   </list>
</t>
<t>
   The "private" response directive indicates that the response message is
   intended for a single user and &MUST-NOT; be stored by a shared cache. A
   private cache &MAY; store the response.
</t>
<t>
   If the private response directive specifies one or more field-names,
   this requirement is limited to the field-values associated with the
   listed response header fields. That is, a shared cache &MUST-NOT; store
   the specified field-names(s), whereas it &MAY; store the remainder of the
   response message.
</t>
<t>
   The field-names given are not limited to the set of standard header
   fields defined by this specification. Field names are case-insensitive.
</t>
<t>
   &Note; This usage of the word "private" only controls
   where the response can be stored; it cannot ensure the privacy of the
   message content. Also, private response directives with field-names are
   often handled by implementations as if an unqualified private directive
   was received; i.e., the special handling for the qualified form is not
   widely implemented.
</t>
<t>
   &Note; This directive uses the quoted-string form of the argument syntax.
   Senders &SHOULD-NOT; use the token form (even if quoting appears not to be
   needed for single-entry lists).
</t>
</section>

<section title="no-cache" anchor="cache-response-directive.no-cache">
   <iref item="no-cache (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        #<x:ref>field-name</x:ref>
      </t>
   </list>
</t>
<t>
   The "no-cache" response directive indicates that the response &MUST-NOT;
   be used to satisfy a subsequent request without successful validation on
   the origin server. This allows an origin server to prevent a cache from
   using it to satisfy a request without contacting it, even by caches that
   have been configured to return stale responses.
</t>
<t>
   If the no-cache response directive specifies one or more field-names,
   then a cache &MAY; use the response to satisfy a subsequent request,
   subject to any other restrictions on caching. However, any header fields
   in the response that have the field-name(s) listed &MUST-NOT; be sent
   in the response to a subsequent request without successful revalidation
   with the origin server. This allows an origin server to prevent the
   re-use of certain header fields in a response, while still allowing
   caching of the rest of the response.
</t> 
<t>
   The field-names given are not limited to the set of standard header
   fields defined by this specification. Field names are case-insensitive.
</t>
<t>
   &Note; Many HTTP/1.0 caches will not recognize or obey
   this directive. Also, no-cache response directives with field-names are
   often handled by implementations as if an unqualified no-cache directive
   was received; i.e., the special handling for the qualified form is not
   widely implemented.
</t>
<t>
   &Note; This directive uses the quoted-string form of the argument syntax.
   Senders &SHOULD-NOT; use the token form (even if quoting appears not to be
   needed for single-entry lists).
</t>
</section>

<section title="no-store" anchor="cache-response-directive.no-store">
   <iref item="no-store (cache directive)" primary="true" />
<t>
   The "no-store" response directive indicates that a cache &MUST-NOT;
   store any part of either the immediate request or response. This
   directive applies to both private and shared caches. "&MUST-NOT;
   store" in this context means that the cache &MUST-NOT; intentionally
   store the information in non-volatile storage, and &MUST; make a
   best-effort attempt to remove the information from volatile storage as
   promptly as possible after forwarding it.
</t>
<t>
   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy. In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might be
   vulnerable to eavesdropping.
</t>
</section>

<section title="must-revalidate" anchor="cache-response-directive.must-revalidate">
   <iref item="must-revalidate (cache directive)" primary="true" />
<t>
   The "must-revalidate" response directive indicates that once it has
   become stale, a cache &MUST-NOT; use the response to satisfy subsequent
   requests without successful validation on the origin server.
</t>
<t>
   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features. In all circumstances a
   cache &MUST; obey the must-revalidate directive; in particular,
   if a cache cannot reach the origin server for any reason, it &MUST;
   generate a <x:ref>504 (Gateway Timeout)</x:ref> response.
</t>
<t>
   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result in
   incorrect operation, such as a silently unexecuted financial
   transaction.
</t>
</section>

<section title="proxy-revalidate" anchor="cache-response-directive.proxy-revalidate">
   <iref item="proxy-revalidate (cache directive)" primary="true" />
<t>
   The "proxy-revalidate" response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.
</t>
</section>

<section title="max-age" anchor="cache-response-directive.max-age">
   <iref item="max-age (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        <x:ref>delta-seconds</x:ref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-age" response directive indicates that the response is to be
   considered stale after its age is greater than the specified number of
   seconds.
</t>
<t>
   &Note; This directive uses the token form of the argument syntax;
   e.g., 'max-age=5', not 'max-age="5"'. Senders &SHOULD-NOT; use the
   quoted-string form.
</t>
</section>      

<section title="s-maxage" anchor="cache-response-directive.s-maxage">
   <iref item="s-maxage (cache directive)" primary="true" />
<t>
   Argument syntax:
   <list>
      <t>
        <x:ref>delta-seconds</x:ref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "s-maxage" response directive indicates that, in shared caches, the
   maximum age specified by this directive overrides the maximum age
   specified by either the max-age directive or the <x:ref>Expires</x:ref>
   header field. The s-maxage directive also implies the semantics of the
   proxy-revalidate response directive.
</t>
<t>
   &Note; This directive uses the token form of the argument syntax;
   e.g., 's-maxage=10', not 's-maxage="10"'. Senders &SHOULD-NOT; use the
   quoted-string form.
</t>
</section>

<section title="no-transform" anchor="cache-response-directive.no-transform">
   <iref item="no-transform (cache directive)" primary="true" />
<t>
   The "no-transform" response directive indicates that an intermediary
   (regardless of whether it implements a cache) &MUST-NOT; transform the
   payload, as defined in &transformations;.
</t>
</section>

</section>

<section anchor="cache.control.extensions" title="Cache Control Extensions">
<t>
   The Cache-Control header field can be extended through the use of one or
   more cache-extension tokens, each with an optional value. Informational
   extensions (those that do not require a change in cache behavior) can be
   added without changing the semantics of other directives. Behavioral
   extensions are designed to work by acting as modifiers to the existing base
   of cache directives. Both the new directive and the standard directive are
   supplied, such that applications that do not understand the new directive
   will default to the behavior specified by the standard directive, and those
   that understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without requiring
   changes to the base protocol.
</t>
<t>
   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.
</t>
<t>
   For example, consider a hypothetical new response directive called
   "community" that acts as a modifier to the private directive. We define
   this new directive to mean that, in addition to any private cache, any
   cache that is shared only by members of the community named within its
   value is allowed to cache the response. An origin server wishing to allow
   the UCI community to use an otherwise private response in their shared
   cache(s) could do so by including
</t>
<figure><artwork type="example">
  Cache-Control: private, community="UCI"
</artwork></figure>
<t>
   A cache seeing this header field will act correctly even if the cache does
   not understand the community cache-extension, since it will also see and
   understand the private directive and thus default to the safe behavior.
</t>
<t>
   A cache &MUST; ignore unrecognized cache directives; it is assumed that any
   cache directive likely to be unrecognized by an HTTP/1.1 cache will be
   combined with standard directives (or the response's default cacheability)
   such that the cache behavior will remain minimally correct even if the
   cache does not understand the extension(s).
</t>
<t>
   New extension directives ought to consider defining:
</t>
<t>
   <list style="symbols">
      <t>What it means for a directive to be specified multiple times,</t>
      <t>When the directive does not take an argument, what it means when an
      argument is present,</t>
      <t>When the directive requires an argument, what it means when it is
      missing.</t>
   </list>
</t>
<t>
   The HTTP Cache Directive Registry defines the name space for the cache
   directives.
</t>
<t>
   A registration &MUST; include the following fields:
   <list style="symbols">
      <t>Cache Directive Name</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to this name space require IETF Review (see <xref
   target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
<t>
   The registry itself is maintained at <eref
   target="http://www.iana.org/assignments/http-cache-directives"/>.
</t>
</section>

</section>

<section anchor="header.expires" title="Expires">
   <iref item="Expires header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="Expires"/>
<t>
   The "Expires" header field gives the date/time after which the
   response is considered stale. See <xref target="expiration.model" /> for
   further discussion of the freshness model.
</t>
<t>
   The presence of an Expires field does not imply that the original resource
   will change or cease to exist at, before, or after that time.
</t>
<t>
   The field-value is an absolute date and time as defined by HTTP-date in
   &http-date;; a sender &MUST; use the rfc1123-date format.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Expires"/>
  <x:ref>Expires</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<figure>
  <preamble>For example</preamble>
<artwork type="example">
  Expires: Thu, 01 Dec 1994 16:00:00 GMT
</artwork></figure>
<t>
   A cache &MUST; treat other invalid date formats,
   especially including the value "0", as in the past (i.e., "already
   expired").
</t>
<x:note>
   <t>
       &Note; If a response includes a <x:ref>Cache-Control</x:ref> field with
       the max-age directive (see <xref target="cache-response-directive.max-age" />),
       that directive overrides the Expires field. Likewise, the s-maxage
       directive (<xref target="cache-response-directive.s-maxage" />) overrides
       the <x:ref>Expires</x:ref> header field in shared caches.
   </t>
</x:note>
<t>
   Historically, HTTP required the Expires field-value to be no more than a 
   year in the future. While longer freshness lifetimes are no longer 
   prohibited, extremely large values have been demonstrated to cause 
   problems (e.g., clock overflows due to use of 32-bit integers for 
   time values), and many caches will evict a response far sooner than 
   that.
</t>
<t>
   An origin server without a clock &MUST-NOT; assign Expires
   values to a response unless these values were associated
   with the resource by a system or user with a reliable clock. It &MAY;
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows "pre-expiration"
   of responses without storing separate Expires values for each
   resource).
</t>
</section>

<section anchor="header.pragma" title="Pragma">
   <iref item="Pragma header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="extension-pragma"/>
   <x:anchor-alias value="Pragma"/>
   <x:anchor-alias value="pragma-directive"/>
<t>
   The "Pragma" header field allows backwards compatibility with HTTP/1.0
   caches, so that clients can specify a "no-cache" request that they will
   understand (as <x:ref>Cache-Control</x:ref> was not defined until HTTP/1.1).
   When the Cache-Control header field is also present and understood in a
   request, Pragma is ignored.
</t>
<t>
   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients. This specification
   deprecates such extensions to improve interoperability.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Pragma"/><iref primary="true" item="Grammar" subitem="pragma-directive"/><iref primary="true" item="Grammar" subitem="extension-pragma"/>
  <x:ref>Pragma</x:ref>           = 1#<x:ref>pragma-directive</x:ref>
  <x:ref>pragma-directive</x:ref> = "no-cache" / <x:ref>extension-pragma</x:ref>
  <x:ref>extension-pragma</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   When the <x:ref>Cache-Control</x:ref> header field is not present in a
   request, the no-cache request pragma-directive &MUST; have the same effect
   on caches as if "Cache-Control: no-cache" were present (see <xref
   target="cache-request-directive" />).
</t>
<t>
   When sending a no-cache request, a client ought to include both the pragma
   and cache-control directives, unless Cache-Control: no-cache is
   purposefully omitted to target other <x:ref>Cache-Control</x:ref> response
   directives at HTTP/1.1 caches. For example:
</t>
<figure>
<artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
GET / HTTP/1.1
Host: www.example.com
Cache-Control: max-age=30
Pragma: no-cache

</artwork>
</figure>
<t>
   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   <x:ref>Cache-Control</x:ref> from serving a cached response.
</t>
<x:note>
   <t>
      &Note; Because the meaning of "Pragma: no-cache" in responses is not
      specified, it does not provide a reliable replacement for
      "Cache-Control: no-cache" in them.
   </t>
</x:note>
</section>

<section anchor="header.warning" title="Warning">
   <iref item="Warning header field" primary="true" x:for-anchor="" />
   <x:anchor-alias value="Warning"/>
   <x:anchor-alias value="warning-value"/>
   <x:anchor-alias value="warn-agent"/>
   <x:anchor-alias value="warn-code"/>
   <x:anchor-alias value="warn-date"/>
   <x:anchor-alias value="warn-text"/>
<t>
   The "Warning" header field is used to carry additional information
   about the status or transformation of a message that might not be reflected
   in the message. This information is typically used to warn about possible
   incorrectness introduced by caching operations or transformations applied
   to the payload of the message.
</t>
<t>
   Warnings can be used for other purposes, both cache-related and otherwise.
   The use of a warning, rather than an error status code, distinguishes these
   responses from true failures.
</t>
<t>
   Warning header fields can in general be applied to any message, however some
   warn-codes are specific to caches and can only be applied to response
   messages.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Warning"/><iref primary="true" item="Grammar" subitem="warning-value"/><iref primary="true" item="Grammar" subitem="warn-code"/><iref primary="true" item="Grammar" subitem="warn-agent"/><iref primary="true" item="Grammar" subitem="warn-text"/><iref primary="true" item="Grammar" subitem="warn-date"/>
  <x:ref>Warning</x:ref>       = 1#<x:ref>warning-value</x:ref>
  
  <x:ref>warning-value</x:ref> = <x:ref>warn-code</x:ref> <x:ref>SP</x:ref> <x:ref>warn-agent</x:ref> <x:ref>SP</x:ref> <x:ref>warn-text</x:ref>
                                        [<x:ref>SP</x:ref> <x:ref>warn-date</x:ref>]
  
  <x:ref>warn-code</x:ref>  = 3<x:ref>DIGIT</x:ref>
  <x:ref>warn-agent</x:ref> = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
                  ; the name or pseudonym of the server adding
                  ; the Warning header field, for use in debugging
  <x:ref>warn-text</x:ref>  = <x:ref>quoted-string</x:ref>
  <x:ref>warn-date</x:ref>  = <x:ref>DQUOTE</x:ref> <x:ref>HTTP-date</x:ref> <x:ref>DQUOTE</x:ref>
</artwork></figure>
<t>
   Multiple warnings can be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number, only differing in warn-text.
</t>
<t>
   When this occurs, the user agent &SHOULD; inform the user of as many of
   them as possible, in the order that they appear in the response.
</t>
<t>
   Systems that generate multiple Warning header fields are encouraged to
   order them with this user agent behavior in mind. New Warning header fields
   are added after any existing Warning header fields.
</t>
<t>
   Warnings are assigned three digit warn-codes. The first digit indicates
   whether the Warning is required to be deleted from a stored response after
   validation:
   <list style="symbols">
      <t>1xx Warnings describe the freshness or validation status of the
      response, and so &MUST; be deleted by a cache after validation. They can
      only be generated by a cache when validating a cached entry, and
      &MUST-NOT; be generated in any other situation.</t>
      <t>2xx Warnings describe some aspect of the representation that is not
      rectified by a validation (for example, a lossy compression of the
      representation) and &MUST-NOT; be deleted by a cache after validation,
      unless a full response is returned, in which case they &MUST; be.</t>
   </list>
</t>
<t>
   If an implementation sends a message with one or more Warning header fields
   to a receiver whose version is HTTP/1.0 or lower, then the sender &MUST;
   include in each warning-value a warn-date that matches the
   <x:ref>Date</x:ref> header field in the message.
</t>
<t>
   If a system receives a message with a warning-value that includes a
   warn-date, and that warn-date is different from the <x:ref>Date</x:ref>
   value in the response, then that warning-value &MUST; be deleted from the
   message before storing, forwarding, or using it. (preventing the
   consequences of naive caching of Warning header fields.) If all of the
   warning-values are deleted for this reason, the Warning header field &MUST;
   be deleted as well.
</t>
<t>
   The following warn-codes are defined by this specification, each with a
   recommended warn-text in English, and a description of its meaning.
</t>

<section title="110 Response is Stale" anchor="warn.110">
  <iref primary="true" item="110 Response is Stale (warn code)" x:for-anchor=""/>
<t>
   A cache &SHOULD; include this whenever the returned response is stale.
</t>
</section>

<section title="111 Revalidation Failed" anchor="warn.111">
  <iref primary="true" item="111 Revalidation Failed (warn code)" x:for-anchor=""/>
<t>
   A cache &SHOULD; include this when returning a stale response because an
   attempt to validate the response failed, due to an inability to reach
   the server.
</t>
</section>

<section title="112 Disconnected Operation" anchor="warn.112">
  <iref primary="true" item="112 Disconnected Operation (warn code)" x:for-anchor=""/>
<t>
   A cache &SHOULD; include this if it is intentionally disconnected from
   the rest of the network for a period of time.
</t>
</section>

<section title="113 Heuristic Expiration" anchor="warn.113">
  <iref primary="true" item="113 Heuristic Expiration (warn code)" x:for-anchor=""/>
<t>
   A cache &SHOULD; include this if it heuristically chose a freshness
   lifetime greater than 24 hours and the response's age is greater than 24
   hours.
</t>
</section>

<section title="199 Miscellaneous Warning" anchor="warn.199">
  <iref primary="true" item="199 Miscellaneous Warning (warn code)" x:for-anchor=""/>
<t>
   The warning text can include arbitrary information to be presented to
   a human user, or logged. A system receiving this warning &MUST-NOT; take
   any automated action, besides presenting the warning to the user.
</t>
</section>

<section title="214 Transformation Applied" anchor="warn.214">
  <iref primary="true" item="214 Transformation Applied (warn code)" x:for-anchor=""/>
<t>
   &MUST; be added by a proxy if it applies any transformation to the
   representation, such as changing the content-coding, media-type, or
   modifying the representation data, unless this Warning code already appears
   in the response.
</t>
</section>

<section title="299 Miscellaneous Persistent Warning" anchor="warn.299">
  <iref primary="true" item="299 Miscellaneous Persistent Warning (warn code)" x:for-anchor=""/>
<t>
   The warning text can include arbitrary information to be presented to
   a human user, or logged. A system receiving this warning &MUST-NOT; take
   any automated action.
</t>
</section>

<section title="Warn Code Extensions" anchor="warn.code.extensions">
<t>
   The HTTP Warn Code Registry defines the name space for warn codes.
</t>
<t>
   A registration &MUST; include the following fields:
   <list style="symbols">
      <t>Warn Code (3 digits)</t>
      <t>Short Description</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to this name space require IETF Review (see <xref
   target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
<t>
   The registry itself is maintained at <eref
   target="http://www.iana.org/assignments/http-warn-codes"/>.
</t>
</section>
</section>
</section>

<section anchor="history.lists" title="History Lists">
<t>
   User agents often have history mechanisms, such as "Back" buttons and
   history lists, that can be used to redisplay a representation retrieved
   earlier in a session.
</t>
<t>
   The freshness model (<xref target="expiration.model"/>) does not
   necessarily apply to history mechanisms. I.e., a history mechanism can
   display a previous representation even if it has expired.
</t>
<t>
   This does not prohibit the history mechanism from telling the user that a
   view might be stale, or from honoring cache directives (e.g.,
   Cache-Control: no-store).
</t>
</section>


<section anchor="IANA.considerations" title="IANA Considerations">

<section title="Cache Directive Registry" 
   anchor="cache.directive.registration">
<t>
   The registration procedure for HTTP Cache Directives is defined by <xref
   target="cache.control.extensions"/> of this document.
</t>
<t>
   The HTTP Cache Directive Registry shall be created at <eref
   target="http://www.iana.org/assignments/http-cache-directives"/> and be
   populated with the registrations below:
</t>
<?BEGININC p6-cache.cache-directives ?>
<!--AUTOGENERATED FROM extract-cache-directives-defs.xslt, do not edit manually-->
<texttable xmlns:my="#my" align="left" suppress-title="true"
           anchor="iana.cache.directive.registration.table">
   <ttcol>Cache Directive</ttcol>
   <ttcol>Reference</ttcol>

   <c>max-age</c>
   <c>
      <xref target="cache-request-directive.max-age"/>, <xref target="cache-response-directive.max-age"/>
   </c>
   <c>max-stale</c>
   <c>
      <xref target="cache-request-directive.max-stale"/>
   </c>
   <c>min-fresh</c>
   <c>
      <xref target="cache-request-directive.min-fresh"/>
   </c>
   <c>must-revalidate</c>
   <c>
      <xref target="cache-response-directive.must-revalidate"/>
   </c>
   <c>no-cache</c>
   <c>
      <xref target="cache-request-directive.no-cache"/>, <xref target="cache-response-directive.no-cache"/>
   </c>
   <c>no-store</c>
   <c>
      <xref target="cache-request-directive.no-store"/>, <xref target="cache-response-directive.no-store"/>
   </c>
   <c>no-transform</c>
   <c>
      <xref target="cache-request-directive.no-transform"/>, <xref target="cache-response-directive.no-transform"/>
   </c>
   <c>only-if-cached</c>
   <c>
      <xref target="cache-request-directive.only-if-cached"/>
   </c>
   <c>private</c>
   <c>
      <xref target="cache-response-directive.private"/>
   </c>
   <c>proxy-revalidate</c>
   <c>
      <xref target="cache-response-directive.proxy-revalidate"/>
   </c>
   <c>public</c>
   <c>
      <xref target="cache-response-directive.public"/>
   </c>
   <c>s-maxage</c>
   <c>
      <xref target="cache-response-directive.s-maxage"/>
   </c>
   <c>stale-if-error</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="4"/>
   </c>
   <c>stale-while-revalidate</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="3"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.cache-directives ?>
</section>

<section title="Warn Code Registry" 
   anchor="warn.code.registration">
<t>
   The registration procedure for HTTP Warn Codes is defined by <xref
   target="warn.code.extensions"/> of this document.
</t>
<t>
   The HTTP Warn Code Registry shall be created at <eref
   target="http://www.iana.org/assignments/http-cache-directives"/> and be
   populated with the registrations below:
</t>
<?BEGININC p6-cache.iana-warn-codes ?>
<!--AUTOGENERATED FROM extract-warn-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.warn.code.registration.table">
   <ttcol>Warn Code</ttcol>
   <ttcol>Short Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>110</c>
   <c>Response is Stale</c>
   <c>
      <xref target="warn.110"/>
   </c>
   <c>111</c>
   <c>Revalidation Failed</c>
   <c>
      <xref target="warn.111"/>
   </c>
   <c>112</c>
   <c>Disconnected Operation</c>
   <c>
      <xref target="warn.112"/>
   </c>
   <c>113</c>
   <c>Heuristic Expiration</c>
   <c>
      <xref target="warn.113"/>
   </c>
   <c>199</c>
   <c>Miscellaneous Warning</c>
   <c>
      <xref target="warn.199"/>
   </c>
   <c>214</c>
   <c>Transformation Applied</c>
   <c>
      <xref target="warn.214"/>
   </c>
   <c>299</c>
   <c>Miscellaneous Persistent Warning</c>
   <c>
      <xref target="warn.299"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.iana-warn-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
  The Message Header Field Registry located at <eref  
  target="http://www.iana.org/assignments/message-headers/message-header-index.html" />
  shall be updated with the permanent registrations below (see <xref target="RFC3864" />):
</t>
<?BEGININC p6-cache.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Age</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.age"/>
   </c>
   <c>Cache-Control</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.cache-control"/>
   </c>
   <c>Expires</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expires"/>
   </c>
   <c>Pragma</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.pragma"/>
   </c>
   <c>Warning</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.warning"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task
   Force".
</t>
</section>
</section>

<section anchor="security.considerations" title="Security Considerations">
<t>
   Caches expose additional potential vulnerabilities, since the contents of
   the cache represent an attractive target for malicious exploitation.
   Because cache contents persist after an HTTP request is complete, an attack
   on the cache can reveal information long after a user believes that the
   information has been removed from the network. Therefore, cache contents
   need to be protected as sensitive information.
</t>
<t>
   Furthermore, the very use of a cache can bring about privacy concerns. For
   example, if two users share a cache, and the first one browses to a site,
   the second may be able to detect that the other has been to that site, 
   because the resources from it load more quickly, thanks to the cache.
</t>
<t>
   Implementation flaws might allow attackers to insert content into a cache 
   ("cache poisoning"), leading to compromise of clients that trust that
   content. Because of their nature, these attacks are difficult to mitigate.
</t>
<t>
   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing it to
   unauthorized parties.
</t>
<t>
   Note that the Set-Cookie response header <xref target="RFC6265"/> does not
   inhibit caching; a cacheable response with a Set-Cookie header can be (and
   often is) used to satisfy subsequent requests to caches. Servers who wish
   to control caching of these responses are encouraged to emit appropriate
   Cache-Control response headers.
</t>

</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>

</middle>

<back>
<references title="Normative References">

  <reference anchor="Part1">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;" />
    <x:source basename="p1-messaging" href="p1-messaging.xml">
      <x:defines>Content-Length</x:defines>
      <x:defines>Via</x:defines>
    </x:source>
  </reference>

  <reference anchor="Part2">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;" />
    <x:source basename="p2-semantics" href="p2-semantics.xml">
      <x:defines>2xx (Successful)</x:defines>
      <x:defines>200 (OK)</x:defines>
      <x:defines>203 (Non-Authoritative Information)</x:defines>
      <x:defines>3xx (Redirection)</x:defines>
      <x:defines>300 (Multiple Choices)</x:defines>
      <x:defines>301 (Moved Permanently)</x:defines>
      <x:defines>404 (Not Found)</x:defines>
      <x:defines>410 (Gone)</x:defines>
      <x:defines>5xx (Server Error)</x:defines>
      <x:defines>504 (Gateway Timeout)</x:defines>
      <x:defines>Content-Encoding</x:defines>
      <x:defines>Content-Location</x:defines>
      <x:defines>Content-Type</x:defines>
      <x:defines>Date</x:defines>
      <x:defines>Location</x:defines>
      <x:defines>Vary</x:defines>
    </x:source>
  </reference>

  <reference anchor="Part4">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;" />
    <x:source basename="p4-conditional" href="p4-conditional.xml">
      <x:defines>304</x:defines>
      <x:defines>304 (Not Modified)</x:defines>
      <x:defines>ETag</x:defines>
      <x:defines>If-Modified-Since</x:defines>
      <x:defines>If-None-Match</x:defines>
      <x:defines>Last-Modified</x:defines>
    </x:source>
  </reference>

  <reference anchor="Part5">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;" />
    <x:source basename="p5-range" href="p5-range.xml">
      <x:defines>206 (Partial Content)</x:defines>
      <x:defines>Content-Range</x:defines>
      <x:defines>Range</x:defines>
    </x:source>
  </reference>

  <reference anchor="Part7">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-&ID-VERSION;" />
    <x:source basename="p7-auth" href="p7-auth.xml">
      <x:defines>Authorization</x:defines>
    </x:source>
  </reference>

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author fullname="Scott Bradner" initials="S." surname="Bradner">
        <organization>Harvard University</organization>
        <address><email>sob@harvard.edu</email></address>
      </author>
      <date month="March" year="1997" />
    </front>
    <seriesInfo name="BCP" value="14" />
    <seriesInfo name="RFC" value="2119" />
  </reference>

  <reference anchor="RFC5234">
    <front>
      <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
      <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
        <organization>Brandenburg InternetWorking</organization>
        <address>
          <email>dcrocker@bbiw.net</email>
        </address>  
      </author>
      <author initials="P." surname="Overell" fullname="Paul Overell">
        <organization>THUS plc.</organization>
        <address>
          <email>paul.overell@thus.net</email>
        </address>
      </author>
      <date month="January" year="2008"/>
    </front>
    <seriesInfo name="STD" value="68"/>
    <seriesInfo name="RFC" value="5234"/>
  </reference>
  
</references>

<references title="Informative References">

  <reference anchor="RFC1305">
    <front>
      <title>Network Time Protocol (Version 3) Specification, Implementation</title>
      <author fullname="David L. Mills" initials="D." surname="Mills">
        <organization>University of Delaware, Electrical Engineering Department</organization>
        <address><email>mills@udel.edu</email></address>
      </author>
      <date month="March" year="1992" />
    </front>
    <seriesInfo name="RFC" value="1305" />
  </reference>

  <reference anchor="RFC2616">
    <front>
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
      <author fullname="R. Fielding" initials="R." surname="Fielding">
        <organization>University of California, Irvine</organization>
        <address><email>fielding@ics.uci.edu</email></address>
      </author>
      <author fullname="J. Gettys" initials="J." surname="Gettys">
        <organization>W3C</organization>
        <address><email>jg@w3.org</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>Compaq Computer Corporation</organization>
        <address><email>mogul@wrl.dec.com</email></address>
      </author>
      <author fullname="H. Frystyk" initials="H." surname="Frystyk">
        <organization>MIT Laboratory for Computer Science</organization>
        <address><email>frystyk@w3.org</email></address>
      </author>
      <author fullname="L. Masinter" initials="L." surname="Masinter">
        <organization>Xerox Corporation</organization>
        <address><email>masinter@parc.xerox.com</email></address>
      </author>
      <author fullname="P. Leach" initials="P." surname="Leach">
        <organization>Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee">
        <organization>W3C</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <date month="June" year="1999" />
    </front>
    <seriesInfo name="RFC" value="2616" />
  </reference>

  <reference anchor="RFC3864">
    <front>
      <title>Registration Procedures for Message Header Fields</title>
      <author fullname="G. Klyne" initials="G." surname="Klyne">
        <organization>Nine by Nine</organization>
        <address><email>GK-IETF@ninebynine.org</email></address>
      </author>
      <author fullname="M. Nottingham" initials="M." surname="Nottingham">
        <organization>BEA Systems</organization>
        <address><email>mnot@pobox.com</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>HP Labs</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <date month="September" year="2004" />
    </front>
    <seriesInfo name="BCP" value="90" />
    <seriesInfo name="RFC" value="3864" />
  </reference>

  <reference anchor='RFC5226'>
    <front>
      <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
      <author initials='T.' surname='Narten' fullname='T. Narten'>
        <organization>IBM</organization>
        <address><email>narten@us.ibm.com</email></address>
      </author>
      <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
        <organization>Google</organization>
        <address><email>Harald@Alvestrand.no</email></address>
      </author>
      <date year='2008' month='May' />
    </front>
    <seriesInfo name='BCP' value='26' />
    <seriesInfo name='RFC' value='5226' />
  </reference>

  <reference anchor='RFC5861'>
    <front>
      <title abbrev="HTTP stale controls">HTTP Cache-Control Extensions for Stale Content</title>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization>Yahoo! Inc.</organization>
        <address><email>mnot@yahoo-inc.com</email></address>
      </author>
      <date month="April" year="2010"/>
    </front>
    <seriesInfo name='RFC' value='5861' />
  </reference>

  <reference anchor="RFC6265">
    <front>
      <title>HTTP State Management Mechanism</title>
      <author initials="A." surname="Barth" fullname="Adam Barth">
        <organization abbrev="U.C. Berkeley">
          University of California, Berkeley
        </organization>
        <address><email>abarth@eecs.berkeley.edu</email></address>
      </author>
      <date year="2011" month="April" />
    </front>
    <seriesInfo name="RFC" value="6265"/>
  </reference>

</references>

<section anchor="changes.from.rfc.2616" title="Changes from RFC 2616">
<t>
  Caching-related text has been substantially rewritten for clarity.
</t>
<t>
  The algorithm for calculating age is now less conservative.
  (<xref target="age.calculations"/>)
</t>
<t>
  Caches are now required to handle dates with timezones as if they're 
  invalid, because it's not possible to accurately guess.
  (<xref target="age.calculations"/>)
</t>
<t>
  The <x:ref>Content-Location</x:ref> response header field is no longer used
  to determine the appropriate response to use when validating.
  (<xref target="validation.model" />)
</t>
<t>
  The algorithm for selecting a cached negotiated response to use has been
  clarified in several ways. In particular, it now explicitly allows
  header-specific canonicalization when processing selecting header fields.
  (<xref target="caching.negotiated.responses" />)
</t>
<t>
  Requirements regarding denial of service attack avoidance when performing
  invalidation have been clarified.
  (<xref target="invalidation.after.updates.or.deletions" />)
</t>
<t>
  Cache invalidation only occurs when a successful response is received.
  (<xref target="invalidation.after.updates.or.deletions" />)
</t>
<t>
  The conditions under which an authenticated response can be cached have been
  clarified.
  (<xref target="caching.authenticated.responses" />)
</t>
<t>
  The one-year limit on Expires header field values has been removed; instead,
  the reasoning for using a sensible value is given.
  (<xref target="header.expires" />)
</t>
<t>
  The Pragma header field is now only defined for backwards compatibility;
  future pragmas are deprecated.
  (<xref target="header.pragma" />)
</t>
<t>
  Cache directives are explicitly defined to be case-insensitive.
  (<xref target="header.cache-control" />)
</t>
<t>
  Handling of multiple instances of cache directives when only one is 
  expected is now defined.
  (<xref target="header.cache-control" />)
</t>
<t>
  The qualified forms of the private and no-cache cache directives are noted
  to not be widely implemented; e.g., "private=foo" is interpreted by many
  caches as simply "private". Additionally, the meaning of the qualified
  form of no-cache has been clarified.
  (<xref target="cache-response-directive" />)
</t>
<t>
  The "no-store" cache request directive doesn't apply to responses; i.e.,
  a cache can satisfy a request with no-store on it, and does not invalidate
  it.
  (<xref target="cache-request-directive.no-store" />)
</t>
<t>
  The meaning of the "public" cache response directive has been refined to
  be less vague.
  (<xref target="cache-response-directive.public" />)
</t>
<t>
  The "no-cache" response cache directive's meaning has been clarified.
  (<xref target="cache-response-directive.no-cache" />)
</t>
<t>
  New status codes can now define that caches are allowed to use heuristic
  freshness with them.
  (<xref target="heuristic.freshness" />)
</t>
<t>
  Caches are now allow to calculate heuristic freshness for URLs with query
  components.
  (<xref target="heuristic.freshness" />)
</t>
<t>
  Some requirements regarding production of the <x:ref>Warning</x:ref> 
  header have been relaxed, as it is not widely implemented.
  (<xref target="header.warning" />)
</t>
<t>
  The <x:ref>Warning</x:ref> header field no longer uses RFC 2047 encoding,
  nor allows multiple languages, as these aspects were not implemented.
  (<xref target="header.warning" />)
</t>
<t>
  This specification introduces the Cache Directive and Warn Code Registries,
  and defines considerations for new cache directives.
  (<xref target="cache.control.extensions"/> and <xref target="warn.code.extensions"/>)
</t>
</section>

<section title="Imported ABNF" anchor="imported.abnf">
   <x:anchor-alias value="ALPHA"/>
   <x:anchor-alias value="CR"/>
   <x:anchor-alias value="DIGIT"/>
   <x:anchor-alias value="DQUOTE"/>
   <x:anchor-alias value="LF"/>
   <x:anchor-alias value="OCTET"/>
   <x:anchor-alias value="SP"/>
   <x:anchor-alias value="VCHAR"/>
   <x:anchor-alias value="quoted-string"/>
   <x:anchor-alias value="token"/>
   <x:anchor-alias value="OWS"/>
   <x:anchor-alias value="field-name"/>
   <x:anchor-alias value="HTTP-date"/>
   <x:anchor-alias value="port"/>
   <x:anchor-alias value="pseudonym"/>
   <x:anchor-alias value="uri-host"/>
<t>
   The following core rules are included by reference, as defined in <xref
   target="RFC5234" x:fmt="of" x:sec="B.1"/>: ALPHA (letters), CR (carriage
   return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit
   sequence of data), SP (space), and VCHAR (any visible US-ASCII character).
</t>
<t>
   The rules below are defined in <xref target="Part1"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &whitespace;&gt;
  <x:ref>field-name</x:ref>    = &lt;field-name, defined in &header-fields;&gt;
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in &field-components;&gt;
  <x:ref>token</x:ref>         = &lt;token, defined in &field-components;&gt;

  <x:ref>port</x:ref>          = &lt;port, defined in &uri;&gt;
  <x:ref>pseudonym</x:ref>     = &lt;pseudonym, defined in &header-via;&gt; 
  <x:ref>uri-host</x:ref>      = &lt;uri-host, defined in &uri;&gt;
</artwork></figure>
<t>
   The rules below are defined in other parts: 
</t>
<figure><artwork type="abnf2616">
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &http-date;&gt;
</artwork></figure>
</section>

<?BEGININC p6-cache.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p6-cache.parsed-abnf">
<x:ref>Age</x:ref> = delta-seconds

<x:ref>Cache-Control</x:ref> = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

<x:ref>Expires</x:ref> = HTTP-date

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part2], Section 8.1.1.1&gt;

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 3.2.3&gt;

<x:ref>Pragma</x:ref> = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

<x:ref>Warning</x:ref> = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value ]
 )

<x:ref>cache-directive</x:ref> = token [ "=" ( token / quoted-string ) ]

<x:ref>delta-seconds</x:ref> = 1*DIGIT

<x:ref>extension-pragma</x:ref> = token [ "=" ( token / quoted-string ) ]

<x:ref>field-name</x:ref> = &lt;field-name, defined in [Part1], Section 3.2&gt;

<x:ref>port</x:ref> = &lt;port, defined in [Part1], Section 2.7&gt;
<x:ref>pragma-directive</x:ref> = "no-cache" / extension-pragma
<x:ref>pseudonym</x:ref> = &lt;pseudonym, defined in [Part1], Section 5.7.1&gt;

<x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in [Part1], Section 3.2.6&gt;

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 3.2.6&gt;

<x:ref>uri-host</x:ref> = &lt;uri-host, defined in [Part1], Section 2.7&gt;

<x:ref>warn-agent</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>warn-code</x:ref> = 3DIGIT
<x:ref>warn-date</x:ref> = DQUOTE HTTP-date DQUOTE
<x:ref>warn-text</x:ref> = quoted-string
<x:ref>warning-value</x:ref> = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]
</artwork>
</figure>
</section>
<?ENDINC p6-cache.abnf-appendix ?>

<section anchor="change.log" title="Change Log (to be removed by RFC Editor before publication)">
<t>
  Changes up to the first Working Group Last Call draft are summarized
  in <eref target="http://trac.tools.ietf.org/html/draft-ietf-httpbis-p6-cache-19#appendix-C"/>.
</t>

<section title="Since draft-ietf-httpbis-p6-cache-19" anchor="changes.since.19">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/307"/>:
      "untangle Cache-Control ABNF"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/353"/>:
      "Multiple values in Cache-Control header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/355"/>:
      "Case sensitivity of header fields in CC values"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/356"/>:
      "Spurious 'MAYs'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/360"/>:
      "enhance considerations for new cache control directives"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/361"/>:
      "ABNF requirements for recipients"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/368"/>:
      "note introduction of new IANA registries as normative changes"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/373"/>:
      "broken prose in description of 'Vary'"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-20" anchor="changes.since.20">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/375"/>:
      "'Most Conservative'"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols">
    <t>
      Conformance criteria and considerations regarding error handling are
      now defined in Part 1.
    </t>
    <t>
      Move definition of "Vary" header field into Part 2.
    </t>
    <t>
      Add security considerations with respect to cache poisoning and
      the "Set-Cookie" header field.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-21" anchor="changes.since.21">
<t>
  None yet.
</t>
</section>

</section>
  </back>
</rfc>
