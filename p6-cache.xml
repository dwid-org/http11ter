<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "February">
  <!ENTITY ID-YEAR "2009">
  <!ENTITY notation                    "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation-abnf               "<xref target='Part1' x:rel='#notation.abnf' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules                 "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                   "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conditional                 "<xref target='Part4' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY combining-byte-ranges       "<xref target='Part5' x:rel='#combining.byte.ranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-length               "<xref target='Part3' x:rel='#entity.length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY full-date                   "<xref target='Part1' x:rel='#full.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-authorization        "<xref target='Part7' x:rel='#header.authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-connection           "<xref target='Part1' x:rel='#header.connection' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                 "<xref target='Part1' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-via                  "<xref target='Part1' x:rel='#header.via' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-headers             "<xref target='Part1' x:rel='#message.headers' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-length              "<xref target='Part1' x:rel='#message.length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods                "<xref target='Part2' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY server-driven-negotiation   "<xref target='Part3' x:rel='#server-driven.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                         "<xref target='Part1' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="draft"
     ipr="full3978" docName="draft-ietf-httpbis-p6-cache-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<front>

  <title abbrev="HTTP/1.1, Part 6">HTTP/1.1, part 6: Caching</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <postal>
        <street>23 Corporate Plaza DR, Suite 280</street>
        <city>Newport Beach</city>
        <region>CA</region>
        <code>92660</code>
        <country>USA</country>
      </postal>
      <phone>+1-949-706-5300</phone>
      <facsimile>+1-949-706-5305</facsimile>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization>One Laptop per Child</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@laptop.org</email>
      <uri>http://www.laptop.org/</uri>
    </address>
  </author>
  
  <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author initials="L." surname="Masinter" fullname="Larry Masinter">
    <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  
  <author initials="P." surname="Leach" fullname="Paul J. Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>
   
  <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>	
      <facsimile>+49 251 2807761</facsimile>	
      <email>julian.reschke@greenbytes.de</email>	
      <uri>http://greenbytes.de/tech/webdav/</uri>	
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World Wide Web global information
   initiative since 1990. This document is Part 6 of the seven-part specification
   that defines the protocol referred to as "HTTP/1.1" and, taken together,
   obsoletes RFC 2616.  Part 6 defines requirements on HTTP caches
   and the associated header fields that control cache behavior or indicate
   cacheable response messages.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org). The current issues list is
    at <eref target="http://tools.ietf.org/wg/httpbis/trac/report/11"/>
    and related documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.05"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="caching">
<t>
   HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches, and includes
   a number of elements intended to make caching work as well as possible.
   Because these elements interact with each other, it is useful to describe
   the caching design of HTTP separately.  This document defines aspects of
   HTTP/1.1 related to caching and reusing response messages.
</t>

<section title="Purpose" anchor="intro.purpose">
<iref item="cache"/>
<t>
   An HTTP <x:dfn>cache</x:dfn> is a local store of response messages
   and the subsystem that controls its message storage, retrieval, and
   deletion. A cache stores cacheable responses in order to reduce the
   response time and network bandwidth consumption on future, equivalent
   requests. Any client or server may include a cache, though a cache
   cannot be used by a server that is acting as a tunnel.
</t>
<t>
   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to reuse a prior response
   message to satisfy a current request.  In some cases, the existing response
   can be reused without the need for a network request, reducing latency and
   network round-trips; we use an "expiration" mechanism for this purpose
   (see <xref target="expiration.model"/>).  Even when a new request is required,
   it is often possible to reuse all or parts of the payload of a prior response
   to satisfy the request, thereby reducing network bandwidth usage; we use a
   "validation" mechanism for this purpose (see <xref target="validation.model"/>).
</t>
<iref item="semantically transparent"/>
<t>
   A cache behaves in a "<x:dfn>semantically transparent</x:dfn>" manner, with
   respect to a particular response, when its use affects neither the
   requesting client nor the origin server, except to improve
   performance. When a cache is semantically transparent, the client
   receives exactly the same response status and payload
   that it would have received had its request been handled directly
   by the origin server.
</t>
<t>
   In an ideal world, all interactions with an HTTP cache would be
   semantically transparent.  However, for some resources, semantic
   transparency is not always necessary and can be effectively traded
   for the sake of bandwidth scaling, disconnected operation, and
   high availability.  HTTP/1.1 allows origin servers, caches,
   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed
  <list style="symbols">
     <t>only by an explicit protocol-level request when relaxed by
        client or origin server</t>

     <t>only with an explicit warning to the end user when relaxed by
        cache or client</t>
  </list>
</t>
<t>
   Therefore, HTTP/1.1 provides these important elements:
  <list style="numbers">
      <t>Protocol features that provide full semantic transparency when
         this is required by all parties.</t>

      <t>Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.</t>

      <t>Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.</t>
  </list>
</t>
<t>
   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.
  <list><t>
      <x:h>Note:</x:h> The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.
    </t></list>
</t>
</section>

<section title="Terminology" anchor="intro.terminology">
<t>
   This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, HTTP caching.
</t>
<t>
  <iref item="cacheable"/>
  <x:dfn>cacheable</x:dfn>
  <list>
    <t>
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests.
      Even when a response is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request.
    </t>
  </list>
</t>
<t>
  <iref item="first-hand"/>
  <x:dfn>first-hand</x:dfn>
  <list>
    <t>
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.
    </t>
  </list>
</t>
<t>
  <iref item="explicit expiration time"/>
  <x:dfn>explicit expiration time</x:dfn>
  <list>
    <t>
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.
    </t>
  </list>
</t>
<t>
  <iref item="heuristic expiration time"/>
  <x:dfn>heuristic expiration time</x:dfn>
  <list>
    <t>
      An expiration time assigned by a cache when no explicit expiration
      time is available.
    </t>
  </list>
</t>
<t>
  <iref item="age"/>
  <x:dfn>age</x:dfn>
  <list>
    <t>
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.
    </t>
  </list>
</t>
<t>
  <iref item="freshness lifetime"/>
  <x:dfn>freshness lifetime</x:dfn>
  <list>
    <t>
      The length of time between the generation of a response and its
      expiration time.
    </t>
  </list>
</t>
<t>
  <iref item="fresh"/>
  <x:dfn>fresh</x:dfn>
  <list>
    <t>
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.
    </t>
  </list>
</t>
<t>
  <iref item="stale"/>
  <x:dfn>stale</x:dfn>
  <list>
    <t>
      A response is stale if its age has passed its freshness lifetime.
    </t>
  </list>
</t>
<t>
  <iref item="validator"/>
  <x:dfn>validator</x:dfn>
  <list>
    <t>
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.
    </t>
  </list>
</t>
</section>

<section title="Requirements" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   An implementation is not compliant if it fails to satisfy one or more
   of the &MUST; or &REQUIRED; level requirements for the protocols it
   implements. An implementation that satisfies all the &MUST; or &REQUIRED;
   level and all the &SHOULD; level requirements for its protocols is said
   to be "unconditionally compliant"; one that satisfies all the &MUST;
   level requirements but not all the &SHOULD; level requirements for its
   protocols is said to be "conditionally compliant."
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="WSP"/>
<t>
  This specification uses the ABNF syntax defined in &notation;.
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space),
  VCHAR (any visible USASCII character),
  and WSP (whitespace).
</t>

<section title="Core Rules" anchor="core.rules">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="OWS"/>
<t>
  The core rules below are defined in &basic-rules;:
</t>
<figure><artwork type="abnf2616">
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in &basic-rules;&gt;
  <x:ref>token</x:ref>         = &lt;token, defined in &basic-rules;&gt;
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &basic-rules;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification" anchor="abnf.dependencies">
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="HTTP-date"/>
  <x:anchor-alias value="port"/>
  <x:anchor-alias value="pseudonym"/>
  <x:anchor-alias value="uri-host"/>
<t>
  The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part1--><artwork type="abnf2616">
  <x:ref>field-name</x:ref>    = &lt;field-name, defined in &message-headers;&gt;
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &full-date;&gt;
  <x:ref>port</x:ref>          = &lt;port, defined in &uri;&gt;
  <x:ref>pseudonym</x:ref>     = &lt;pseudonym, defined in &header-via;&gt; 
  <x:ref>uri-host</x:ref>      = &lt;uri-host, defined in &uri;&gt;
</artwork></figure>
</section>

</section>

</section>


<section title="Overview" anchor="caching.overview">
<section title="Cache Correctness" anchor="cache.correctness">
<t>
   A correct cache &MUST; respond to a request with the most up-to-date
   response held by the cache that is appropriate to the request (see
   Sections <xref target="disambiguating.expiration.values" format="counter"/>,
   <xref target="disambiguating.multiple.responses" format="counter"/>,
   and <xref target="cache.replacement" format="counter"/>) which meets one of the following
   conditions:
  <list style="numbers">
      <t>It has been checked for equivalence with what the origin server
         would have returned by revalidating the response with the
         origin server (<xref target="validation.model"/>);</t>

      <t>It is "fresh enough" (see <xref target="expiration.model"/>). In the default case,
         this means it meets the least restrictive freshness requirement
         of the client, origin server, and cache (see <xref target="header.cache-control"/>); if
         the origin server so specifies, it is the freshness requirement
         of the origin server alone.

         If a stored response is not "fresh enough" by the most
         restrictive freshness requirement of both the client and the
         origin server, in carefully considered circumstances the cache
         &MAY; still return the response with the appropriate Warning
         header (see Sections <xref target="exceptions.to.the.rules.and.warnings" format="counter"/>
         and <xref target="header.warning" format="counter"/>), unless such a response
         is prohibited (e.g., by a "no-store" cache-directive, or by a
         "no-cache" cache-request-directive; see <xref target="header.cache-control"/>).</t>

      <t>It is an appropriate 304 (Not Modified), 305 (Use Proxy),
         or error (4xx or 5xx) response message.</t>
  </list>
</t>
<t>
   If the cache can not communicate with the origin server, then a
   correct cache &SHOULD; respond as above if the response can be
   correctly served from the cache; if not it &MUST; return an error or
   warning indicating that there was a communication failure.
</t>
<t>
   If a cache receives a response (either an entire response, or a 304
   (Not Modified) response) that it would normally forward to the
   requesting client, and the received response is no longer fresh, the
   cache &SHOULD; forward it to the requesting client without adding a new
   Warning (but without removing any existing Warning headers). A cache
   &SHOULD-NOT;  attempt to revalidate a response simply because that
   response became stale in transit; this might lead to an infinite
   loop. A user agent that receives a stale response without a Warning
   &MAY; display a warning indication to the user.
</t>
</section>

<section title="Warnings" anchor="warnings">
<t>
   Whenever a cache returns a response that is neither first-hand nor
   "fresh enough" (in the sense of condition 2 in <xref target="cache.correctness"/>), it
   &MUST; attach a warning to that effect, using a Warning general-header.
   The Warning header and the currently defined warnings are described
   in <xref target="header.warning"/>. The warning allows clients to take appropriate
   action.
</t>
<t>
   Warnings &MAY; be used for other purposes, both cache-related and
   otherwise. The use of a warning, rather than an error status code,
   distinguish these responses from true failures.
</t>
<t>
   Warnings are assigned three digit warn-codes. The first digit
   indicates whether the Warning &MUST; or &MUST-NOT; be deleted from a
   stored cache entry after a successful revalidation:
</t>
<t>
  <list style="hanging">
    <t hangText="1xx">Warnings that describe the freshness or revalidation status of
     the response, and so &MUST; be deleted after a successful
     revalidation. 1xx warn-codes &MAY; be generated by a cache only when
     validating a cached entry. It &MUST-NOT; be generated by clients.</t>

    <t hangText="2xx">Warnings that describe some aspect of the entity body or entity
     headers that is not rectified by a revalidation (for example, a
     lossy compression of the entity bodies) and which &MUST-NOT; be
     deleted after a successful revalidation.</t>
    </list>
</t>
<t>
   See <xref target="header.warning"/> for the definitions of the codes themselves.
</t>
<t>
   HTTP/1.0 caches will cache all Warnings in responses, without
   deleting the ones in the first category. Warnings in responses that
   are passed to HTTP/1.0 caches carry an extra warning-date field,
   which prevents a future HTTP/1.1 recipient from believing an
   erroneously cached Warning.
</t>
<t>
   Warnings also carry a warning text. The text &MAY; be in any
   appropriate natural language (perhaps based on the client's Accept
   headers), and include an &OPTIONAL; indication of what character set is
   used.
</t>
<t>
   Multiple warnings &MAY; be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number. For example, a server might provide the same warning with
   texts in both English and Basque.
</t>
<t>
   When multiple warnings are attached to a response, it might not be
   practical or reasonable to display all of them to the user. This
   version of HTTP does not specify strict priority rules for deciding
   which warnings to display and in what order, but does suggest some
   heuristics.
</t>
</section>

<section title="Cache-control Mechanisms" anchor="cache-control.mechanisms">
<t>
   The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.
</t>
<t>
   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However,
   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   "max-stale" or "public").
</t>
<t>
   The cache-control directives are described in detail in <xref target="header.cache-control"/>.
</t>
</section>

<section title="Explicit User Agent Warnings" anchor="explicit.ua.warnings">
<t>
   Many user agents make it possible for users to override the basic
   caching mechanisms. For example, the user agent might allow the user
   to specify that cached entities (even explicitly stale ones) are
   never validated. Or the user agent might habitually add "Cache-Control:
   max-stale=3600" to every request. The user agent &SHOULD-NOT; 
   default to either non-transparent behavior, or behavior that results
   in abnormally ineffective caching, but &MAY; be explicitly configured
   to do so by an explicit action of the user.
</t>
<t>
   If the user has overridden the basic caching mechanisms, the user
   agent &SHOULD; explicitly indicate to the user whenever this results in
   the display of information that might not meet the server's
   transparency requirements (in particular, if the displayed entity is
   known to be stale). Since the protocol normally allows the user agent
   to determine if responses are stale or not, this indication need only
   be displayed when this actually happens. The indication need not be a
   dialog box; it could be an icon (for example, a picture of a rotting
   fish) or some other indicator.
</t>
<t>
   If the user has overridden the caching mechanisms in a way that would
   abnormally reduce the effectiveness of caches, the user agent &SHOULD;
   continually indicate this state to the user (for example, by a
   display of a picture of currency in flames) so that the user does not
   inadvertently consume excess resources or suffer from excessive
   latency.
</t>
</section>

<section title="Exceptions to the Rules and Warnings" anchor="exceptions.to.the.rules.and.warnings">
<t>
   In some cases, the operator of a cache &MAY; choose to configure it to
   return stale responses even when not requested by clients. This
   decision ought not be made lightly, but may be necessary for reasons
   of availability or performance, especially when the cache is poorly
   connected to the origin server. Whenever a cache returns a stale
   response, it &MUST; mark it as such (using a Warning header) enabling
   the client software to alert the user that there might be a potential
   problem.
</t>
<t>
   It also allows the user agent to take steps to obtain a first-hand or
   fresh response. For this reason, a cache &SHOULD-NOT;  return a stale
   response if the client explicitly requests a first-hand or fresh one,
   unless it is impossible to comply for technical or policy reasons.
</t>
</section>

<section title="Client-controlled Behavior" anchor="client-controlled.behavior">
<t>
   While the origin server (and to a lesser extent, intermediate caches,
   by their contribution to the age of a response) are the primary
   source of expiration information, in some cases the client might need
   to control a cache's decision about whether to return a cached
   response without validating it. Clients do this using several
   directives of the Cache-Control header.
</t>
<t>
   A client's request &MAY; specify the maximum age it is willing to
   accept of an unvalidated response; specifying a value of zero forces
   the cache(s) to revalidate all responses. A client &MAY; also specify
   the minimum time remaining before a response expires. Both of these
   options increase constraints on the behavior of caches, and so cannot
   further relax the cache's approximation of semantic transparency.
</t>
<t>
   A client &MAY; also specify that it will accept stale responses, up to
   some maximum amount of staleness. This loosens the constraints on the
   caches, and so might violate the origin server's specified
   constraints on semantic transparency, but might be necessary to
   support disconnected operation, or high availability in the face of
   poor connectivity.
</t>
</section>
</section>

<section title="Expiration Model" anchor="expiration.model">

<section title="Server-Specified Expiration" anchor="server-specified.expiration">
<t>
   HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response &MAY; be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.
</t>
<t>
   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen.
</t>
<t>
   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.
</t>
<t>
   If an origin server wishes to force a semantically transparent cache
   to validate every request, it &MAY; assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache &SHOULD; validate it before using it for subsequent requests. See
   <xref target="cache.revalidation.and.reload.controls"/> for a more restrictive way to force revalidation.
</t>
<t>
   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it &SHOULD; use the "must-revalidate"
   cache-control directive (see <xref target="header.cache-control"/>).
</t>
<t>
   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.
</t>
<t>
   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See <xref target="history.lists"/> for an explanation of the difference between caches
   and history mechanisms.
</t>
</section>

<section title="Heuristic Expiration" anchor="heuristic.expiration">
<t>
   Since origin servers do not always provide explicit expiration times,
   HTTP caches typically assign heuristic expiration times, employing
   algorithms that use other header values (such as the Last-Modified
   time) to estimate a plausible expiration time. The HTTP/1.1
   specification does not provide specific algorithms, but does impose
   worst-case constraints on their results. Since heuristic expiration
   times might compromise semantic transparency, they ought to be used
   cautiously, and we encourage origin servers to provide explicit
   expiration times as much as possible.
</t>
</section>

<section title="Age Calculations" anchor="age.calculations">
<t>
   In order to know if a cached entry is fresh, a cache needs to know if
   its age exceeds its freshness lifetime. We discuss how to calculate
   the latter in <xref target="expiration.calculations"/>; this section describes how to calculate
   the age of a response or cache entry.
</t>
<t>
   In this discussion, we use the term "now" to mean "the current value
   of the clock at the host performing the calculation." Hosts that use
   HTTP, but especially hosts running origin servers and caches, &SHOULD;
   use NTP <xref target="RFC1305"/> or some similar protocol to synchronize their clocks to
   a globally accurate time standard.
</t>
<t>
   HTTP/1.1 requires origin servers to send a Date header, if possible,
   with every response, giving the time at which the response was
   generated (see &header-date;). We use the term "date_value" to denote
   the value of the Date header, in a form appropriate for arithmetic
   operations.
</t>
<t>
   HTTP/1.1 uses the Age response-header to convey the estimated age of
   the response message when obtained from a cache. The Age field value
   is the cache's estimate of the amount of time since the response was
   generated or revalidated by the origin server.
</t>
<t>
   In essence, the Age value is the sum of the time that the response
   has been resident in each of the caches along the path from the
   origin server, plus the amount of time it has been in transit along
   network paths.
</t>
<t>
   We use the term "age_value" to denote the value of the Age header, in
   a form appropriate for arithmetic operations.
</t>
<t>
   A response's age can be calculated in two entirely independent ways:
  <list style="numbers">
      <t>now minus date_value, if the local clock is reasonably well
         synchronized to the origin server's clock. If the result is
         negative, the result is replaced by zero.</t>

      <t>age_value, if all of the caches along the response path
         implement HTTP/1.1.</t>
  </list>
</t>
<t>
   Given that we have two independent ways to compute the age of a
   response when it is received, we can combine these as
</t>
<figure><artwork type="code">
    corrected_received_age = max(now - date_value, age_value)
</artwork></figure>
<t>
   and as long as we have either nearly synchronized clocks or all-HTTP/1.1
   paths, one gets a reliable (conservative) result.
</t>
<t>
   Because of network-imposed delays, some significant interval might
   pass between the time that a server generates a response and the time
   it is received at the next outbound cache or client. If uncorrected,
   this delay could result in improperly low ages.
</t>
<t>
   Because the request that resulted in the returned Age value must have
   been initiated prior to that Age value's generation, we can correct
   for delays imposed by the network by recording the time at which the
   request was initiated. Then, when an Age value is received, it &MUST;
   be interpreted relative to the time the request was initiated, not
   the time that the response was received. This algorithm results in
   conservative behavior no matter how much delay is experienced. So, we
   compute:
</t>
<figure><artwork type="code">
   corrected_initial_age = corrected_received_age
                         + (now - request_time)
</artwork></figure>
<t>
   where "request_time" is the time (according to the local clock) when
   the request that elicited this response was sent.
</t>
<t>
   Summary of age calculation algorithm, when a cache receives a
   response:
</t>
<figure><artwork type="code">
   /*
    * age_value
    *      is the value of Age: header received by the cache with
    *              this response.
    * date_value
    *      is the value of the origin server's Date: header
    * request_time
    *      is the (local) time when the cache made the request
    *              that resulted in this cached response
    * response_time
    *      is the (local) time when the cache received the
    *              response
    * now
    *      is the current (local) time
    */

   apparent_age = max(0, response_time - date_value);
   corrected_received_age = max(apparent_age, age_value);
   response_delay = response_time - request_time;
   corrected_initial_age = corrected_received_age + response_delay;
   resident_time = now - response_time;
   current_age   = corrected_initial_age + resident_time;
</artwork></figure>
<t>
   The current_age of a cache entry is calculated by adding the amount
   of time (in seconds) since the cache entry was last validated by the
   origin server to the corrected_initial_age. When a response is
   generated from a cache entry, the cache &MUST; include a single Age
   header field in the response with a value equal to the cache entry's
   current_age.
</t>
<t>
   The presence of an Age header field in a response implies that a
   response is not first-hand. However, the converse is not true, since
   the lack of an Age header field in a response does not imply that the
   response is first-hand unless all caches along the request path are
   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement
   the Age header field).
</t>
</section>

<section title="Expiration Calculations" anchor="expiration.calculations">
<t>
   In order to decide whether a response is fresh or stale, we need to
   compare its freshness lifetime to its age. The age is calculated as
   described in <xref target="age.calculations"/>; this section describes how to calculate
   the freshness lifetime, and to determine if a response has expired.
   In the discussion below, the values can be represented in any form
   appropriate for arithmetic operations.
</t>
<t>
   We use the term "expires_value" to denote the value of the Expires
   header. We use the term "max_age_value" to denote an appropriate
   value of the number of seconds carried by the "max-age" directive of
   the Cache-Control header in a response (see <xref target="modifications.of.the.basic.expiration.mechanism"/>).
</t>
<t>
   The max-age directive takes priority over Expires, so if max-age is
   present in a response, the calculation is simply:
</t>
<figure><artwork type="code">
   freshness_lifetime = max_age_value
</artwork></figure>
<t>
   Otherwise, if Expires is present in the response, the calculation is:
</t>
<figure><artwork type="code">
   freshness_lifetime = expires_value - date_value
</artwork></figure>
<t>
   Note that neither of these calculations is vulnerable to clock skew,
   since all of the information comes from the origin server.
</t>
<t>
   If none of Expires, Cache-Control: max-age, or Cache-Control: s-maxage
   (see <xref target="modifications.of.the.basic.expiration.mechanism"/>) appears in the response, and the response
   does not include other restrictions on caching, the cache &MAY; compute
   a freshness lifetime using a heuristic. The cache &MUST; attach Warning
   113 to any response whose age is more than 24 hours if such warning
   has not already been added.
</t>
<t>
   Also, if the response does have a Last-Modified time, the heuristic
   expiration value &SHOULD; be no more than some fraction of the interval
   since that time. A typical setting of this fraction might be 10%.
</t>
<t>
   The calculation to determine if a response has expired is quite
   simple:
</t>
<figure><artwork type="code">
   response_is_fresh = (freshness_lifetime &gt; current_age)
</artwork></figure>
</section>

<section title="Disambiguating Expiration Values" anchor="disambiguating.expiration.values">
<t>
   Because expiration values are assigned optimistically, it is possible
   for two caches to contain fresh values for the same resource that are
   different.
</t>
<t>
   If a client performing a retrieval receives a non-first-hand response
   for a request that was already fresh in its own cache, and the Date
   header in its existing cache entry is newer than the Date on the new
   response, then the client &MAY; ignore the response. If so, it &MAY;
   retry the request with a "Cache-Control: max-age=0" directive (see
   <xref target="header.cache-control"/>), to force a check with the origin server.
</t>
<t>
   If a cache has two fresh responses for the same representation with
   different validators, it &MUST; use the one with the more recent Date
   header. This situation might arise because the cache is pooling
   responses from other caches, or because a client has asked for a
   reload or a revalidation of an apparently fresh cache entry.
</t>
</section>

<section title="Disambiguating Multiple Responses" anchor="disambiguating.multiple.responses">
<t>
   Because a client might be receiving responses via multiple paths, so
   that some responses flow through one set of caches and other
   responses flow through a different set of caches, a client might
   receive responses in an order different from that in which the origin
   server sent them. We would like the client to use the most recently
   generated response, even if older responses are still apparently
   fresh.
</t>
<t>
   Neither the entity tag nor the expiration value can impose an
   ordering on responses, since it is possible that a later response
   intentionally carries an earlier expiration time. The Date values are
   ordered to a granularity of one second.
</t>
<t>
   When a client tries to revalidate a cache entry, and the response it
   receives contains a Date header that appears to be older than the one
   for the existing entry, then the client &SHOULD; repeat the request
   unconditionally, and include
</t>
<figure><artwork type="example">
    Cache-Control: max-age=0
</artwork></figure>
<t>
   to force any intermediate caches to validate their copies directly
   with the origin server, or
</t>
<figure><artwork type="example">
    Cache-Control: no-cache
</artwork></figure>
<t>
   to force any intermediate caches to obtain a new copy from the origin
   server.
</t>
<t>
   If the Date values are equal, then the client &MAY; use either response
   (or &MAY;, if it is being extremely prudent, request a new response).
   Servers &MUST-NOT; depend on clients being able to choose
   deterministically between responses generated during the same second,
   if their expiration times overlap.
</t>
</section>
</section>

<section title="Validation Model" anchor="validation.model">
<t>
   When a cache has a stale entry that it would like to use as a
   response to a client's request, it first has to check with the origin
   server (or possibly an intermediate cache with a fresh response) to
   see if its cached entry is still usable. We call this "validating"
   the cache entry.
</t>
<t>
   HTTP's conditional request mechanism, defined in &conditional;, is
   used to avoid retransmitting the response payload when the cached entry
   is valid.  When a cached response includes one or more "cache validators,"
   such as the field values of an ETag or Last-Modified header field, then
   a validating GET request &SHOULD; be made conditional to those field values.
   The server checks the conditional request's validator against the current
   state of the requested resource and, if they match, the server responds
   with a 304 (Not Modified) status code to indicate that the cached response
   can be refreshed and reused without retransmitting the response payload.
   If the validator does not match the current state of the requested
   resource, then the server returns a full response, including payload,
   so that the request can be satisfied and the cache entry supplanted
   without the need for an additional network round-trip.
</t>
</section>

<section title="Response Cacheability" anchor="response.cacheability">
<t>
   Unless specifically constrained by a cache-control (<xref target="header.cache-control"/>)
   directive, a caching system &MAY; always store a successful response
   (see <xref target="errors.or.incomplete.response.cache.behavior"/>) as a cache entry, &MAY; return it without validation
   if it is fresh, and &MAY; return it after successful validation. If
   there is neither a cache validator nor an explicit expiration time
   associated with a response, we do not expect it to be cached, but
   certain caches &MAY; violate this expectation (for example, when little
   or no network connectivity is available). A client can usually detect
   that such a response was taken from a cache by comparing the Date
   header to the current time.
  <list><t>
      <x:h>Note:</x:h> some HTTP/1.0 caches are known to violate this expectation
      without providing any Warning.
  </t></list>
</t>
<t>
   However, in some cases it might be inappropriate for a cache to
   retain an entity, or to return it in response to a subsequent
   request. This might be because absolute semantic transparency is
   deemed necessary by the service author, or because of security or
   privacy considerations. Certain cache-control directives are
   therefore provided so that the server can indicate that certain
   resource entities, or portions thereof, are not to be cached
   regardless of other considerations.
</t>
<t>
   Note that &header-authorization; normally prevents a shared cache from saving
   and returning a response to a previous request if that request
   included an Authorization header.
</t>
<t>
   A response received with a status code of 200, 203, 206, 300, 301 or
   410 &MAY; be stored by a cache and used in reply to a subsequent
   request, subject to the expiration mechanism, unless a cache-control
   directive prohibits caching. However, a cache that does not support
   the Range and Content-Range headers &MUST-NOT; cache 206 (Partial
   Content) responses.
</t>
<t>
   A response received with any other status code (e.g. status codes 302
   and 307) &MUST-NOT; be returned in a reply to a subsequent request
   unless there are cache-control directives or another header(s) that
   explicitly allow it. For example, these include the following: an
   Expires header (<xref target="header.expires"/>); a "max-age", "s-maxage",  "must-revalidate",
   "proxy-revalidate", "public" or "private" cache-control
   directive (<xref target="header.cache-control"/>).
</t>
</section>

<section title="Constructing Responses From Caches" anchor="constructing.responses.from.caches">
<t>
   The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.
</t>

<section title="End-to-end and Hop-by-hop Headers" anchor="end-to-end.and.hop-by-hop.headers">
<t>
   For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:
  <list style="symbols">
      <t>End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses &MUST; be stored as part of a cache entry and &MUST; be
        transmitted in any response formed from a cache entry.</t>

      <t>Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.</t>
  </list>
</t>
<t>
   The following HTTP/1.1 headers are hop-by-hop headers:
  <list style="symbols">
      <t>Connection</t>
      <t>Keep-Alive</t>
      <t>Proxy-Authenticate</t>
      <t>Proxy-Authorization</t>
      <t>TE</t>
      <t>Trailer</t>
      <t>Transfer-Encoding</t>
      <t>Upgrade</t>
  </list>
</t>
<t>
   All other headers defined by HTTP/1.1 are end-to-end headers.
</t>
<t>
   Other hop-by-hop headers &MUST; be listed in a Connection header
   (&header-connection;).
</t>
</section>

<section title="Non-modifiable Headers" anchor="non-modifiable.headers">
<t>
   Some features of HTTP/1.1, such as Digest
   Authentication, depend on the value of certain end-to-end headers. A
   transparent proxy &SHOULD-NOT;  modify an end-to-end header unless the
   definition of that header requires or specifically allows that.
</t>
<t>
   A transparent proxy &MUST-NOT; modify any of the following fields in a
   request or response, and it &MUST-NOT; add any of these fields if not
   already present:
  <list style="symbols">
      <t>Content-Location</t>
      <t>Content-MD5</t>
      <t>ETag</t>
      <t>Last-Modified</t>
  </list>
</t>
<t>
   A transparent proxy &MUST-NOT; modify any of the following fields in a
   response:
  <list style="symbols">
    <t>Expires</t>
  </list>
</t>
<t>
   but it &MAY; add any of these fields if not already present. If an
   Expires header is added, it &MUST; be given a field-value identical to
   that of the Date header in that response.
</t>
<t>
   A  proxy &MUST-NOT; modify or add any of the following fields in a
   message that contains the no-transform cache-control directive, or in
   any request:
  <list style="symbols">
    <t>Content-Encoding</t>
    <t>Content-Range</t>
    <t>Content-Type</t>
  </list>
</t>
<t>
   A non-transparent proxy &MAY; modify or add these fields to a message
   that does not include no-transform, but if it does so, it &MUST; add a
   Warning 214 (Transformation applied) if one does not already appear
   in the message (see <xref target="header.warning"/>).
  <list><t>
      Warning: unnecessary modification of end-to-end headers might
      cause authentication failures if stronger authentication
      mechanisms are introduced in later versions of HTTP. Such
      authentication mechanisms &MAY; rely on the values of header fields
      not listed here.
    </t></list>
</t>
<t>
   The Content-Length field of a request or response is added or deleted
   according to the rules in &message-length;. A transparent proxy &MUST;
   preserve the entity-length (&entity-length;) of the entity-body,
   although it &MAY; change the transfer-length (&message-length;).
</t>
</section>

<section title="Combining Headers" anchor="combining.headers">
<t>
   When a cache makes a validating request to a server, and the server
   provides a 304 (Not Modified) response or a 206 (Partial Content)
   response, the cache then constructs a response to send to the
   requesting client.
</t>
<t>
   If the status code is 304 (Not Modified), the cache uses the entity-body
   stored in the cache entry as the entity-body of this outgoing
   response. If the status code is 206 (Partial Content) and the ETag or
   Last-Modified headers match exactly, the cache &MAY; combine the
   contents stored in the cache entry with the new contents received in
   the response and use the result as the entity-body of this outgoing
   response, (see &combining-byte-ranges;).
</t>
<t>
   The end-to-end headers stored in the cache entry are used for the
   constructed response, except that
  <list style="symbols">
    <t>any stored Warning headers with warn-code 1xx (see <xref target="header.warning"/>)
      &MUST; be deleted from the cache entry and the forwarded response.</t>
    <t>any stored Warning headers with warn-code 2xx &MUST; be retained
        in the cache entry and the forwarded response.</t>
    <t>any end-to-end headers provided in the 304 or 206 response &MUST;
        replace the corresponding headers from the cache entry.</t>
  </list>
</t>
<t>
   Unless the cache decides to remove the cache entry, it &MUST; also
   replace the end-to-end headers stored with the cache entry with
   corresponding headers received in the incoming response, except for
   Warning headers as described immediately above. If a header field-name
   in the incoming response matches more than one header in the
   cache entry, all such old headers &MUST; be replaced.
</t>
<t>
   In other words, the set of end-to-end headers received in the
   incoming response overrides all corresponding end-to-end headers
   stored with the cache entry (except for stored Warning headers with
   warn-code 1xx, which are deleted even if not overridden).
  <list><t>
      <x:h>Note:</x:h> this rule allows an origin server to use a 304 (Not
      Modified) or a 206 (Partial Content) response to update any header
      associated with a previous response for the same entity or sub-ranges
      thereof, although it might not always be meaningful or
      correct to do so. This rule does not allow an origin server to use
      a 304 (Not Modified) or a 206 (Partial Content) response to
      entirely delete a header that it had provided with a previous
      response.
  </t></list>
</t>
</section>

</section>

<section title="Caching Negotiated Responses" anchor="caching.negotiated.responses">
<t>
   Use of server-driven content negotiation (&server-driven-negotiation;), as indicated
   by the presence of a Vary header field in a response, alters the
   conditions and procedure by which a cache can use the response for
   subsequent requests. See <xref target="header.vary"/> for use of the Vary header
   field by servers.
</t>
<t>
   A server &SHOULD; use the Vary header field to inform a cache of what
   request-header fields were used to select among multiple
   representations of a cacheable response subject to server-driven
   negotiation. The set of header fields named by the Vary field value
   is known as the "selecting" request-headers.
</t>
<t>
   When the cache receives a subsequent request whose request-target
   specifies one or more cache entries including a Vary header field,
   the cache &MUST-NOT; use such a cache entry to construct a response to
   the new request unless all of the selecting request-headers present
   in the new request match the corresponding stored request-headers in
   the original request.
</t>
<t>
   The selecting request-headers from two requests are defined to match
   if and only if the selecting request-headers in the first request can
   be transformed to the selecting request-headers in the second request
   by adding or removing linear whitespace (LWS) at places where this
   is allowed by the corresponding BNF, and/or combining multiple
   message-header fields with the same field name following the rules
   about message headers in &message-headers;.
</t>
<t>
   A Vary header field-value of "*" always fails to match and subsequent
   requests on that resource can only be properly interpreted by the
   origin server.
</t>
<t>
   If the selecting request header fields for the cached entry do not
   match the selecting request header fields of the new request, then
   the cache &MUST-NOT; use a cached entry to satisfy the request unless
   it first relays the new request to the origin server in a conditional
   request and the server responds with 304 (Not Modified), including an
   entity tag or Content-Location that indicates the entity to be used.
</t>
<t>
   If an entity tag was assigned to a cached representation, the
   forwarded request &SHOULD; be conditional and include the entity tags
   in an If-None-Match header field from all its cache entries for the
   resource. This conveys to the server the set of entities currently
   held by the cache, so that if any one of these entities matches the
   requested entity, the server can use the ETag header field in its 304
   (Not Modified) response to tell the cache which entry is appropriate.
   If the entity-tag of the new response matches that of an existing
   entry, the new response &SHOULD; be used to update the header fields of
   the existing entry, and the result &MUST; be returned to the client.
</t>
<t>
   If any of the existing cache entries contains only partial content
   for the associated entity, its entity-tag &SHOULD-NOT;  be included in
   the If-None-Match header field unless the request is for a range that
   would be fully satisfied by that entry.
</t>
<t>
   If a cache receives a successful response whose Content-Location
   field matches that of an existing cache entry for the same request-target,
   whose entity-tag differs from that of the existing entry, and
   whose Date is more recent than that of the existing entry, the
   existing entry &SHOULD-NOT;  be returned in response to future requests
   and &SHOULD; be deleted from the cache.
</t>
</section>

<section title="Shared and Non-Shared Caches" anchor="shared.and.non-shared.caches">
<t>
   For reasons of security and privacy, it is necessary to make a
   distinction between "shared" and "non-shared" caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case &SHOULD; be enforced by appropriate security mechanisms.
   All other caches are considered to be "shared." Other sections of
   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.
</t>
</section>

<section title="Errors or Incomplete Response Cache Behavior" anchor="errors.or.incomplete.response.cache.behavior">
<t>
   A cache that receives an incomplete response (for example, with fewer
   bytes of data than specified in a Content-Length header) &MAY; store
   the response. However, the cache &MUST; treat this as a partial
   response. Partial responses &MAY; be combined as described in &combining-byte-ranges;;
   the result might be a full response or might still be
   partial. A cache &MUST-NOT; return a partial response to a client
   without explicitly marking it as such, using the 206 (Partial
   Content) status code. A cache &MUST-NOT; return a partial response
   using a status code of 200 (OK).
</t>
<t>
   If a cache receives a 5xx response while attempting to revalidate an
   entry, it &MAY; either forward this response to the requesting client,
   or act as if the server failed to respond. In the latter case, it &MAY;
   return a previously received response unless the cached entry
   includes the "must-revalidate" cache-control directive (see <xref target="header.cache-control"/>).
</t>
</section>

<section title="Side Effects of GET and HEAD" anchor="side.effects.of.get.and.head">
<t>
   Unless the origin server explicitly prohibits the caching of their
   responses, the application of GET and HEAD methods to any resources
   &SHOULD-NOT;  have side effects that would lead to erroneous behavior if
   these responses are taken from a cache. They &MAY; still have side
   effects, but a cache is not required to consider such side effects in
   its caching decisions. Caches are always expected to observe an
   origin server's explicit restrictions on caching.
</t>
<t>
   We note one exception to this rule: since some applications have
   traditionally used GET and HEAD requests with URLs containing a query part
   to perform operations with significant side
   effects, caches &MUST-NOT; treat responses to such URIs as fresh unless
   the server provides an explicit expiration time. This specifically
   means that responses from HTTP/1.0 servers for such URIs &SHOULD-NOT; 
   be taken from a cache. See &safe-methods; for related information.
</t>
</section>

<section title="Invalidation After Updates or Deletions" anchor="invalidation.after.updates.or.deletions">
<t>
   The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-transparently
   invalid. That is, although they might continue to be
   "fresh," they do not accurately reflect what the origin server would
   return for a new request on that resource.
</t>
<t>
   There is no way for HTTP to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.
</t>
<t>
   In this section, the phrase "invalidate an entity" means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as "invalid" and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.
</t>
<t>
   Some HTTP methods &MUST; cause a cache to invalidate an entity. This is
   either the entity referred to by the request-target, or by the Location
   or Content-Location headers (if present). These methods are:
  <list style="symbols">
      <t>PUT</t>
      <t>DELETE</t>
      <t>POST</t>
  </list>
</t>  
<t>
   An invalidation based
   on the URI in a Location or Content-Location header &MUST-NOT; be
   performed if the host part of that URI differs from the host part
   in the request-target. This helps prevent denial of service attacks.
</t>
<t>
   A cache that passes through requests for methods it does not
   understand &SHOULD; invalidate any entities referred to by the
   request-target.
</t>
</section>

<section title="Write-Through Mandatory" anchor="write-through.mandatory">
<t>
   All methods that might be expected to cause modifications to the
   origin server's resources &MUST; be written through to the origin
   server. This currently includes all methods except for GET and HEAD.
   A cache &MUST-NOT; reply to such a request from a client before having
   transmitted the request to the inbound server, and having received a
   corresponding response from the inbound server. This does not prevent
   a proxy cache from sending a 100 (Continue) response before the
   inbound server has sent its final reply.
</t>
<t>
   The alternative (known as "write-back" or "copy-back" caching) is not
   allowed in HTTP/1.1, due to the difficulty of providing consistent
   updates and the problems arising from server, cache, or network
   failure prior to write-back.
</t>
</section>

<section title="Cache Replacement" anchor="cache.replacement">
<t>
   If a new cacheable (see Sections <xref target="what.may.be.stored.by.caches" format="counter"/>,
   <xref target="disambiguating.expiration.values" format="counter"/>,
   <xref target="disambiguating.multiple.responses" format="counter"/>
   and <xref target="errors.or.incomplete.response.cache.behavior" format="counter"/>)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache &SHOULD; use the new response
   to reply to the current request. It &MAY; insert it into cache storage
   and &MAY;, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in <xref target="combining.headers"/> apply.
  <list><t>
      <x:h>Note:</x:h> a new response that has an older Date header value than
      existing cached responses is not cacheable.
  </t></list>
</t>
</section>

<section title="History Lists" anchor="history.lists">
<t>
   User agents often have history mechanisms, such as "Back" buttons and
   history lists, which can be used to redisplay an entity retrieved
   earlier in a session.
</t>
<t>
   History mechanisms and caches are different. In particular history
   mechanisms &SHOULD-NOT;  try to show a semantically transparent view of
   the current state of a resource. Rather, a history mechanism is meant
   to show exactly what the user saw at the time when the resource was
   retrieved.
</t>
<t>
   By default, an expiration time does not apply to history mechanisms.
   If the entity is still in storage, a history mechanism &SHOULD; display
   it even if the entity has expired, unless the user has specifically
   configured the agent to refresh expired history documents.
</t>
<t>
   This is not to be construed to prohibit the history mechanism from
   telling the user that a view might be stale.
  <list><t>
      <x:h>Note:</x:h> if history list mechanisms unnecessarily prevent users from
      viewing stale resources, this will tend to force service authors
      to avoid using HTTP expiration controls and cache controls when
      they would otherwise like to. Service authors may consider it
      important that users not be presented with error messages or
      warning messages when they use navigation controls (such as BACK)
      to view previously fetched resources. Even though sometimes such
      resources ought not be cached, or ought to expire quickly, user
      interface considerations may force service authors to resort to
      other means of preventing caching (e.g. "once-only" URLs) in order
      not to suffer the effects of improperly functioning history
      mechanisms.
  </t></list>
</t>
</section>

<section title="Header Field Definitions" anchor="header.fields">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to caching.
</t>
<t>
   For entity-header fields, both sender and recipient refer to either the
   client or the server, depending on who sends and who receives the entity.
</t>

<section title="Age" anchor="header.age">
  <iref primary="true" item="Age header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Age" x:for-anchor=""/>
  <x:anchor-alias value="Age"/>
  <x:anchor-alias value="Age-v"/>
  <x:anchor-alias value="age-value"/>
<t>
      The response-header field "Age" conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is "fresh" if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in <xref target="age.calculations"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Age"/><iref primary="true" item="Grammar" subitem="Age-v"/>
  <x:ref>Age</x:ref>   = "Age" ":" <x:ref>OWS</x:ref> <x:ref>Age-v</x:ref>
  <x:ref>Age-v</x:ref> = <x:ref>delta-seconds</x:ref>
</artwork></figure>
<t anchor="rule.delta-seconds">
  <x:anchor-alias value="delta-seconds"/>
      Age values are non-negative decimal integers, representing time in
      seconds.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="delta-seconds"/>
  <x:ref>delta-seconds</x:ref>  = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it &MUST; transmit an Age header with a value of
      2147483648 (2<x:sup>31</x:sup>). An HTTP/1.1 server that includes a cache &MUST;
      include an Age header field in every response generated from its
      own cache. Caches &SHOULD; use an arithmetic type of at least 31
      bits of range.
</t>
</section>

<section title="Cache-Control" anchor="header.cache-control">
  <iref primary="true" item="Cache-Control header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Cache-Control" x:for-anchor=""/>
  <x:anchor-alias value="Cache-Control"/>
  <x:anchor-alias value="Cache-Control-v"/>
  <x:anchor-alias value="cache-directive"/>
  <x:anchor-alias value="cache-extension"/>
  <x:anchor-alias value="cache-request-directive"/>
  <x:anchor-alias value="cache-response-directive"/>
<t>
   The general-header field "Cache-Control" is used to specify directives
   that &MUST; be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.
  <list><t>
      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see <xref target="header.pragma"/>).
  </t></list>
</t>
<t>
   Cache directives &MUST; be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-directive
   for a specific cache.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Cache-Control"/><iref primary="true" item="Grammar" subitem="Cache-Control-v"/><iref primary="true" item="Grammar" subitem="cache-directive"/><iref primary="true" item="Grammar" subitem="cache-request-directive"/><iref primary="true" item="Grammar" subitem="cache-response-directive"/><iref primary="true" item="Grammar" subitem="cache-extension"/>
  <x:ref>Cache-Control</x:ref>   = "Cache-Control" ":" <x:ref>OWS</x:ref> <x:ref>Cache-Control-v</x:ref>
  <x:ref>Cache-Control-v</x:ref> = 1#<x:ref>cache-directive</x:ref>

  <x:ref>cache-directive</x:ref> = <x:ref>cache-request-directive</x:ref>
     / <x:ref>cache-response-directive</x:ref>

  <x:ref>cache-request-directive</x:ref> =
       "no-cache"                          ; <xref target="what.is.cacheable"/>
     / "no-store"                          ; <xref target="what.may.be.stored.by.caches"/>
     / "max-age" "=" <x:ref>delta-seconds</x:ref>         ; <xref target="modifications.of.the.basic.expiration.mechanism"/>, <xref format="counter" target="cache.revalidation.and.reload.controls"/>
     / "max-stale" [ "=" <x:ref>delta-seconds</x:ref> ]   ; <xref target="modifications.of.the.basic.expiration.mechanism"/>
     / "min-fresh" "=" <x:ref>delta-seconds</x:ref>       ; <xref target="modifications.of.the.basic.expiration.mechanism"/>
     / "no-transform"                      ; <xref target="no-transform.directive"/>
     / "only-if-cached"                    ; <xref target="cache.revalidation.and.reload.controls"/>
     / <x:ref>cache-extension</x:ref>                     ; <xref target="cache.control.extensions"/>

  <x:ref>cache-response-directive</x:ref> =
       "public"                               ; <xref target="what.is.cacheable"/>
     / "private" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ] ; <xref target="what.is.cacheable"/>
     / "no-cache" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ] ; <xref target="what.is.cacheable"/>
     / "no-store"                             ; <xref target="what.may.be.stored.by.caches"/>
     / "no-transform"                         ; <xref target="no-transform.directive"/>
     / "must-revalidate"                      ; <xref target="cache.revalidation.and.reload.controls"/>
     / "proxy-revalidate"                     ; <xref target="cache.revalidation.and.reload.controls"/>
     / "max-age" "=" <x:ref>delta-seconds</x:ref>            ; <xref target="modifications.of.the.basic.expiration.mechanism"/>
     / "s-maxage" "=" <x:ref>delta-seconds</x:ref>           ; <xref target="modifications.of.the.basic.expiration.mechanism"/>
     / <x:ref>cache-extension</x:ref>                        ; <xref target="cache.control.extensions"/>

  <x:ref>cache-extension</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of HTTP might apply these directives to
   header fields not defined in HTTP/1.1.
</t>
<t>
   The cache-control directives can be broken down into these general
   categories:
  <list style="symbols">
     <t>Restrictions on what are cacheable; these may only be imposed by
        the origin server.</t>

     <t>Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.</t>

     <t>Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.</t>

     <t>Controls over cache revalidation and reload; these may only be
        imposed by a user agent.</t>

     <t>Control over transformation of entities.</t>

     <t>Extensions to the caching system.</t>
  </list>
</t>

<section title="What is Cacheable" anchor="what.is.cacheable">
<t>
   By default, a response is cacheable if the requirements of the
   request method, request header fields, and the response status
   indicate that it is cacheable. <xref target="response.cacheability"/> summarizes these defaults
   for cacheability. The following Cache-Control response directives
   allow an origin server to override the default cacheability of a
   response:
</t>
<t>
  <iref item="Cache Directives" subitem="public" primary="true"/>
  <iref item="public" subitem="Cache Directive" primary="true"/>
   public
  <list><t>
      Indicates that the response &MAY; be cached by any cache, even if it
      would normally be non-cacheable or cacheable only within a non-shared
      cache. (See also Authorization, &header-authorization;, for
      additional details.)
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="private" primary="true"/>
  <iref item="private" subitem="Cache Directive" primary="true"/>
   private
  <list><t>
      Indicates that all or part of the response message is intended for
      a single user and &MUST-NOT; be cached by a shared cache. This
      allows an origin server to state that the specified parts of the
      response are intended for only one user and are not a valid
      response for requests by other users. A private (non-shared) cache
      &MAY; cache the response.
    </t><t>
       <x:h>Note:</x:h> This usage of the word private only controls where the
       response may be cached, and cannot ensure the privacy of the
       message content.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="no-cache" primary="true"/>
  <iref item="no-cache" subitem="Cache Directive" primary="true"/>
   no-cache
  <list><t>
       If the no-cache directive does not specify a field-name, then a
      cache &MUST-NOT; use the response to satisfy a subsequent request
      without successful revalidation with the origin server. This
      allows an origin server to prevent caching even by caches that
      have been configured to return stale responses to client requests.
    </t><t>
      If the no-cache directive does specify one or more field-names,
      then a cache &MAY; use the response to satisfy a subsequent request,
      subject to any other restrictions on caching. However, the
      specified field-name(s) &MUST-NOT; be sent in the response to a
      subsequent request without successful revalidation with the origin
      server. This allows an origin server to prevent the re-use of
      certain header fields in a response, while still allowing caching
      of the rest of the response.
    <list><t>
       <x:h>Note:</x:h> Most HTTP/1.0 caches will not recognize or obey this
       directive.
    </t></list>
  </t></list>
</t>
</section>

<section title="What May be Stored by Caches" anchor="what.may.be.stored.by.caches">
<t>
  <iref item="Cache Directives" subitem="no-store" primary="true"/>
  <iref item="no-store" subitem="Cache Directive" primary="true"/>
   no-store
  <list><t>   
      The purpose of the no-store directive is to prevent the
      inadvertent release or retention of sensitive information (for
      example, on backup tapes). The no-store directive applies to the
      entire message, and &MAY; be sent either in a response or in a
      request. If sent in a request, a cache &MUST-NOT; store any part of
      either this request or any response to it. If sent in a response,
      a cache &MUST-NOT; store any part of either this response or the
      request that elicited it. This directive applies to both non-shared
      and shared caches. "&MUST-NOT; store" in this context means
      that the cache &MUST-NOT; intentionally store the information in
      non-volatile storage, and &MUST; make a best-effort attempt to
      remove the information from volatile storage as promptly as
      possible after forwarding it.
  </t><t>
      Even when this directive is associated with a response, users
      might explicitly store such a response outside of the caching
      system (e.g., with a "Save As" dialog). History buffers &MAY; store
      such responses as part of their normal operation.
  </t><t>
      The purpose of this directive is to meet the stated requirements
      of certain users and service authors who are concerned about
      accidental releases of information via unanticipated accesses to
      cache data structures. While the use of this directive might
      improve privacy in some cases, we caution that it is NOT in any
      way a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or
      obey this directive, and communications networks might be
      vulnerable to eavesdropping.
  </t></list>
</t>
</section>

<section title="Modifications of the Basic Expiration Mechanism" anchor="modifications.of.the.basic.expiration.mechanism">
<t>
   The expiration time of an entity &MAY; be specified by the origin
   server using the Expires header (see <xref target="header.expires"/>). Alternatively,
   it &MAY; be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., "public") unless some other, more
   restrictive cache directive is also present.
</t>
<t>
   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.
</t>
<t>
   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive "no-cache". If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it &SHOULD; consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.
  <list><t>
       <x:h>Note:</x:h> An origin server might wish to use a relatively new HTTP
       cache control feature, such as the "private" directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="s-maxage" primary="true"/>
  <iref item="s-maxage" subitem="Cache Directive" primary="true"/>
   s-maxage
  <list><t>
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       <xref target="cache.revalidation.and.reload.controls"/>), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-maxage
       directive is always ignored by a private cache.
  </t></list>
</t>
<t>
   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache &MAY; exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.
</t>
<t>
   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives &MAY; be specified on a request:
</t>
<t>
  <iref item="Cache Directives" subitem="max-age" primary="true"/>
  <iref item="max-age" subitem="Cache Directive" primary="true"/>
   max-age
  <list><t>
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-stale
      directive is also included, the client is not willing to
      accept a stale response.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="min-fresh" primary="true"/>
  <iref item="min-fresh" subitem="Cache Directive" primary="true"/>
   min-fresh
  <list><t>
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="max-stale" primary="true"/>
  <iref item="max-stale" subitem="Cache Directive" primary="true"/>
   max-stale
  <list><t>
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.
  </t></list>
</t>
<t>
   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache &MUST; attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale).
</t>
<t>
   A cache &MAY; be configured to return stale responses without
   validation, but only if this does not conflict with any "MUST"-level
   requirements concerning cache validation (e.g., a "must-revalidate"
   cache-control directive).
</t>
<t>
   If both the new request and the cached entry include "max-age"
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.
</t>
</section>

<section title="Cache Revalidation and Reload Controls" anchor="cache.revalidation.and.reload.controls">
<t>
   Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.
</t>
<t>
   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   "unspecified end-to-end revalidation", or when the client does have a
   local cached copy, in which case we call it "specific end-to-end
   revalidation."
</t>
<t>
   The client can specify these three kinds of action using Cache-Control
   request directives:
</t>
<t>
   End-to-end reload
  <list><t>
      The request includes a "no-cache" cache-control directive or, for
      compatibility with HTTP/1.0 clients, "Pragma: no-cache". Field
      names &MUST-NOT; be included with the no-cache directive in a
      request. The server &MUST-NOT; use a cached copy when responding to
      such a request.
  </t></list>
</t>
<t>
   Specific end-to-end revalidation
  <list><t>
      The request includes a "max-age=0" cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.
  </t></list>
</t>
<t>
   Unspecified end-to-end revalidation
  <list><t>
      The request includes "max-age=0" cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating
      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="max-age" primary="true"/>
  <iref item="max-age" subitem="Cache Directive" primary="true"/>
   max-age
  <list><t>
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache &MAY; use either validator in making
      its own request without affecting semantic transparency.
  </t><t>
      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.
  </t><t>
      If a request includes the no-cache directive, it &SHOULD-NOT; 
      include min-fresh, max-stale, or max-age.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="only-if-cached" primary="true"/>
  <iref item="only-if-cached" subitem="Cache Directive" primary="true"/>
   only-if-cached
  <list><t>
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache &SHOULD; either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request &MAY; be forwarded within that group of
      caches.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="must-revalidate" primary="true"/>
  <iref item="must-revalidate" subitem="Cache Directive" primary="true"/>
   must-revalidate
  <list><t>
      Because a cache &MAY; be configured to ignore a server's specified
      expiration time, and because a client request &MAY; include a max-stale
      directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      &MUST-NOT; use the entry after it becomes stale to respond to a
      subsequent request without first revalidating it with the origin
      server. (I.e., the cache &MUST; do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)
  </t><t>
      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache &MUST; obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it &MUST; generate a 504 (Gateway Timeout) response.
  </t><t>
      Servers &SHOULD; send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients &MUST-NOT; take any automated action that
      violates this directive, and &MUST-NOT; automatically provide an
      unvalidated copy of the entity if revalidation fails.
  </t><t>
      Although this is not recommended, user agents operating under
      severe connectivity constraints &MAY; violate this directive but, if
      so, &MUST; explicitly warn the user that an unvalidated response has
      been provided. The warning &MUST; be provided on each unvalidated
      access, and &SHOULD; require explicit user confirmation.
  </t></list>
</t>
<t>
  <iref item="Cache Directives" subitem="proxy-revalidate" primary="true"/>
  <iref item="proxy-revalidate" subitem="Cache Directive" primary="true"/>
   proxy-revalidate
  <list><t>
      The proxy-revalidate directive has the same meaning as the must-revalidate
      directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.
  </t></list>
</t>
</section>

<section title="No-Transform Directive" anchor="no-transform.directive">
<t>
  <iref item="Cache Directives" subitem="no-transform" primary="true"/>
  <iref item="no-transform" subitem="Cache Directive" primary="true"/>
   no-transform
  <list><t>
      Implementors of intermediate caches (proxies) have found it useful
      to convert the media type of certain entity bodies. A non-transparent
      proxy might, for example, convert between image
      formats in order to save cache space or to reduce the amount of
      traffic on a slow link.
  </t><t>
      Serious operational problems occur, however, when these
      transformations are applied to entity bodies intended for certain
      kinds of applications. For example, applications for medical
      imaging, scientific data analysis and those using end-to-end
      authentication, all depend on receiving an entity body that is bit
      for bit identical to the original entity-body.
  </t><t>
      Therefore, if a message includes the no-transform directive, an
      intermediate cache or proxy &MUST-NOT; change those headers that are
      listed in <xref target="non-modifiable.headers"/> as being subject to the no-transform
      directive. This implies that the cache or proxy &MUST-NOT; change
      any aspect of the entity-body that is specified by these headers,
      including the value of the entity-body itself.
  </t></list>
</t>
</section>

<section title="Cache Control Extensions" anchor="cache.control.extensions">
<t>
   The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) &MAY; be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.
</t>
<t>
   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.
</t>
<t>
   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including
</t>
<figure><artwork type="example">
    Cache-Control: private, community="UCI"
</artwork></figure>
<t>
   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior.
</t>
<t>
   Unrecognized cache-directives &MUST; be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).
</t>
</section>
</section>

<section title="Expires" anchor="header.expires">
  <iref primary="true" item="Expires header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Expires" x:for-anchor=""/>
  <x:anchor-alias value="Expires"/>
  <x:anchor-alias value="Expires-v"/>
<t>
   The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See <xref target="expiration.model"/>
   for further discussion of the expiration model.
</t>
<t>
   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.
</t>
<t>
   The format is an absolute date and time as defined by HTTP-date in
   &full-date;; it &MUST; be sent in rfc1123-date format.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Expires"/><iref primary="true" item="Grammar" subitem="Expires-v"/>
  <x:ref>Expires</x:ref>   = "Expires" ":" <x:ref>OWS</x:ref> <x:ref>Expires-v</x:ref>
  <x:ref>Expires-v</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of its use is
</t>
<figure><artwork type="example">
  Expires: Thu, 01 Dec 1994 16:00:00 GMT
</artwork></figure>
<t>
  <list><t>
      <x:h>Note:</x:h> if a response includes a Cache-Control field with the max-age
      directive (see <xref target="modifications.of.the.basic.expiration.mechanism"/>), that directive overrides the
      Expires field.
  </t></list>
</t>
<t>
   HTTP/1.1 clients and caches &MUST; treat other invalid date formats,
   especially including the value "0", as in the past (i.e., "already
   expired").
</t>
<t>
   To mark a response as "already expired," an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in <xref target="expiration.calculations"/>.)
</t>
<t>
   To mark a response as "never expires," an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers &SHOULD-NOT;  send Expires dates more than one
   year in the future.
</t>
<t>
   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (<xref target="header.cache-control"/>).
</t>
</section>

<section title="Pragma" anchor="header.pragma">
  <iref primary="true" item="Pragma header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Pragma" x:for-anchor=""/>
  <x:anchor-alias value="extension-pragma"/>
  <x:anchor-alias value="Pragma"/>
  <x:anchor-alias value="Pragma-v"/>
  <x:anchor-alias value="pragma-directive"/>
<t>
   The general-header field "Pragma" is used to include implementation-specific
   directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   &MAY; require that behavior be consistent with the directives.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Pragma"/><iref primary="true" item="Grammar" subitem="Pragma-v"/><iref primary="true" item="Grammar" subitem="pragma-directive"/><iref primary="true" item="Grammar" subitem="extension-pragma"/>
  <x:ref>Pragma</x:ref>            = "Pragma" ":" <x:ref>OWS</x:ref> <x:ref>Pragma-v</x:ref>
  <x:ref>Pragma-v</x:ref>          = 1#<x:ref>pragma-directive</x:ref>
  <x:ref>pragma-directive</x:ref>  = "no-cache" / <x:ref>extension-pragma</x:ref>
  <x:ref>extension-pragma</x:ref>  = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   When the no-cache directive is present in a request message, an
   application &SHOULD; forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   <xref target="header.cache-control"/>) and is defined here for backward compatibility with
   HTTP/1.0. Clients &SHOULD; include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant.
</t>
<t>
   Pragma directives &MUST; be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient &SHOULD; be ignored by that recipient.
</t>
<t>
   HTTP/1.1 caches &SHOULD; treat "Pragma: no-cache" as if the client had
   sent "Cache-Control: no-cache". No new Pragma directives will be
   defined in HTTP.
  <list><t>
      <x:h>Note:</x:h> because the meaning of "Pragma: no-cache" as a
      response-header field is not actually specified, it does not provide a
      reliable replacement for "Cache-Control: no-cache" in a response.
  </t></list>
</t>
</section>

<section title="Vary" anchor="header.vary">
  <iref primary="true" item="Vary header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Vary" x:for-anchor=""/>
  <x:anchor-alias value="Vary"/>
  <x:anchor-alias value="Vary-v"/>
<t>
   The "Vary" response-header field's value indicates the set of request-header
   fields that fully determines, while the response is fresh, whether a cache
   is permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of "*" implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   <xref target="caching.negotiated.responses"/> for use of the Vary header field by caches.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Vary"/><iref primary="true" item="Grammar" subitem="Vary-v"/>
  <x:ref>Vary</x:ref>   = "Vary" ":" <x:ref>OWS</x:ref> <x:ref>Vary-v</x:ref>
  <x:ref>Vary-v</x:ref> = "*" / 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
   An HTTP/1.1 server &SHOULD; include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation
   on that resource. A server &MAY; include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.
</t>
<t>
   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache &MAY; assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.
</t>
<t>
   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.
</t>
<t>
   A Vary field value of "*" signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The "*" value &MUST-NOT; be generated by a proxy server; it may only be
   generated by an origin server.
</t>
</section>

<section title="Warning" anchor="header.warning">
  <iref primary="true" item="Warning header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Warning" x:for-anchor=""/>
  <x:anchor-alias value="Warning"/>
  <x:anchor-alias value="Warning-v"/>
  <x:anchor-alias value="warning-value"/>
  <x:anchor-alias value="warn-agent"/>
  <x:anchor-alias value="warn-code"/>
  <x:anchor-alias value="warn-date"/>
  <x:anchor-alias value="warn-text"/>
<t>
   The general-header field "Warning" is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.
</t>
<t>
   Warning headers are sent with responses using:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Warning"/><iref primary="true" item="Grammar" subitem="Warning-v"/><iref primary="true" item="Grammar" subitem="warning-value"/><iref primary="true" item="Grammar" subitem="warn-code"/><iref primary="true" item="Grammar" subitem="warn-agent"/><iref primary="true" item="Grammar" subitem="warn-text"/><iref primary="true" item="Grammar" subitem="warn-date"/>
  <x:ref>Warning</x:ref>    = "Warning" ":" <x:ref>OWS</x:ref> <x:ref>Warning-v</x:ref>
  <x:ref>Warning-v</x:ref>  = 1#<x:ref>warning-value</x:ref>
  
  <x:ref>warning-value</x:ref> = <x:ref>warn-code</x:ref> <x:ref>SP</x:ref> <x:ref>warn-agent</x:ref> <x:ref>SP</x:ref> <x:ref>warn-text</x:ref>
                                        [<x:ref>SP</x:ref> <x:ref>warn-date</x:ref>]
  
  <x:ref>warn-code</x:ref>  = 3<x:ref>DIGIT</x:ref>
  <x:ref>warn-agent</x:ref> = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
                  ; the name or pseudonym of the server adding
                  ; the Warning header, for use in debugging
  <x:ref>warn-text</x:ref>  = <x:ref>quoted-string</x:ref>
  <x:ref>warn-date</x:ref>  = <x:ref>DQUOTE</x:ref> <x:ref>HTTP-date</x:ref> <x:ref>DQUOTE</x:ref>
</artwork></figure>
<t>
   A response &MAY; carry more than one Warning header.
</t>
<t>
   The warn-text &SHOULD; be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision &MAY; be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1 (<xref target="ISO-8859-1"/>).
</t>
<t>
   If a character set other than ISO-8859-1 is used, it &MUST; be encoded
   in the warn-text using the method described in <xref target="RFC2047"/>.
</t>
<t>
   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers &SHOULD; be added
   after any existing Warning headers. A cache &MUST-NOT; delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it &SHOULD; remove any Warning
   headers previously attached to that entry except as specified for
   specific Warning codes. It &MUST; then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.
</t>
<t>
   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent &SHOULD; follow
   these heuristics:
  <list style="symbols">
    <t>Warnings that appear early in the response take priority over
        those appearing later in the response.</t>

    <t>Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-codes
        and warn-agents.</t>
  </list>
</t>
<t>
   Systems that generate multiple Warning headers &SHOULD; order them with
   this user agent behavior in mind.
</t>
<t>
   Requirements for the behavior of caches with respect to Warnings are
   stated in <xref target="warnings"/>.
</t>
<t>
   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.
</t>
<t>
   110 Response is stale
  <list><t>
     &MUST; be included whenever the returned response is stale.
  </t></list>
</t>
<t>
   111 Revalidation failed
  <list><t>
     &MUST; be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.
  </t></list>
</t>
<t>
   112 Disconnected operation
  <list><t>
     &SHOULD; be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.
  </t></list>
</t>
<t>
   113 Heuristic expiration
  <list><t>
     &MUST; be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.
  </t></list>
</t>
<t>
   199 Miscellaneous warning
  <list><t>
     The warning text &MAY; include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning &MUST-NOT;
     take any automated action, besides presenting the warning to
     the user.
  </t></list>
</t>
<t>
   214 Transformation applied
  <list><t>
     &MUST; be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.
  </t></list>
</t>
<t>
   299 Miscellaneous persistent warning
  <list><t>
     The warning text &MAY; include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning &MUST-NOT;
     take any automated action.
  </t></list>
</t>
<t>
   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender &MUST; include in
   each warning-value a warn-date that matches the date in the response.
</t>
<t>
   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value &MUST; be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   &MUST; be deleted as well.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="IANA.considerations">
<section title="Message Header Registration" anchor="message.header.registration">
<t>
   The Message Header Registry located at <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/> should be updated
   with the permanent registrations below (see <xref target="RFC3864"/>):
</t>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Age</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.age"/>
   </c>
   <c>Cache-Control</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.cache-control"/>
   </c>
   <c>Expires</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expires"/>
   </c>
   <c>Pragma</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.pragma"/>
   </c>
   <c>Vary</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.vary"/>
   </c>
   <c>Warning</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.warning"/>
   </c>
</texttable>
<!--(END)-->
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   Caching proxies provide additional potential vulnerabilities, since
   the contents of the cache represent an attractive target for
   malicious exploitation. Because cache contents persist after an HTTP
   request is complete, an attack on the cache can reveal information
   long after a user believes that the information has been removed from
   the network. Therefore, cache contents should be protected as
   sensitive information.
</t>
</section>

<section title="Acknowledgments" anchor="ack">
<t>
   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="ISO-8859-1">
  <front>
    <title>
     Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1
    </title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
</reference>

<reference anchor="Part1">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
  <x:source href="p1-messaging.xml" basename="p1-messaging"/>
</reference>

<reference anchor="Part2">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="p2-semantics.xml" basename="p2-semantics"/>
</reference>

<reference anchor="Part3">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 3: Message Payload and Content Negotiation</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p3-payload-&ID-VERSION;"/>
  <x:source href="p3-payload.xml" basename="p3-payload"/>
</reference>

<reference anchor="Part4">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 4: Conditional Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"/>
  <x:source href="p4-conditional.xml" basename="p4-conditional"/>
</reference>

<reference anchor="Part5">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
  <x:source href="p5-range.xml" basename="p5-range"/>
</reference>

<reference anchor="Part7">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 7: Authentication</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>One Laptop per Child</organization>
      <address><email>jg@laptop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-&ID-VERSION;"/>
  <x:source href="p7-auth.xml" basename="p7-auth"/>
</reference>

<reference anchor="RFC2047">
  <front>
    <title abbrev="Message Header Extensions">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</title>
    <author initials="K." surname="Moore" fullname="Keith Moore">
      <organization>University of Tennessee</organization>
      <address><email>moore@cs.utk.edu</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2047"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
      <postal>
      <street>675 Spruce Dr.</street>
      <city>Sunnyvale</city>
      <region>CA</region>
      <code>94086</code>
      <country>US</country></postal>
      <phone>+1.408.246.8253</phone>
      <email>dcrocker@bbiw.net</email></address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
      <postal>
      <street>1/2 Berkeley Square</street>
      <street>99 Berkely Street</street>
      <city>Glasgow</city>
      <code>G3 7HR</code>
      <country>UK</country></postal>
      <email>paul.overell@thus.net</email></address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC1305">
  <front>
    <title>Network Time Protocol (Version 3) Specification, Implementation</title>
    <author initials="D." surname="Mills" fullname="David L. Mills">
      <organization>University of Delaware, Electrical Engineering Department</organization>
      <address><email>mills@udel.edu</email></address>
    </author>
    <date month="March" year="1992"/>
  </front>
  <seriesInfo name="RFC" value="1305"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

</references>

<section title="Compatibility with Previous Versions" anchor="compatibility">

<section title="Changes from RFC 2068" anchor="changes.from.rfc.2068">
<t>
   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections <xref target="response.cacheability" format="counter"/>,
   <xref target="header.cache-control" format="counter"/>,
   <xref target="modifications.of.the.basic.expiration.mechanism" format="counter"/>)
</t>
<t>
   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed.
   (<xref target="non-modifiable.headers"/>,
   see also <xref target="Part1"/>, <xref target="Part3"/> and <xref target="Part5"/>)
</t>
<t>
   Proxies should be able to add Content-Length when appropriate.
   (<xref target="non-modifiable.headers"/>)
</t>
<t>
   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided.
   (<xref target="combining.headers"/>)
</t>
<t>
   The Cache-Control: max-age directive was not properly defined for
   responses. (<xref target="modifications.of.the.basic.expiration.mechanism"/>)
</t>
<t>
   Warnings could be cached incorrectly, or not updated appropriately.
   (Section <xref target="warnings" format="counter"/>, <xref target="expiration.calculations" format="counter"/>, <xref target="non-modifiable.headers" format="counter"/>,
   <xref target="combining.headers" format="counter"/>, <xref target="modifications.of.the.basic.expiration.mechanism" format="counter"/>,
   and <xref target="header.warning" format="counter"/>) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests.
</t>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Clarify denial of service attack avoidance requirement.
  (<xref target="invalidation.after.updates.or.deletions"/>)
</t>
</section>

</section>

<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p6-cache.parsed-abnf">
<x:ref>Age</x:ref> = "Age:" OWS Age-v
<x:ref>Age-v</x:ref> = delta-seconds

<x:ref>Cache-Control</x:ref> = "Cache-Control:" OWS Cache-Control-v
<x:ref>Cache-Control-v</x:ref> = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

<x:ref>Expires</x:ref> = "Expires:" OWS Expires-v
<x:ref>Expires-v</x:ref> = HTTP-date

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part1], Section 3.2.1&gt;

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>Pragma</x:ref> = "Pragma:" OWS Pragma-v
<x:ref>Pragma-v</x:ref> = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

<x:ref>Vary</x:ref> = "Vary:" OWS Vary-v
<x:ref>Vary-v</x:ref> = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name
 ] ) )

<x:ref>Warning</x:ref> = "Warning:" OWS Warning-v
<x:ref>Warning-v</x:ref> = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value
 ] )

<x:ref>cache-directive</x:ref> = cache-request-directive / cache-response-directive
<x:ref>cache-extension</x:ref> = token [ "=" ( token / quoted-string ) ]
<x:ref>cache-request-directive</x:ref> = "no-cache" / "no-store" / ( "max-age="
 delta-seconds ) / ( "max-stale" [ "=" delta-seconds ] ) / (
 "min-fresh=" delta-seconds ) / "no-transform" / "only-if-cached" /
 cache-extension
<x:ref>cache-response-directive</x:ref> = "public" / ( "private" [ "=" DQUOTE *( ","
 OWS ) field-name *( OWS "," [ OWS field-name ] ) DQUOTE ] ) / (
 "no-cache" [ "=" DQUOTE *( "," OWS ) field-name *( OWS "," [ OWS
 field-name ] ) DQUOTE ] ) / "no-store" / "no-transform" /
 "must-revalidate" / "proxy-revalidate" / ( "max-age=" delta-seconds
 ) / ( "s-maxage=" delta-seconds ) / cache-extension

<x:ref>delta-seconds</x:ref> = 1*DIGIT

<x:ref>extension-pragma</x:ref> = token [ "=" ( token / quoted-string ) ]

<x:ref>field-name</x:ref> = &lt;field-name, defined in [Part1], Section 4.2&gt;

<x:ref>port</x:ref> = &lt;port, defined in [Part1], Section 2.1&gt;
<x:ref>pragma-directive</x:ref> = "no-cache" / extension-pragma
<x:ref>pseudonym</x:ref> = &lt;pseudonym, defined in [Part1], Section 8.9&gt;

<x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in [Part1], Section 1.2.2&gt;

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 1.2.2&gt;

<x:ref>uri-host</x:ref> = &lt;uri-host, defined in [Part1], Section 2.1&gt;

<x:ref>warn-agent</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>warn-code</x:ref> = 3DIGIT
<x:ref>warn-date</x:ref> = DQUOTE HTTP-date DQUOTE
<x:ref>warn-text</x:ref> = quoted-string
<x:ref>warning-value</x:ref> = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]

; Age defined but not used
; Cache-Control defined but not used
; Expires defined but not used
; Pragma defined but not used
; Vary defined but not used
; Warning defined but not used


</artwork>
</figure>
</section>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/9"/>:
      "Trailer"
      (<eref target="http://purl.org/NET/http-errata#trailer-hop"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/12"/>:
      "Invalidation after Update or Delete"
      (<eref target="http://purl.org/NET/http-errata#invalidupd"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/48"/>:
      "Date reference typo"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/49"/>:
      "Connection header text"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/65"/>:
      "Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/66"/>:
      "ISO-8859-1 Reference"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86"/>:
      "Normative up-to-date references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/87"/>:
      "typo in 13.2.2"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Use names of RFC4234 core rule DQUOTE (work in progress on <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>)
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-01">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/82"/>:
      "rel_path not used"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
       Get rid of duplicate BNF rule names ("host" -> "uri-host")
       (work in progress on <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>)
    </t>
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-02" anchor="changes.since.02">
<t>
  Ongoing work on IANA Message Header Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header registrations for headers defined
      in this document.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-03" anchor="changes.since.03">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/106"/>:
      "Vary header classification"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-04" anchor="changes.since.04">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-05" anchor="changes.since.05">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

</section>

</back>
</rfc>
