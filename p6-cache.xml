<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "July">
  <!ENTITY ID-YEAR "2010">
  <!ENTITY notation                    "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules                 "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                         "<xref target='Part1' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri      "<xref target='Part1' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                   "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conditional                 "<xref target='Part4' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY partial                     "<xref target='Part5' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY combining-byte-ranges       "<xref target='Part5' x:rel='#combining.byte.ranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY full-date                   "<xref target='Part1' x:rel='#date.time.formats.full.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-authorization        "<xref target='Part7' x:rel='#header.authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-connection           "<xref target='Part1' x:rel='#header.connection' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                 "<xref target='Part1' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-via                  "<xref target='Part1' x:rel='#header.via' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified        "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-fields               "<xref target='Part1' x:rel='#header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods                "<xref target='Part2' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY weak-and-strong             "<xref target='Part4' x:rel='#weak.and.strong.validators' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes                "<xref target='Part2' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc category="std" docName="draft-ietf-httpbis-p6-cache-&ID-VERSION;" ipr="pre5378Trust200902"
  obsoletes="2616" x:maturity-level="draft" xmlns:x="http://purl.org/net/xml2rfc/ext">
<front>

  <title abbrev="HTTP/1.1, Part 6">HTTP/1.1, part 6: Caching</title>

  <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <postal>
        <street>23 Corporate Plaza DR, Suite 280</street>
        <city>Newport Beach</city>
        <region>CA</region>
        <code>92660</code>
        <country>USA</country>
      </postal>
      <phone>+1-949-706-5300</phone>
      <facsimile>+1-949-706-5305</facsimile>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@freedesktop.org</email>
      <uri>http://gettys.wordpress.com/</uri>
    </address>
  </author>

  <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author fullname="Larry Masinter" initials="L." surname="Masinter">
    <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>

  <author fullname="Paul J. Leach" initials="P." surname="Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>

  <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
    <address>
      <email>mnot@mnot.net</email>
      <uri>http://www.mnot.net/</uri>
    </address>
  </author>

  <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>
      <facsimile>+49 251 2807761</facsimile>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;" />
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
  The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed,
  collaborative, hypermedia information systems. This document is Part 6 of the seven-part
  specification that defines the protocol referred to as "HTTP/1.1" and, taken together,
  obsoletes RFC 2616. Part 6 defines requirements on HTTP caches and the associated header
  fields that control cache behavior or indicate cacheable response messages.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org). The current issues list is
    at <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/>
    and related documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.10"/>.
  </t>
</note>

  </front>
  <middle>

<section anchor="caching" title="Introduction">
<t>
  HTTP is typically used for distributed information systems, where performance can be
  improved by the use of response caches. This document defines aspects of HTTP/1.1 related to
  caching and reusing response messages.
</t>

<section anchor="intro.purpose" title="Purpose">
<iref item="cache" />
<t>
  An HTTP <x:dfn>cache</x:dfn> is a local store of response messages and the subsystem that
  controls its message storage, retrieval, and deletion. A cache stores cacheable responses
  in order to reduce the response time and network bandwidth consumption on future,
  equivalent requests. Any client or server &MAY; employ a cache, though a cache cannot be
  used by a server that is acting as a tunnel.
</t>
<t>
  Caching would be useless if it did not significantly improve performance. The goal of
  caching in HTTP/1.1 is to reuse a prior response message to satisfy a current request. In
  some cases, a stored response can be reused without the need for a network request,
  reducing latency and network round-trips; a "freshness" mechanism is used for this purpose
  (see <xref target="expiration.model" />). Even when a new request is required, it is often
  possible to reuse all or parts of the payload of a prior response to satisfy the request,
  thereby reducing network bandwidth usage; a "validation" mechanism is used for this
  purpose (see <xref target="validation.model" />).
</t>
</section>

<section anchor="intro.terminology" title="Terminology">
<t>
  This specification uses a number of terms to refer to the roles played by participants
  in, and objects of, HTTP caching.
</t>
<t>
  <iref item="cacheable" />
  <x:dfn>cacheable</x:dfn>
  <list>
    <t>A response is cacheable if a cache is allowed to store a copy of the response message
      for use in answering subsequent requests. Even when a response is cacheable, there might
      be additional constraints on whether a cache can use the cached copy to satisfy a
      particular request.</t>
  </list>
</t>
<t>
  <iref item="explicit expiration time" />
  <x:dfn>explicit expiration time</x:dfn>
  <list>
    <t>The time at which the origin server intends that a representation should no longer be
      returned by a cache without further validation.</t>
  </list>
</t>
<t>
  <iref item="heuristic expiration time" />
  <x:dfn>heuristic expiration time</x:dfn>
  <list>
    <t>An expiration time assigned by a cache when no explicit expiration time is
    available.</t>
  </list>
</t>
<t>
  <iref item="age" />
  <x:dfn>age</x:dfn>
  <list>
    <t>The age of a response is the time since it was sent by, or successfully validated
      with, the origin server.</t>
  </list>
</t>
<t>
  <iref item="first-hand" />
  <x:dfn>first-hand</x:dfn>
  <list>
    <t>A response is first-hand if the freshness model is not in use; i.e., its age is
    0.</t>
  </list>
</t>
<t>
  <iref item="freshness lifetime" />
  <x:dfn>freshness lifetime</x:dfn>
  <list>
    <t>The length of time between the generation of a response and its expiration time. </t>
  </list>
</t>
<t>
  <iref item="fresh" />
  <x:dfn>fresh</x:dfn>
  <list>
    <t>A response is fresh if its age has not yet exceeded its freshness lifetime.</t>
  </list>
</t>
<t>
  <iref item="stale" />
  <x:dfn>stale</x:dfn>
  <list>
    <t>A response is stale if its age has passed its freshness lifetime (either explicit or heuristic).</t>
  </list>
</t>
<t>
  <iref item="validator" />
  <x:dfn>validator</x:dfn>
  <list>
    <t>A protocol element (e.g., an entity-tag or a Last-Modified time) that is used to find
      out whether a stored response has an equivalent copy of a representation.</t>
  </list>
</t>
<t anchor="shared.and.non-shared.caches">
  <iref item="validator" />
  <x:dfn>shared cache</x:dfn>
  <list>
    <t>A cache that is accessible to more than one user. A non-shared cache is
      dedicated to a single user.</t>
  </list>
</t>
</section>

<section anchor="intro.requirements" title="Requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   An implementation is not compliant if it fails to satisfy one or more
   of the "MUST" or "REQUIRED" level requirements for the protocols it
   implements. An implementation that satisfies all the "MUST" or "REQUIRED"
   level and all the "SHOULD" level requirements for its protocols is said
   to be "unconditionally compliant"; one that satisfies all the "MUST"
   level requirements but not all the "SHOULD" level requirements for its
   protocols is said to be "conditionally compliant".
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="WSP"/>
<t>
  This specification uses the ABNF syntax defined in &notation; (which
  extends the syntax defined in <xref target="RFC5234"/> with a list rule).
  <xref target="collected.abnf"/> shows the collected ABNF, with the list
  rule expanded.
</t>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space),
  VCHAR (any visible USASCII character),
  and WSP (whitespace).
</t>

<section title="Core Rules" anchor="core.rules">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="OWS"/>
<t>
  The core rules below are defined in &basic-rules;:
</t>
<figure><artwork type="abnf2616">
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in &basic-rules;&gt;
  <x:ref>token</x:ref>         = &lt;token, defined in &basic-rules;&gt;
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &basic-rules;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification" anchor="abnf.dependencies">
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="HTTP-date"/>
  <x:anchor-alias value="port"/>
  <x:anchor-alias value="pseudonym"/>
  <x:anchor-alias value="uri-host"/>
<t>
  The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part1--><artwork type="abnf2616">
  <x:ref>field-name</x:ref>    = &lt;field-name, defined in &header-fields;&gt;
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &full-date;&gt;
  <x:ref>port</x:ref>          = &lt;port, defined in &uri;&gt;
  <x:ref>pseudonym</x:ref>     = &lt;pseudonym, defined in &header-via;&gt; 
  <x:ref>uri-host</x:ref>      = &lt;uri-host, defined in &uri;&gt;
</artwork></figure>
</section>

</section>
</section>

<section anchor="caching.overview" title="Cache Operation">

<section anchor="response.cacheability" title="Response Cacheability">
<t>
  A cache &MUST-NOT; store a response to any request, unless:
  <list style="symbols">
    <t>The request method is understood by the cache and defined as being cacheable, and</t>
    <t>the response status code is understood by the cache, and</t>
    <t>the "no-store" cache directive (see <xref target="header.cache-control" />) does not
       appear in request or response headers, and</t>
    <t>the "private" cache response directive (see <xref target="cache-response-directive" />
       does not appear in the response, if the cache is shared, and</t>
    <t>the "Authorization" header (see &header-authorization;) does not appear in the request, if
       the cache is shared, unless the response explicitly allows it (see <xref
       target="caching.authenticated.responses" />), and</t>
    <t>the response either:
      <list style="symbols">
        <t>contains an Expires header (see <xref target="header.expires" />), or</t>
        <t>contains a max-age response cache directive (see <xref target="cache-response-directive" />), or</t>
        <t>contains a s-maxage response cache directive and the cache is shared, or</t>
        <t>contains a Cache Control Extension (see <xref target="cache.control.extensions" />) that allows it to be cached, or</t>
        <t>has a status code that can be served with heuristic freshness (see <xref
           target="heuristic.freshness" />).</t>
      </list>
    </t>
  </list>
</t>
<t>
  In this context, a cache has "understood" a request method or a response status
  code if it recognises it and implements any cache-specific behaviour. In
  particular, 206 Partial Content responses cannot be cached by an
  implementation that does not handle partial content
  (see <xref target="errors.or.incomplete.response.cache.behavior" />).
</t>
<t>
  Note that in normal operation, most caches will not store a response that has neither a
  cache validator nor an explicit expiration time, as such responses are not usually
  useful to store. However, caches are not prohibited from storing such responses.
</t>

<section anchor="errors.or.incomplete.response.cache.behavior" title="Storing Partial and Incomplete Responses">
<t>
  A cache that receives an incomplete response (for example, with fewer bytes of data
  than specified in a Content-Length header) can store the response, but &MUST; 
  treat it as a partial response &partial;. Partial responses
  can be combined as described in &combining-byte-ranges;; the result might be a
  full response or might still be partial. A cache &MUST-NOT; return a partial
  response to a client without explicitly marking it as such using the 206 (Partial
  Content) status code.
</t>
<t>
  A cache that does not support the Range and Content-Range headers &MUST-NOT; store
  incomplete or partial responses.
</t>
</section>

</section>


<section anchor="constructing.responses.from.caches" title="Constructing Responses from Caches">
<t>
  For a presented request, a cache &MUST-NOT; return a stored response, unless: 
  <list style="symbols">
    <t>The presented Effective Request URI (&effective-request-uri;) and that of the stored response match, and</t>
    <t>the request method associated with the stored response allows it to be 
      used for the presented request, and</t>
    <t>selecting request-headers nominated by the stored response (if any) match those presented (see <xref
      target="caching.negotiated.responses" />), and</t>
    <t>the presented request and stored response are free from directives that would prevent
      its use (see <xref target="header.cache-control" /> and <xref target="header.pragma"/>),
      and</t>
    <t>the stored response is either:
      <list style="symbols">
        <t>fresh (see <xref target="expiration.model" />), or</t>
        <t>allowed to be served stale (see <xref target="serving.stale.responses" />), or</t>
        <t>successfully validated (see <xref target="validation.model" />).</t>
      </list>
    </t>
  </list>
</t>
<t>
  When a stored response is used to satisfy a request, caches &MUST; include a
  single Age header field (<xref target="header.age" />) in the response with a value equal to the stored response's
  current_age; see <xref target="age.calculations" />. 
  <cref anchor="DISCUSS-includes-validated">this currently includes successfully validated responses.</cref>
</t>
<t>
  Requests with methods that are unsafe (&safe-methods;) &MUST; be written through the cache to
  the origin server; i.e., a cache must not reply to such a request before having forwarded the request and having received a
  corresponding response.
</t>
<t>
  Also, note that unsafe requests might invalidate already stored responses; see
  <xref target="invalidation.after.updates.or.deletions" />.
</t>
<t>
  Caches &MUST; use the most recent response (as determined by the Date header) when
  more than one suitable response is stored. They can also forward a request with
  "Cache-Control: max-age=0" or "Cache-Control: no-cache" to disambiguate which response to
  use.
</t>
</section>

<section anchor="expiration.model" title="Freshness Model">
<t>
  When a response is "fresh" in the cache, it can be used to satisfy subsequent
  requests without contacting the origin server, thereby improving efficiency.
</t>
<t>
  The primary mechanism for determining freshness is for an origin server to provide an
  explicit expiration time in the future, using either the Expires header (<xref
  target="header.expires" />) or the max-age response cache directive (<xref
  target="cache-response-directive" />). Generally, origin servers will assign future
  explicit expiration times to responses in the belief that the representation is not likely to
  change in a semantically significant way before the expiration time is reached.
</t>
<t>
  If an origin server wishes to force a cache to validate every request, it can
  assign an explicit expiration time in the past. This means that the response is always
  stale, so that caches should validate it before using it for subsequent requests.
  <cref anchor="TODO-response-stale">This wording might cause confusion, because the response might still be served stale.</cref>
</t>
<t>
  Since origin servers do not always provide explicit expiration times, HTTP caches &MAY;
  assign heuristic expiration times when explicit times are not specified, employing algorithms that
  use other header values (such as the Last-Modified time) to estimate a plausible
  expiration time. The HTTP/1.1 specification does not provide specific algorithms, but does
  impose worst-case constraints on their results.
</t>
<figure>
<preamble>
  The calculation to determine if a response is fresh is:
</preamble>
<artwork type="code">
   response_is_fresh = (freshness_lifetime &gt; current_age)
</artwork>
</figure>
<t>
  The freshness_lifetime is defined in <xref target="calculating.freshness.lifetime" />;
  the current_age is defined in <xref target="age.calculations" />.
</t>
<t>
  Additionally, clients might need to influence freshness calculation. They can do this using
  several request cache directives, with the effect of either increasing or loosening
  constraints on freshness. See <xref target="cache-request-directive" />.
</t>
<t>
  <cref anchor="ISSUE-no-req-for-directives">there are not requirements directly applying to cache-request-directives and
  freshness.</cref>
</t>
<t>
  Note that freshness applies only to cache operation; it cannot be used to force a user agent 
  to refresh its display or reload a resource. See <xref target="history.lists" /> for an explanation of
  the difference between caches and history mechanisms.
</t>

<section anchor="calculating.freshness.lifetime" title="Calculating Freshness Lifetime">
<t>
  A cache can calculate the freshness lifetime (denoted as freshness_lifetime) of a
  response by using the first match of:
  <list style="symbols">
    <t>If the cache is shared and the s-maxage response cache directive (<xref
      target="cache-response-directive" />) is present, use its value, or</t>
    <t>If the max-age response cache directive (<xref target="cache-response-directive"
      />) is present, use its value, or</t>
    <t>If the Expires response header (<xref target="header.expires" />) is present, use
      its value minus the value of the Date response header, or</t>
    <t>Otherwise, no explicit expiration time is present in the response. A heuristic
      freshness lifetime might be applicable; see <xref target="heuristic.freshness" />.</t>
  </list>
</t>
<t>
  Note that this calculation is not vulnerable to clock skew, since all of the
  information comes from the origin server.
</t>

<section anchor="heuristic.freshness" title="Calculating Heuristic Freshness">
<t>
  If no explicit expiration time is present in a stored response that has a status code
  whose definition allows heuristic freshness to be used (including the following
  in &status-codes;: 200, 203, 206, 300, 301 and 410), a heuristic expiration time &MAY; be
  calculated. Heuristics &MUST-NOT; be used for response status codes that do not explicitly
  allow it.
</t>
<t>
  When a heuristic is used to calculate freshness lifetime, the cache &SHOULD;
  attach a Warning header with a 113 warn-code to the response if its current_age is
  more than 24 hours and such a warning is not already present.
</t>
<t>
  Also, if the response has a Last-Modified header (&header-last-modified;), the
  heuristic expiration value &SHOULD; be no more than some fraction of the interval
  since that time. A typical setting of this fraction might be 10%.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> RFC 2616 (<xref target="RFC2616" x:fmt="," x:sec="13.9"/>)
    required that caches do not calculate heuristic freshness for URLs with
    query components (i.e., those containing '?'). In practice, this has not
    been widely implemented. Therefore, servers are encouraged to send explicit
    directives (e.g., Cache-Control: no-cache) if they wish to preclude
    caching.
  </t>
</x:note>
</section>
</section>

<section anchor="age.calculations" title="Calculating Age">
<t>
  HTTP/1.1 uses the Age response-header to convey the estimated age of the response
  message when obtained from a cache. The Age field value is the cache's estimate of the
  amount of time since the response was generated or validated by the origin server. In
  essence, the Age value is the sum of the time that the response has been resident in
  each of the caches along the path from the origin server, plus the amount of time it has
  been in transit along network paths.
</t>
<t>
  The following data is used for the age calculation:
</t>
<t>
  <x:dfn>age_value</x:dfn>
  <list>
    <t>
      The term "age_value" denotes the value of the Age header (<xref target="header.age"/>),
      in a form appropriate for arithmetic operation; or 0, if not available.
    </t>
  </list>
</t>
<t>
  <x:dfn>date_value</x:dfn>
  <list>
    <t>
      HTTP/1.1 requires origin servers to send a Date header, if possible,
      with every response, giving the time at which the response was generated.
      The term "date_value" denotes the value of the Date header, in a form
      appropriate for arithmetic operations. See &header-date; for the definition
      of the Date header, and for requirements regarding responses without a
      Date response header.
    </t>
  </list>
</t>
<t>
  <x:dfn>now</x:dfn>
  <list>
    <t>
      The term "now" means "the current value of the clock at the host
      performing the calculation". Hosts that use HTTP, but especially hosts
      running origin servers and caches, &SHOULD; use NTP
      (<xref target="RFC1305"/>) or some similar protocol to synchronize their
      clocks to a globally accurate time standard.
    </t>
  </list>
</t>
<t>
  <x:dfn>request_time</x:dfn>
  <list>
    <t>
      The current value of the clock at the host at the time the request
      resulting in the stored response was made.
    </t>
  </list>
</t>
<t>
  <x:dfn>response_time</x:dfn>
  <list>
    <t>
      The current value of the clock at the host at the time the response was
      received.
    </t>
  </list>
</t>
<t>
  A response's age can be calculated in two entirely independent ways:
  <list style="numbers">
    <t>the "apparent_age": response_time minus date_value, if the local clock is reasonably well synchronized to the
      origin server's clock. If the result is negative, the result is replaced by zero.</t>
    <t>the "corrected_age_value", if all of the caches along the response path implement HTTP/1.1;
      note this value &MUST; be interpreted relative to the time the
      request was initiated, not the time that the response was received.</t>
  </list>
</t>
<figure>
<artwork type="code">
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;  
</artwork>
</figure>
<figure>
<preamble>These are combined as</preamble>
<artwork type="code">
  corrected_initial_age = max(apparent_age, corrected_age_value);
</artwork></figure>
<t>
  The current_age of a stored response can then be calculated by adding the amount of
  time (in seconds) since the stored response was last validated by the origin server to
  the corrected_initial_age.
</t>
<figure><artwork type="code">
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
</artwork></figure>
</section>

<section anchor="serving.stale.responses" title="Serving Stale Responses">
<t>
  A "stale" response is one that either has explicit expiry information or is allowed to
  have heuristic expiry calculated, but is not fresh according to the calculations in
  <xref target="expiration.model" />.
</t>
<t>
  Caches &MUST-NOT; return a stale response if it is prohibited by an explicit
  in-protocol directive (e.g., by a "no-store" or "no-cache" cache directive, a
  "must-revalidate" cache-response-directive, or an applicable "s-maxage" or
  "proxy-revalidate" cache-response-directive; see <xref target="cache-response-directive"/>).
</t>
<t>
  Caches &SHOULD-NOT; return stale responses unless they are
  disconnected (i.e., it cannot contact the origin server or otherwise find a forward path) 
  or otherwise explicitly allowed (e.g., the max-stale request directive; see <xref target="cache-request-directive" />).
</t>
<t>
  Stale responses &SHOULD; have a Warning header with the 110 warn-code (see <xref
  target="header.warning" />). Likewise, the 112 warn-code &SHOULD; be sent on stale responses if 
  the cache is disconnected.
</t>
<t>
  If a cache receives a first-hand response (either an entire response, or a 304 (Not
  Modified) response) that it would normally forward to the requesting client, and the
  received response is no longer fresh, the cache &SHOULD; forward it to the
  requesting client without adding a new Warning (but without removing any existing
  Warning headers). A cache &SHOULD-NOT; attempt to validate a response simply because
  that response became stale in transit.
</t>
</section>
</section>

<section anchor="validation.model" title="Validation Model">
<t>
  When a cache has one or more stored responses for a requested URI, but cannot  
  serve any of them (e.g., because they are not fresh, or one cannot be selected; 
  see <xref target="caching.negotiated.responses"/>), 
  it can use the conditional request mechanism &conditional; in the forwarded 
  request to give the origin server an opportunity to both select a valid stored 
  response to be used, and to update it. This process is known as "validating" 
  or "revalidating" the stored response.
</t>
<t>
  When sending such a conditional request, the cache &SHOULD; add an If-Modified-Since 
  header whose value is that of the Last-Modified header from the selected 
  (see <xref target="caching.negotiated.responses"/>) stored response, if available.
</t>
<t>
  Additionally, the cache &SHOULD; add an If-None-Match header whose value  
  is that of the ETag header(s) from all responses stored for the requested URI, 
  if present. However, if any of the stored responses contains only partial
  content, its entity-tag &SHOULD-NOT; be included in the If-None-Match header 
  field unless the request is for a range that would be fully satisfied by 
  that stored response.
</t>
<t>
  A 304 (Not Modified) response status code indicates that the stored 
  response can be updated and reused; see <xref target="combining.headers"/>.
</t>
<t>
  A full response (i.e., one with a response body) indicates that none  
  of the stored responses nominated in the conditional request is
  suitable. Instead, the full response &SHOULD; be used to satisfy the
  request and &MAY; replace the stored response.
</t>
<t>
  If a cache receives a 5xx response while attempting to validate a response, it &MAY;
  either forward this response to the requesting client, or act as if the server failed to
  respond. In the latter case, it &MAY; return a previously stored response (see <xref
  target="serving.stale.responses" />).
</t>
</section>

<section anchor="invalidation.after.updates.or.deletions" title="Request Methods that Invalidate">
<t>
  Because unsafe methods (&safe-methods;) have the potential for changing state on the
  origin server, intervening caches can use them to keep their contents
  up-to-date.
</t>
<t>
  The following HTTP methods &MUST; cause a cache to invalidate the Effective Request URI (&effective-request-uri;) as well
  as the URI(s) in the Location and Content-Location headers (if present):
  <list style="symbols">
    <t>PUT</t>
    <t>DELETE</t>
    <t>POST</t>
  </list>
</t>
<t>
  An invalidation based on a URI from a Location or Content-Location header &MUST-NOT;
  be performed if the host part of that URI differs from the host part in the Effective Request URI (&effective-request-uri;).
  This helps prevent denial of service attacks.
</t>
<t>
  <cref anchor="TODO-def-host-part">"host part" needs to be specified better.</cref>
</t>
<t>
  A cache that passes through requests for methods it does not understand &SHOULD;
  invalidate the Effective Request URI (&effective-request-uri;).
</t>
<t>
  Here, "invalidate" means that the cache will either remove all stored responses related
  to the Effective Request URI, or will mark these as "invalid" and in need of a mandatory validation
  before they can be returned in response to a subsequent request.
</t>
<t>
  Note that this does not guarantee that all appropriate responses are invalidated. For
  example, the request that caused the change at the origin server might not have gone
  through the cache where a response is stored.
</t>
<t>
  <cref anchor="TODO-spec-success-invalidate">specify that only successful (2xx, 3xx?) responses invalidate.</cref>
</t>
</section>

<section anchor="caching.authenticated.responses" title="Shared Caching of Authenticated Responses">

<t>Shared caches &MUST-NOT; use a cached response to a request with an Authorization header (&header-authorization;) to satisfy any subsequent request unless a cache directive that allows such responses to be stored is present in the response.</t>

<t>In this specification, the following Cache-Control response directives (<xref target="cache-response-directive"/>) have such an effect: must-revalidate, public, s-maxage.</t>

<t>Note that cached responses that contain the "must-revalidate" and/or "s-maxage" response directives are not allowed to be served stale (<xref target="serving.stale.responses"/>) by shared caches. In particular, a response with either "max-age=0, must-revalidate" or "s-maxage=0" cannot be used to satisfy a subsequent request without revalidating it on the origin server.</t>
</section>

<section anchor="caching.negotiated.responses" title="Caching Negotiated Responses">
<t>
  When a cache receives a request that can be satisfied by a stored response
  that has a Vary header field (<xref target="header.vary"/>), it &MUST-NOT; use that 
  response unless all of the selecting request-headers nominated by the Vary header match
  in both the original request (i.e., that associated with the stored response),
  and the presented request.
</t>
<t>
  The selecting request-headers from two requests are defined to match
  if and only if those in the first request can be transformed to those in the
  second request by applying any of the following:
  <list style="symbols">
    <t>
      adding or removing whitespace, where allowed in the header's syntax
    </t>
    <t>
      combining multiple message-header fields with the same field name (see
      &header-fields;)
    </t>
    <t>
      normalizing both header values in a way that is known to have identical
      semantics, according to the header's specification (e.g., re-ordering field values
      when order is not significant; case-normalization, where values are defined to be
      case-insensitive)   
    </t>
  </list>
</t>
<t>
  If (after any normalization that might take place) a header field is absent
  from a request, it can only match another request if it is also absent there.
</t>
<t>
  A Vary header field-value of "*" always fails to match, and subsequent requests to that
  resource can only be properly interpreted by the origin server.
</t>
<t>
  The stored response with matching selecting request-headers is known as the
  selected response.
</t>
<t>
  If no selected response is available, the cache &MAY; forward the presented 
  request to the origin server in a conditional request; see <xref target="validation.model"/>.
</t>
</section>

<section anchor="combining.headers" title="Combining Responses">
<t>
  When a cache receives a 304 (Not Modified) response or a 206 (Partial Content) response
  (in this section, the "new" response"), it needs to created an updated response by combining
  the stored response with the new one, so that the updated response can be used to satisfy the request.
</t>
<t>
  If the new response contains an ETag, it identifies the stored  
  response to use. <cref anchor="TODO-mention-CL">might need language about Content-Location  
  here</cref>
</t>
<t>
  If the status code is 206 (partial content), both the stored and new  
  responses &MUST; have validators, and those validators &MUST; match using the strong  
  comparison function (see &weak-and-strong;). Otherwise, the  
  responses &MUST-NOT; be combined.
</t>
<t>
  The stored response headers are used as those of the updated response, except that
  <list style="symbols">
    <t>any stored Warning headers with warn-code 1xx (see <xref target="header.warning" />)
      &MUST; be deleted from the stored response and the updated response.</t>
    <t>any stored Warning headers with warn-code 2xx &MUST; be retained in the stored
      response and the updated response.</t>
    <t>any headers provided in the new response &MUST; replace the corresponding
      headers from the stored response.</t>
  </list>
</t>
<t>
  If a header field-name in the new response matches more than one  
  header in the stored response, all such stored headers &MUST; be replaced.
</t>
<t>
  The updated response can <cref anchor="TODO-is-req">requirement?</cref> be used to replace the  
  stored response in cache. In the case of a 206 response, the combined  
  representation &MAY; be stored.
</t>
</section>

</section>

<section anchor="header.fields" title="Header Field Definitions">
<t>
  This section defines the syntax and semantics of HTTP/1.1 header fields
  related to caching.
</t>
<t>
  For entity-header fields, both sender and recipient refer to either the client or the
  server, depending on who sends and who receives the message.
</t>

<section anchor="header.age" title="Age">
  <iref item="Age header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Age" x:for-anchor="" />
  <x:anchor-alias value="Age"/>
  <x:anchor-alias value="Age-v"/>
  <x:anchor-alias value="age-value"/>
<t>
  The "Age" response-header field conveys the sender's estimate of the amount
  of time since the response was generated or successfully validated at the
  origin server. Age values are calculated as specified in
  <xref target="age.calculations" />.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Age"/><iref primary="true" item="Grammar" subitem="Age-v"/>
  <x:ref>Age</x:ref>   = "Age" ":" <x:ref>OWS</x:ref> <x:ref>Age-v</x:ref>
  <x:ref>Age-v</x:ref> = <x:ref>delta-seconds</x:ref>
</artwork></figure>
<t anchor="rule.delta-seconds">
  <x:anchor-alias value="delta-seconds" />
  Age field-values are non-negative integers, representing time in seconds.
</t>
<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" subitem="delta-seconds" />
  <x:ref>delta-seconds</x:ref>  = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
  If a cache receives a value larger than the largest positive integer it can represent, or
  if any of its age calculations overflows, it &MUST; transmit an Age header with a
  field-value of 2147483648 (2<x:sup>31</x:sup>). Caches &SHOULD; use an arithmetic type
  of at least 31 bits of range.
</t>
<t>
  The presence of an Age header field in a response implies that a response is not
  first-hand. However, the converse is not true, since HTTP/1.0 caches might not implement the
  Age header field.
</t>
</section>

<section anchor="header.cache-control" title="Cache-Control">
  <iref item="Cache-Control header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Cache-Control" x:for-anchor="" />
  <x:anchor-alias value="Cache-Control"/>
  <x:anchor-alias value="Cache-Control-v"/>
  <x:anchor-alias value="cache-directive"/>
  <x:anchor-alias value="cache-extension"/>
  <x:anchor-alias value="cache-request-directive"/>
  <x:anchor-alias value="cache-response-directive"/>
<t>
  The "Cache-Control" general-header field is used to specify directives for
  caches along the request/response chain. Such cache directives are
  unidirectional in that the presence of a directive in a request does not
  imply that the same directive is to be given in the response.
</t>
<t>
  HTTP/1.1 caches &MUST; obey the requirements of the Cache-Control directives
  defined in this section. See <xref target="cache.control.extensions"/> for
  information about how Cache-Control directives defined elsewhere are handled.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> HTTP/1.0 caches might not implement Cache-Control and
    might only implement Pragma: no-cache (see <xref target="header.pragma" />).
  </t>
</x:note>
<t>
  Cache directives &MUST; be passed through by a proxy or gateway application,
  regardless of their significance to that application, since the directives might be
  applicable to all recipients along the request/response chain. It is not possible to
  target a directive to a specific cache.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Cache-Control"/><iref primary="true" item="Grammar" subitem="Cache-Control-v"/><iref primary="true" item="Grammar" subitem="cache-extension"/>
  <x:ref>Cache-Control</x:ref>   = "Cache-Control" ":" <x:ref>OWS</x:ref> <x:ref>Cache-Control-v</x:ref>
  <x:ref>Cache-Control-v</x:ref> = 1#<x:ref>cache-directive</x:ref>

  <x:ref>cache-directive</x:ref> = <x:ref>cache-request-directive</x:ref>
     / <x:ref>cache-response-directive</x:ref>

  <x:ref>cache-extension</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>

<section anchor="cache-request-directive" title="Request Cache-Control Directives">
  <x:anchor-alias value="cache-request-directive" />

<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" subitem="cache-request-directive" />
  <x:ref>cache-request-directive</x:ref> =
       "no-cache"
     / "no-store"
     / "max-age" "=" <x:ref>delta-seconds</x:ref>
     / "max-stale" [ "=" <x:ref>delta-seconds</x:ref> ]
     / "min-fresh" "=" <x:ref>delta-seconds</x:ref>
     / "no-transform"
     / "only-if-cached"
     / <x:ref>cache-extension</x:ref>
</artwork></figure>

<t>
  <x:dfn>no-cache</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-cache" />
  <iref item="no-cache" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-cache request directive indicates that a stored response &MUST-NOT; be
      used to satisfy the request without successful validation on the origin server.</t>
  </list>
</t>
<t>
  <x:dfn>no-store</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-store" />
  <iref item="no-store" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-store request directive indicates that a cache &MUST-NOT; store any part
      of either this request or any response to it. This directive applies to both
      non-shared and shared caches. "&MUST-NOT; store" in this context means that the
      cache &MUST-NOT; intentionally store the information in non-volatile storage,
      and &MUST; make a best-effort attempt to remove the information from volatile
      storage as promptly as possible after forwarding it.</t>
    <t>This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or obey this
      directive, and communications networks might be vulnerable to eavesdropping.</t>
  </list>
</t>
<t>
  <x:dfn>max-age</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="max-age" />
  <iref item="max-age" primary="true" subitem="Cache Directive" />
  <list>
    <t>The max-age request directive indicates that the client is willing to accept a
      response whose age is no greater than the specified time in seconds. Unless
      the max-stale request directive is also present, the client is not willing to accept a stale
      response.</t>
  </list>
</t>
<t>
  <x:dfn>max-stale</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="max-stale" />
  <iref item="max-stale" primary="true" subitem="Cache Directive" />
  <list>
    <t>The max-stale request directive indicates that the client is willing to accept a
      response that has exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded its expiration
      time by no more than the specified number of seconds. If no value is assigned to
      max-stale, then the client is willing to accept a stale response of any age. <cref anchor="TODO-staleness" source="mnot">of any staleness?</cref></t>
  </list>
</t>
<t>
  <x:dfn>min-fresh</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="min-fresh" />
  <iref item="min-fresh" primary="true" subitem="Cache Directive" />
  <list>
    <t>The min-fresh request directive indicates that the client is willing to accept a
      response whose freshness lifetime is no less than its current age plus the specified
      time in seconds. That is, the client wants a response that will still be fresh for
      at least the specified number of seconds.</t>
  </list>
</t>
<t>
  <x:dfn>no-transform</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-transform" />
  <iref item="no-transform" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-transform request directive indicates that an intermediate cache or proxy
      &MUST-NOT; change the Content-Encoding, Content-Range or Content-Type request
      headers, nor the request representation.</t>
  </list>
</t>
<t>
  <x:dfn>only-if-cached</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="only-if-cached" />
  <iref item="only-if-cached" primary="true" subitem="Cache Directive" />
  <list>
    <t>The only-if-cached request directive indicates that the client only wishes to
      return a stored response. If it receives this directive, a cache &SHOULD; either
      respond using a stored response that is consistent with the other constraints of the
      request, or respond with a 504 (Gateway Timeout) status code. If a group of caches is
      being operated as a unified system with good internal connectivity, such a request
      &MAY; be forwarded within that group of caches.</t>
  </list>
</t>
</section>

<section anchor="cache-response-directive" title="Response Cache-Control Directives">
  <x:anchor-alias value="cache-response-directive" />

<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" subitem="cache-response-directive" />
  <x:ref>cache-response-directive</x:ref> =
       "public"
     / "private" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ]
     / "no-cache" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ]
     / "no-store"
     / "no-transform"
     / "must-revalidate"
     / "proxy-revalidate"
     / "max-age" "=" <x:ref>delta-seconds</x:ref>
     / "s-maxage" "=" <x:ref>delta-seconds</x:ref>
     / <x:ref>cache-extension</x:ref>
</artwork></figure>

<t>
  <x:dfn>public</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="public" />
  <iref item="public" primary="true" subitem="Cache Directive" />
  <list>
    <t>The public response directive indicates that the response &MAY; be cached, even
      if it would normally be non-cacheable or cacheable only within a non-shared cache.
      (See also Authorization, &header-authorization;, for additional details.) </t>
  </list>
</t>
<t>
  <x:dfn>private</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="private" />
  <iref item="private" primary="true" subitem="Cache Directive" />
  <list>
    <t>The private response directive indicates that the response message is intended for
      a single user and &MUST-NOT; be stored by a shared cache. A private (non-shared)
      cache &MAY; store the response.</t>
    <t>If the private response directive specifies one or more field-names, this
      requirement is limited to the field-values associated with the listed response
      headers. That is, the specified field-names(s) &MUST-NOT; be stored by a shared
      cache, whereas the remainder of the response message &MAY; be.</t>
    <t>
      <x:h>Note:</x:h> This usage of the word private only controls where the response can
      be stored; it cannot ensure the privacy of the message content.
      Also, private response directives with field-names are often handled by
      implementations as if an unqualified private directive was received; i.e.,
      the special handling for the qualified form is not widely implemented.</t>
  </list>
</t>
<t>
  <x:dfn>no-cache</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-cache" />
  <iref item="no-cache" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-cache response directive indicates that the response MUST NOT be used 
	  to satisfy a subsequent request without successful validation on the origin 
	  server. This allows an origin server to prevent a cache from using it to satisfy 
	  a request without contacting it, even by caches that have been configured to 
	  return stale responses.</t>
    <t>If the no-cache response directive specifies one or more field-names, this
      requirement is limited to the field-values associated with the listed response
      headers. That is, the specified field-name(s) &MUST-NOT; be sent in the response
      to a subsequent request without successful validation on the origin server. This
      allows an origin server to prevent the re-use of certain header fields in a
      response, while still allowing caching of the rest of the response.</t>
    <t>
      <x:h>Note:</x:h> Most HTTP/1.0 caches will not recognize or obey this directive.
      Also, no-cache response directives with field-names are often handled by
      implementations as if an unqualified no-cache directive was received; i.e.,
      the special handling for the qualified form is not widely implemented.
    </t>
  </list>
</t>
<t>
  <x:dfn>no-store</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-store" />
  <iref item="no-store" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-store response directive indicates that a cache &MUST-NOT; store any
      part of either the immediate request or response. This directive applies to both
      non-shared and shared caches. "&MUST-NOT; store" in this context means that the
      cache &MUST-NOT; intentionally store the information in non-volatile storage,
      and &MUST; make a best-effort attempt to remove the information from volatile
      storage as promptly as possible after forwarding it.</t>
    <t>This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or obey this
      directive, and communications networks might be vulnerable to eavesdropping.</t>
  </list>
</t>
<t>
  <x:dfn>must-revalidate</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="must-revalidate" />
  <iref item="must-revalidate" primary="true" subitem="Cache Directive" />
  <list>
    <t>The must-revalidate response directive indicates that once it has become stale, the response &MUST-NOT; be 
     used to satisfy subsequent requests without successful validation on the origin server.</t>
    <t>The must-revalidate directive is necessary to support reliable operation for
      certain protocol features. In all circumstances an HTTP/1.1 cache &MUST; obey
      the must-revalidate directive; in particular, if the cache cannot reach the origin
      server for any reason, it &MUST; generate a 504 (Gateway Timeout) response.</t>
    <t>Servers &SHOULD; send the must-revalidate directive if and only if failure to
      validate a request on the representation could result in incorrect operation, such as a
      silently unexecuted financial transaction.</t>
  </list>
</t>
<t>
  <x:dfn>proxy-revalidate</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="proxy-revalidate" />
  <iref item="proxy-revalidate" primary="true" subitem="Cache Directive" />
  <list>
    <t>The proxy-revalidate response directive has the same meaning as the must-revalidate
      response directive, except that it does not apply to non-shared caches.</t>
  </list>
</t>
<t>
  <x:dfn>max-age</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="max-age" />
  <iref item="max-age" primary="true" subitem="Cache Directive" />
  <list>
    <t>The max-age response directive indicates that response is to be considered stale
      after its age is greater than the specified number of seconds.</t>
  </list>
</t>
<t>
  <x:dfn>s-maxage</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="s-maxage" />
  <iref item="s-maxage" primary="true" subitem="Cache Directive" />
  <list>
    <t>The s-maxage response directive indicates that, in shared caches, the maximum age
      specified by this directive overrides the maximum age specified by either the
      max-age directive or the Expires header. The s-maxage directive also implies the
      semantics of the proxy-revalidate response directive.</t>
  </list>
</t>
<t>
  <x:dfn>no-transform</x:dfn>
  <iref item="Cache Directives" primary="true" subitem="no-transform" />
  <iref item="no-transform" primary="true" subitem="Cache Directive" />
  <list>
    <t>The no-transform response directive indicates that an intermediate cache or proxy
      &MUST-NOT; change the Content-Encoding, Content-Range or Content-Type response
      headers, nor the response representation.</t>
  </list>
</t>

</section>

<section anchor="cache.control.extensions" title="Cache Control Extensions">
<t>
  The Cache-Control header field can be extended through the use of one or more
  cache-extension tokens, each with an optional value. Informational extensions (those
  that do not require a change in cache behavior) can be added without changing the
  semantics of other directives. Behavioral extensions are designed to work by acting as
  modifiers to the existing base of cache directives. Both the new directive and the
  standard directive are supplied, such that applications that do not understand the new
  directive will default to the behavior specified by the standard directive, and those
  that understand the new directive will recognize it as modifying the requirements
  associated with the standard directive. In this way, extensions to the cache-control
  directives can be made without requiring changes to the base protocol.
</t>
<t>
  This extension mechanism depends on an HTTP cache obeying all of the cache-control
  directives defined for its native HTTP-version, obeying certain extensions, and ignoring
  all directives that it does not understand.
</t>
<t>
  For example, consider a hypothetical new response directive called "community" that
  acts as a modifier to the private directive. We define this new directive to mean that,
  in addition to any non-shared cache, any cache that is shared only by members of the
  community named within its value may cache the response. An origin server wishing to
  allow the UCI community to use an otherwise private response in their shared cache(s)
  could do so by including
</t>
<figure><artwork type="example">
  Cache-Control: private, community="UCI"
</artwork></figure>
<t>
  A cache seeing this header field will act correctly even if the cache does not
  understand the community cache-extension, since it will also see and understand the
  private directive and thus default to the safe behavior.
</t>
<t>
  Unrecognized cache directives &MUST; be ignored; it is assumed that any cache
  directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard
  directives (or the response's default cacheability) such that the cache behavior will
  remain minimally correct even if the cache does not understand the extension(s).
</t>
<t>
  The HTTP Cache Directive Registry defines the name space for the cache
  directives.
</t>
<t>
  Registrations &MUST; include the following fields:
  <list style="symbols">
    <t>Cache Directive Name</t>
    <t>Pointer to specification text</t>
  </list>
</t>
<t>
  Values to be added to this name space are subject to IETF review
  (<xref target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
<t>
  The registry itself is maintained at <eref target="http://www.iana.org/assignments/http-cache-directives"/>.
</t>
</section>

</section>

<section anchor="header.expires" title="Expires">
  <iref item="Expires header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Expires" x:for-anchor="" />
  <x:anchor-alias value="Expires"/>
  <x:anchor-alias value="Expires-v"/>
<t>
  The "Expires" entity-header field gives the date/time after which the response is
  considered stale. See <xref target="expiration.model" /> for further discussion of the
  freshness model.
</t>
<t>
  The presence of an Expires field does not imply that the original resource will change or
  cease to exist at, before, or after that time.
</t>
<t>
  The field-value is an absolute date and time as defined by HTTP-date in &full-date;;
  it &MUST; be sent in rfc1123-date format.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Expires"/><iref primary="true" item="Grammar" subitem="Expires-v"/>
  <x:ref>Expires</x:ref>   = "Expires" ":" <x:ref>OWS</x:ref> <x:ref>Expires-v</x:ref>
  <x:ref>Expires-v</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<figure>
  <preamble>For example</preamble>
<artwork type="example">
  Expires: Thu, 01 Dec 1994 16:00:00 GMT
</artwork></figure>
<x:note>
  <t>
    <x:h>Note:</x:h> If a response includes a Cache-Control field with the max-age
    directive (see <xref target="cache-response-directive" />), that directive overrides
    the Expires field. Likewise, the s-maxage directive overrides Expires in shared caches.
  </t>
</x:note>
<t>
  HTTP/1.1 servers &SHOULD-NOT; send Expires dates more than one year in the future.
</t>
<t>
  HTTP/1.1 clients and caches &MUST; treat other invalid date formats, especially
  including the value "0", as in the past (i.e., "already expired").
</t>
</section>

<section anchor="header.pragma" title="Pragma">
  <iref item="Pragma header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Pragma" x:for-anchor="" />
  <x:anchor-alias value="extension-pragma"/>
  <x:anchor-alias value="Pragma"/>
  <x:anchor-alias value="Pragma-v"/>
  <x:anchor-alias value="pragma-directive"/>
<t>
  The "Pragma" general-header field is used to include implementation-specific directives
  that might apply to any recipient along the request/response chain. All pragma directives
  specify optional behavior from the viewpoint of the protocol; however, some systems
  &MAY; require that behavior be consistent with the directives.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Pragma"/><iref primary="true" item="Grammar" subitem="Pragma-v"/><iref primary="true" item="Grammar" subitem="pragma-directive"/><iref primary="true" item="Grammar" subitem="extension-pragma"/>
  <x:ref>Pragma</x:ref>            = "Pragma" ":" <x:ref>OWS</x:ref> <x:ref>Pragma-v</x:ref>
  <x:ref>Pragma-v</x:ref>          = 1#<x:ref>pragma-directive</x:ref>
  <x:ref>pragma-directive</x:ref>  = "no-cache" / <x:ref>extension-pragma</x:ref>
  <x:ref>extension-pragma</x:ref>  = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
  When the no-cache directive is present in a request message, an application &SHOULD;
  forward the request toward the origin server even if it has a cached copy of what is being
  requested. This pragma directive has the same semantics as the no-cache response directive
  (see <xref target="cache-response-directive" />) and is defined here for backward
  compatibility with HTTP/1.0. Clients &SHOULD; include both header fields when a
  no-cache request is sent to a server not known to be HTTP/1.1 compliant. HTTP/1.1 caches
  &SHOULD; treat "Pragma: no-cache" as if the client had sent "Cache-Control: no-cache".
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> Because the meaning of "Pragma: no-cache" as a response-header field
    is not actually specified, it does not provide a reliable replacement for
    "Cache-Control: no-cache" in a response.
  </t>
</x:note>
<t>
  This mechanism is deprecated; no new Pragma directives will be defined in HTTP.
</t>
</section>

<section anchor="header.vary" title="Vary">
  <iref item="Vary header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Vary" x:for-anchor="" />
  <x:anchor-alias value="Vary"/>
  <x:anchor-alias value="Vary-v"/>
<t>
  The "Vary" response-header field conveys the set of request-header fields
  that were used to select the representation.
</t>
<t>
  Caches use this information, in part, to determine whether a stored response
  can be used to satisfy a given request; see
  <xref target="caching.negotiated.responses" />.
  determines, while the response is fresh, whether a cache is permitted to use the
  response to reply to a subsequent request without validation; see <xref 
  target="caching.negotiated.responses" />.
</t>
<t>
  In uncacheable or stale responses, the Vary field value advises the user agent about 
  the criteria that were used to select the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Vary"/><iref primary="true" item="Grammar" subitem="Vary-v"/>
  <x:ref>Vary</x:ref>   = "Vary" ":" <x:ref>OWS</x:ref> <x:ref>Vary-v</x:ref>
  <x:ref>Vary-v</x:ref> = "*" / 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
  The set of header fields named by the Vary field value is known as the selecting
  request-headers.
</t>
<t>
  Servers &SHOULD; include a Vary header field with any cacheable response that is
  subject to server-driven negotiation. Doing so allows a cache to properly interpret future
  requests on that resource and informs the user agent about the presence of negotiation on
  that resource. A server &MAY; include a Vary header field with a non-cacheable
  response that is subject to server-driven negotiation, since this might provide the user
  agent with useful information about the dimensions over which the response varies at the
  time of the response.
</t>
<t>
  A Vary field value of "*" signals that unspecified parameters not limited to the
  request-headers (e.g., the network address of the client), play a role in the selection of
  the response representation; therefore, a cache cannot determine whether this response is
  appropriate. The "*" value &MUST-NOT; be generated by a proxy server.
</t>
<t>
  The field-names given are not limited to the set of standard request-header fields
  defined by this specification. Field names are case-insensitive.
</t>
</section>

<section anchor="header.warning" title="Warning">
  <iref item="Warning header" primary="true" x:for-anchor="" />
  <iref item="Headers" primary="true" subitem="Warning" x:for-anchor="" />
  <x:anchor-alias value="Warning"/>
  <x:anchor-alias value="Warning-v"/>
  <x:anchor-alias value="warning-value"/>
  <x:anchor-alias value="warn-agent"/>
  <x:anchor-alias value="warn-code"/>
  <x:anchor-alias value="warn-date"/>
  <x:anchor-alias value="warn-text"/>
<t>
  The "Warning" general-header field is used to carry additional information about the status
  or transformation of a message that might not be reflected in the message. This
  information is typically used to warn about possible incorrectness introduced by caching
  operations or transformations applied to the payload of the message.
</t>
<t>
  Warnings can be used for other purposes, both cache-related and otherwise. The use of a
  warning, rather than an error status code, distinguishes these responses from true failures.
</t>
<t>
  Warning headers can in general be applied to any message, however some warn-codes are
  specific to caches and can only be applied to response messages.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Warning"/><iref primary="true" item="Grammar" subitem="Warning-v"/><iref primary="true" item="Grammar" subitem="warning-value"/><iref primary="true" item="Grammar" subitem="warn-code"/><iref primary="true" item="Grammar" subitem="warn-agent"/><iref primary="true" item="Grammar" subitem="warn-text"/><iref primary="true" item="Grammar" subitem="warn-date"/>
  <x:ref>Warning</x:ref>    = "Warning" ":" <x:ref>OWS</x:ref> <x:ref>Warning-v</x:ref>
  <x:ref>Warning-v</x:ref>  = 1#<x:ref>warning-value</x:ref>
  
  <x:ref>warning-value</x:ref> = <x:ref>warn-code</x:ref> <x:ref>SP</x:ref> <x:ref>warn-agent</x:ref> <x:ref>SP</x:ref> <x:ref>warn-text</x:ref>
                                        [<x:ref>SP</x:ref> <x:ref>warn-date</x:ref>]
  
  <x:ref>warn-code</x:ref>  = 3<x:ref>DIGIT</x:ref>
  <x:ref>warn-agent</x:ref> = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
                  ; the name or pseudonym of the server adding
                  ; the Warning header, for use in debugging
  <x:ref>warn-text</x:ref>  = <x:ref>quoted-string</x:ref>
  <x:ref>warn-date</x:ref>  = <x:ref>DQUOTE</x:ref> <x:ref>HTTP-date</x:ref> <x:ref>DQUOTE</x:ref>
</artwork></figure>
<t>
  Multiple warnings can be attached to a response (either by the origin server or by
  a cache), including multiple warnings with the same code number, only differing
  in warn-text.
</t>
<t>
  When this occurs, the user agent &SHOULD; inform the user of as many of them as
  possible, in the order that they appear in the response.
</t>
<t>
  Systems that generate multiple Warning headers &SHOULD; order them with this user
  agent behavior in mind. New Warning headers &SHOULD; be added after any existing
  Warning headers.
</t>
<t>
  Warnings are assigned three digit warn-codes. The first digit indicates whether the
  Warning is required to be deleted from a stored response after validation:
  <list style="symbols">
    <t>1xx Warnings describe the freshness or validation status of the response, and so
      &MUST; be deleted by caches after validation. They can only be generated by a cache
      when validating a cached entry, and &MUST-NOT; be generated in any other situation.</t>
    <t>2xx Warnings describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of the representation)
      and &MUST-NOT; be deleted by caches after validation, unless a full response is
      returned, in which case they &MUST; be.</t>
  </list>
</t>
<t>
  If an implementation sends a message with one or more Warning headers to a receiver whose
  version is HTTP/1.0 or lower, then the sender &MUST; include in each warning-value a
  warn-date that matches the Date header in the message.
</t>
<t>
  If an implementation receives a message with a warning-value that includes a warn-date,
  and that warn-date is different from the Date value in the response, then that
  warning-value &MUST; be deleted from the message before storing, forwarding, or using
  it. (preventing the consequences of naive caching of Warning header fields.) If all of the
  warning-values are deleted for this reason, the Warning header &MUST; be deleted as
  well.
</t>
<t>
  The following warn-codes are defined by this specification, each with a recommended
  warn-text in English, and a description of its meaning.
</t>
<t><?rfc needLines="4"?>
  110 Response is stale
  <list>
    <t>&SHOULD; be included whenever the returned response is stale.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  111 Revalidation failed
  <list>
    <t>&SHOULD; be included if a cache returns a stale response because an attempt to
      validate the response failed, due to an inability to reach the server.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  112 Disconnected operation
  <list>
    <t>&SHOULD; be included if the cache is intentionally disconnected from the rest of
      the network for a period of time.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  113 Heuristic expiration
  <list>
    <t>&SHOULD; be included if the cache heuristically chose a freshness lifetime
      greater than 24 hours and the response's age is greater than 24 hours.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  199 Miscellaneous warning
  <list>
    <t>The warning text can include arbitrary information to be presented to a human
      user, or logged. A system receiving this warning &MUST-NOT; take any automated
      action, besides presenting the warning to the user.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  214 Transformation applied
  <list>
    <t>&MUST; be added by an intermediate proxy if it applies any
      transformation to the representation, such as changing the content-coding,
      media-type, or modifying the representation data, unless this Warning code
      already appears in the response.</t>
  </list>
</t>
<t><?rfc needLines="4"?>
  299 Miscellaneous persistent warning
  <list>
    <t>The warning text can include arbitrary information to be presented to a human
      user, or logged. A system receiving this warning &MUST-NOT; take any automated
      action.</t>
  </list>
</t>
</section>

</section>

<section anchor="history.lists" title="History Lists">
<t>
  User agents often have history mechanisms, such as "Back" buttons and history lists, that
  can be used to redisplay a representation retrieved earlier in a session.
</t>
<t>
  The freshness model (<xref target="expiration.model"/>) does not necessarily apply to history mechanisms. I.e., 
  a history mechanism can display a previous representation even if it has expired.
</t>
  <t>
  This does not prohibit the history mechanism from telling the user that a
  view might be stale, or from honoring cache directives (e.g., Cache-Control: no-store).
  </t>
</section>


<section anchor="IANA.considerations" title="IANA Considerations">

<section title="Cache Directive Registry" anchor="cache.directive.registration">
<t>
  The registration procedure for HTTP Cache Directives is defined by 
  <xref target="cache.control.extensions"/> of this document.
</t>
<t>
   The HTTP Cache Directive Registry should be created at <eref target="http://www.iana.org/assignments/http-cache-directives"/>
   and be populated with the registrations below:
</t>
<?BEGININC p6-cache.cache-directives ?>
<!--AUTOGENERATED FROM extract-cache-directives-defs.xslt, do not edit manually-->
<texttable xmlns:my="#my" align="left" suppress-title="true"
           anchor="iana.cache.directive.registration.table">
   <ttcol>Cache Directive</ttcol>
   <ttcol>Reference</ttcol>

   <c>max-age</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>max-stale</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>min-fresh</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>must-revalidate</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>no-cache</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>no-store</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>no-transform</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>only-if-cached</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>private</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>proxy-revalidate</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>public</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>s-maxage</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>stale-if-error</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="4"/>
   </c>
   <c>stale-while-revalidate</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="3"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.cache-directives ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
  The Message Header Field Registry located at <eref
  target="http://www.iana.org/assignments/message-headers/message-header-index.html" />
  should be updated with the permanent registrations below (see <xref target="RFC3864" />):
</t>
<?BEGININC p6-cache.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Age</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.age"/>
   </c>
   <c>Cache-Control</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.cache-control"/>
   </c>
   <c>Expires</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expires"/>
   </c>
   <c>Pragma</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.pragma"/>
   </c>
   <c>Vary</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.vary"/>
   </c>
   <c>Warning</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.warning"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.iana-headers ?>
<t>
  The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

</section>

<section anchor="security.considerations" title="Security Considerations">
<t>
  Caches expose additional potential vulnerabilities, since the contents of the cache
  represent an attractive target for malicious exploitation. Because cache contents persist
  after an HTTP request is complete, an attack on the cache can reveal information long after
  a user believes that the information has been removed from the network. Therefore, cache
  contents should be protected as sensitive information.
</t>
</section>

<section anchor="ack" title="Acknowledgments">
<t>
  Much of the content and presentation of the caching design is due to suggestions and
  comments from individuals including: Shel Kaphan, Paul Leach, Koen Holtman, David Morris,
  and Larry Masinter.
</t>
</section>

</middle>

<back>
<references title="Normative References">

  <reference anchor="Part1">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Day Software">Day Software</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;" />
    <x:source basename="p1-messaging" href="p1-messaging.xml" />
  </reference>

  <reference anchor="Part2">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Day Software">Day Software</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;" />
    <x:source basename="p2-semantics" href="p2-semantics.xml" />
  </reference>

  <reference anchor="Part4">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 4: Conditional Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Day Software">Day Software</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;" />
    <x:source basename="p4-conditional" href="p4-conditional.xml" />
  </reference>

  <reference anchor="Part5">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Day Software">Day Software</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;" />
    <x:source basename="p5-range" href="p5-range.xml" />
  </reference>

  <reference anchor="Part7">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 7: Authentication</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Day Software">Day Software</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-&ID-VERSION;" />
    <x:source basename="p7-auth" href="p7-auth.xml" />
  </reference>

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author fullname="Scott Bradner" initials="S." surname="Bradner">
        <organization>Harvard University</organization>
        <address><email>sob@harvard.edu</email></address>
      </author>
      <date month="March" year="1997" />
    </front>
    <seriesInfo name="BCP" value="14" />
    <seriesInfo name="RFC" value="2119" />
  </reference>

  <reference anchor="RFC5234">
    <front>
      <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
      <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
        <organization>Brandenburg InternetWorking</organization>
        <address>
          <email>dcrocker@bbiw.net</email>
        </address>  
      </author>
      <author initials="P." surname="Overell" fullname="Paul Overell">
        <organization>THUS plc.</organization>
        <address>
          <email>paul.overell@thus.net</email>
        </address>
      </author>
      <date month="January" year="2008"/>
    </front>
    <seriesInfo name="STD" value="68"/>
    <seriesInfo name="RFC" value="5234"/>
  </reference>
  
</references>

<references title="Informative References">

  <reference anchor="RFC1305">
    <front>
      <title>Network Time Protocol (Version 3) Specification, Implementation</title>
      <author fullname="David L. Mills" initials="D." surname="Mills">
        <organization>University of Delaware, Electrical Engineering Department</organization>
        <address><email>mills@udel.edu</email></address>
      </author>
      <date month="March" year="1992" />
    </front>
    <seriesInfo name="RFC" value="1305" />
  </reference>

  <reference anchor="RFC2616">
    <front>
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
      <author fullname="R. Fielding" initials="R." surname="Fielding">
        <organization>University of California, Irvine</organization>
        <address><email>fielding@ics.uci.edu</email></address>
      </author>
      <author fullname="J. Gettys" initials="J." surname="Gettys">
        <organization>W3C</organization>
        <address><email>jg@w3.org</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>Compaq Computer Corporation</organization>
        <address><email>mogul@wrl.dec.com</email></address>
      </author>
      <author fullname="H. Frystyk" initials="H." surname="Frystyk">
        <organization>MIT Laboratory for Computer Science</organization>
        <address><email>frystyk@w3.org</email></address>
      </author>
      <author fullname="L. Masinter" initials="L." surname="Masinter">
        <organization>Xerox Corporation</organization>
        <address><email>masinter@parc.xerox.com</email></address>
      </author>
      <author fullname="P. Leach" initials="P." surname="Leach">
        <organization>Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee">
        <organization>W3C</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <date month="June" year="1999" />
    </front>
    <seriesInfo name="RFC" value="2616" />
  </reference>

  <reference anchor="RFC3864">
    <front>
      <title>Registration Procedures for Message Header Fields</title>
      <author fullname="G. Klyne" initials="G." surname="Klyne">
        <organization>Nine by Nine</organization>
        <address><email>GK-IETF@ninebynine.org</email></address>
      </author>
      <author fullname="M. Nottingham" initials="M." surname="Nottingham">
        <organization>BEA Systems</organization>
        <address><email>mnot@pobox.com</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>HP Labs</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <date month="September" year="2004" />
    </front>
    <seriesInfo name="BCP" value="90" />
    <seriesInfo name="RFC" value="3864" />
  </reference>

  <reference anchor='RFC5226'>
    <front>
      <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
      <author initials='T.' surname='Narten' fullname='T. Narten'>
        <organization>IBM</organization>
        <address><email>narten@us.ibm.com</email></address>
      </author>
      <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
        <organization>Google</organization>
        <address><email>Harald@Alvestrand.no</email></address>
      </author>
      <date year='2008' month='May' />
    </front>
    <seriesInfo name='BCP' value='26' />
    <seriesInfo name='RFC' value='5226' />
  </reference>

  <reference anchor='RFC5861'>
    <front>
      <title abbrev="HTTP stale controls">HTTP Cache-Control Extensions for Stale Content</title>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization>Yahoo! Inc.</organization>
        <address><email>mnot@yahoo-inc.com</email></address>
      </author>
      <date month="April" year="2010"/>
    </front>
    <seriesInfo name='RFC' value='5861' />
  </reference>

</references>

<section anchor="changes.from.rfc.2616" title="Changes from RFC 2616">
<t>
  Make the specified age calculation algorithm less conservative.
  (<xref target="age.calculations"/>)
</t>
<t>
  Remove requirement to consider Content-Location in successful responses
  in order to determine the appropriate response to use.
  (<xref target="validation.model" />)
</t>
<t>
  Clarify denial of service attack avoidance requirement.
  (<xref target="invalidation.after.updates.or.deletions" />)
</t>
<t>
  Do not mention RFC 2047 encoding and multiple languages in Warning headers
  anymore, as these aspects never were implemented. 
  (<xref target="header.warning" />)
</t>
</section>

<?BEGININC p6-cache.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p6-cache.parsed-abnf">
<x:ref>Age</x:ref> = "Age:" OWS Age-v
<x:ref>Age-v</x:ref> = delta-seconds

<x:ref>Cache-Control</x:ref> = "Cache-Control:" OWS Cache-Control-v
<x:ref>Cache-Control-v</x:ref> = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

<x:ref>Expires</x:ref> = "Expires:" OWS Expires-v
<x:ref>Expires-v</x:ref> = HTTP-date

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part1], Section 6.1&gt;

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>Pragma</x:ref> = "Pragma:" OWS Pragma-v
<x:ref>Pragma-v</x:ref> = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

<x:ref>Vary</x:ref> = "Vary:" OWS Vary-v
<x:ref>Vary-v</x:ref> = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name
 ] ) )

<x:ref>Warning</x:ref> = "Warning:" OWS Warning-v
<x:ref>Warning-v</x:ref> = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value
 ] )

<x:ref>cache-directive</x:ref> = cache-request-directive / cache-response-directive
<x:ref>cache-extension</x:ref> = token [ "=" ( token / quoted-string ) ]
<x:ref>cache-request-directive</x:ref> = "no-cache" / "no-store" / ( "max-age="
 delta-seconds ) / ( "max-stale" [ "=" delta-seconds ] ) / (
 "min-fresh=" delta-seconds ) / "no-transform" / "only-if-cached" /
 cache-extension
<x:ref>cache-response-directive</x:ref> = "public" / ( "private" [ "=" DQUOTE *( ","
 OWS ) field-name *( OWS "," [ OWS field-name ] ) DQUOTE ] ) / (
 "no-cache" [ "=" DQUOTE *( "," OWS ) field-name *( OWS "," [ OWS
 field-name ] ) DQUOTE ] ) / "no-store" / "no-transform" /
 "must-revalidate" / "proxy-revalidate" / ( "max-age=" delta-seconds
 ) / ( "s-maxage=" delta-seconds ) / cache-extension

<x:ref>delta-seconds</x:ref> = 1*DIGIT

<x:ref>extension-pragma</x:ref> = token [ "=" ( token / quoted-string ) ]

<x:ref>field-name</x:ref> = &lt;field-name, defined in [Part1], Section 3.2&gt;

<x:ref>port</x:ref> = &lt;port, defined in [Part1], Section 2.6&gt;
<x:ref>pragma-directive</x:ref> = "no-cache" / extension-pragma
<x:ref>pseudonym</x:ref> = &lt;pseudonym, defined in [Part1], Section 9.9&gt;

<x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in [Part1], Section 1.2.2&gt;

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 1.2.2&gt;

<x:ref>uri-host</x:ref> = &lt;uri-host, defined in [Part1], Section 2.6&gt;

<x:ref>warn-agent</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>warn-code</x:ref> = 3DIGIT
<x:ref>warn-date</x:ref> = DQUOTE HTTP-date DQUOTE
<x:ref>warn-text</x:ref> = quoted-string
<x:ref>warning-value</x:ref> = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; Age defined but not used
; Cache-Control defined but not used
; Expires defined but not used
; Pragma defined but not used
; Vary defined but not used
; Warning defined but not used
</artwork></figure></section>
<?ENDINC p6-cache.abnf-appendix ?>

<section anchor="change.log" title="Change Log (to be removed by RFC Editor before publication)">

<section title="Since RFC2616">
  <t>Extracted relevant partitions from <xref target="RFC2616" />.</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-00">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/9" />: "Trailer" (<eref target="http://purl.org/NET/http-errata#trailer-hop" />)</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/12" />: "Invalidation after Update or Delete" (<eref target="http://purl.org/NET/http-errata#invalidupd" />)</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35" />: "Normative and Informative references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/48" />: "Date reference typo"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/49" />: "Connection header text"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/65" />: "Informative references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/66" />: "ISO-8859-1 Reference"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86" />: "Normative up-to-date references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/87" />: "typo in 13.2.2"</t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols">
    <t>Use names of RFC4234 core rules DQUOTE and HTAB (work in progress on <eref
        target="http://tools.ietf.org/wg/httpbis/trac/ticket/36" />)</t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-01">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/82" />: "rel_path not used"</t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols">
    <t>Get rid of duplicate BNF rule names ("host" -&gt; "uri-host") (work in progress
      on <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36" />)</t>
    <t>Add explicit references to BNF syntax and rules imported from other parts of the
      specification.</t>
  </list>
</t>
</section>

<section anchor="changes.since.02" title="Since draft-ietf-httpbis-p6-cache-02">
<t>
  Ongoing work on IANA Message Header Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40" />):
  <list style="symbols">
    <t>Reference RFC 3984, and update header registrations for headers defined in this
      document.</t>
  </list>
</t>
</section>

<section anchor="changes.since.03" title="Since draft-ietf-httpbis-p6-cache-03">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/106" />: "Vary header classification"</t>
  </list>
</t>
</section>

<section anchor="changes.since.04" title="Since draft-ietf-httpbis-p6-cache-04">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header value format definitions.
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.05" title="Since draft-ietf-httpbis-p6-cache-05">
<t>
  This is a total rewrite of this part of the specification.
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/54" />: "Definition of 1xx Warn-Codes"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60" />: "Placement of 13.5.1 and 13.5.2"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/138" />: "The role of Warning and Semantic Transparency in Caching"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/139" />: "Methods and Caching"</t>
  </list>
</t>
<t>
  In addition: Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.06" title="Since draft-ietf-httpbis-p6-cache-06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/161"/>:
      "base for numeric protocol elements"
    </t>
  </list>
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/37"/>: 
      Vary and non-existant headers
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.07" title="Since draft-ietf-httpbis-p6-cache-07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/54" />:
      "Definition of 1xx Warn-Codes"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/167"/>:
      "Content-Location on 304 responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/169" />:
      "private and no-cache CC directives with headers"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/187"/>:
      "RFC2047 and warn-text"
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.08" title="Since draft-ietf-httpbis-p6-cache-08">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/147" />:
      "serving negotiated responses from cache: header-specific canonicalization"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/197" />:
      "Effect of CC directives on history lists"
    </t>
  </list>
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/199"/>: 
      Status codes and caching
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60"/>:
      "Placement of 13.5.1 and 13.5.2"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-09" anchor="changes.since.09">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/29" />:
      "Age calculation"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/168" />:
      "Clarify differences between / requirements for request and response CC directives"
    </t>
	<t>
		<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/174" />:
		"Caching authenticated responses"
	</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/208" />:
      "IANA registry for cache-control directives"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/211" />:
      "Heuristic caching of URLs with query components"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/196"/>:
      "Term for the requested resource's URI"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/223"/>:
      "Allowing heuristic caching for new status codes"
    </t>
  </list>
</t>
</section>

</section>
  </back>
</rfc>
