<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "December">
  <!ENTITY ID-YEAR "2011">
  <!ENTITY architecture               "<xref target='Part1' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                    "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                        "<xref target='Part1' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules                 "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-rules                 "<xref target='Part1' x:rel='#field.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                         "<xref target='Part1' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri       "<xref target='Part1' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                   "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY semantics                   "<xref target='Part2' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY conditional                 "<xref target='Part4' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY partial                     "<xref target='Part5' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY combining-byte-ranges       "<xref target='Part5' x:rel='#combining.byte.ranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                   "<xref target='Part2' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-authorization        "<xref target='Part7' x:rel='#header.authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-connection           "<xref target='Part1' x:rel='#header.connection' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                 "<xref target='Part2' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-via                  "<xref target='Part1' x:rel='#header.via' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified        "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-fields               "<xref target='Part1' x:rel='#header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods                "<xref target='Part2' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-tags                 "<xref target='Part4' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY weak-and-strong             "<xref target='Part4' x:rel='#weak.and.strong.validators' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY lastmod-comparison          "<xref target='Part4' x:rel='#lastmod.comparison' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes                "<xref target='Part2' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status.2xx                  "<xref target='Part2' x:rel='#status.2xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc category="std" docName="draft-ietf-httpbis-p6-cache-&ID-VERSION;" ipr="pre5378Trust200902"
  obsoletes="2616" x:maturity-level="proposed" xmlns:x="http://purl.org/net/xml2rfc/ext">
<x:link rel="prev" basename="p5-range"/>
<x:link rel="next" basename="p7-auth"/>
<front>

  <title abbrev="HTTP/1.1, Part 6">HTTP/1.1, part 6: Caching</title>

  <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@freedesktop.org</email>
      <uri>http://gettys.wordpress.com/</uri>
    </address>
  </author>

  <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author fullname="Larry Masinter" initials="L." surname="Masinter">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>

  <author fullname="Paul J. Leach" initials="P." surname="Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>

  <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
    <organization>Rackspace</organization>
    <address>
      <email>mnot@mnot.net</email>
      <uri>http://www.mnot.net/</uri>
    </address>
  </author>

  <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>
      <facsimile>+49 251 2807761</facsimile>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;" />
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. HTTP has been in
   use by the World Wide Web global information initiative since 1990. This
   document is Part 6 of the seven-part specification that defines the protocol
   referred to as "HTTP/1.1" and, taken together, obsoletes RFC 2616.
</t>
<t>
   Part 6 defines requirements on HTTP caches and the associated header fields
   that control cache behavior or indicate cacheable response messages.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.17"/>.
  </t>
</note>

   </front>
   <middle>

<section anchor="caching" title="Introduction">
<t>
   HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. This document
   defines aspects of HTTP/1.1 related to caching and reusing response
   messages.
</t>

<section anchor="intro.purpose" title="Purpose">
<iref item="cache" />
<t>
   An HTTP <x:dfn>cache</x:dfn> is a local store of response messages and the
   subsystem that controls its message storage, retrieval, and deletion. A
   cache stores cacheable responses in order to reduce the response time and
   network bandwidth consumption on future, equivalent requests. Any client or
   server &MAY; employ a cache, though a cache cannot be used by a server that
   is acting as a tunnel.
</t>
<t>
   The goal of caching in HTTP/1.1 is to significantly improve performance
   by reusing a prior response message to satisfy a current request.
   A stored response is considered "fresh", as defined in
   <xref target="expiration.model" />, if the response can be reused without
   "validation" (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh cache response can therefore
   reduce both latency and network transfers each time it is reused.
   When a cached response is not fresh, it might still be reusable if it can
   be freshened by validation (<xref target="validation.model" />) or if the
   origin is unavailable.
</t>
</section>

<section anchor="intro.terminology" title="Terminology">
<t>
   This specification uses a number of terms to refer to the roles played by
   participants in, and objects of, HTTP caching.
</t>
<t>
   <iref item="cache" />
   <x:dfn>cache</x:dfn>
   <list>
      <t>A conformant implementation of a HTTP cache. Note that this implies
        an HTTP/1.1 cache; this specification does not define conformance
        for HTTP/1.0 caches.</t>
   </list>
</t>
<t anchor="shared.and.non-shared.caches">
   <iref item="shared cache" />
   <x:dfn>shared cache</x:dfn>
   <list>
      <t>A cache that stores responses to be reused by more than one user;
         usually (but not always) deployed as part of an intermediary.</t>
   </list>
</t>
<t>
   <iref item="private cache" />
   <x:dfn>private cache</x:dfn>
   <list>
      <t>A cache that is dedicated to a single user.</t>
   </list>
</t>
<t>
   <iref item="cacheable" />
   <x:dfn>cacheable</x:dfn>
   <list>
      <t>A response is cacheable if a cache is allowed to store a copy of the
      response message for use in answering subsequent requests. Even when a
      response is cacheable, there might be additional constraints on whether
      a cache can use the stored copy to satisfy a particular request.</t>
   </list>
</t>
<t>
   <iref item="explicit expiration time" />
   <x:dfn>explicit expiration time</x:dfn>
   <list>
      <t>The time at which the origin server intends that a representation
      no longer be returned by a cache without further validation.</t>
   </list>
</t>
<t>
   <iref item="heuristic expiration time" />
   <x:dfn>heuristic expiration time</x:dfn>
   <list>
      <t>An expiration time assigned by a cache when no explicit expiration
      time is available.</t>
   </list>
</t>
<t>
   <iref item="age" />
   <x:dfn>age</x:dfn>
   <list>
      <t>The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.</t>
   </list>
</t>
<t>
   <iref item="first-hand" />
   <x:dfn>first-hand</x:dfn>
   <list>
      <t>A response is first-hand if the freshness model is not in use; i.e.,
      its age is 0.</t>
   </list>
</t>
<t>
   <iref item="freshness lifetime" />
   <x:dfn>freshness lifetime</x:dfn>
   <list>
      <t>The length of time between the generation of a response and its
      expiration time.</t>
   </list>
</t>
<t>
   <iref item="fresh" />
   <x:dfn>fresh</x:dfn>
   <list>
      <t>A response is fresh if its age has not yet exceeded its freshness
      lifetime.</t>
   </list>
</t>
<t>
   <iref item="stale" />
   <x:dfn>stale</x:dfn>
   <list>
      <t>A response is stale if its age has passed its freshness lifetime
      (either explicit or heuristic).</t>
   </list>
</t>
<t>
   <iref item="validator" />
   <x:dfn>validator</x:dfn>
   <list>
      <t>A protocol element (e.g., an entity-tag or a Last-Modified time) that
      is used to find out whether a stored response is an equivalent copy of
      a representation. See &weak-and-strong;.</t>
   </list>
</t>
<t>
   <iref item="strong validator" />
   <iref item="validator" subitem="strong" />
   <x:dfn>strong validator</x:dfn>
   <list>
      <t>A validator that is defined by the origin server such that its
         current value will change if the representation body changes; i.e.,
         an entity-tag that is not marked as weak (&entity-tags;) or,
         if no entity-tag is provided, a Last-Modified value that is strong
         in the sense defined by &lastmod-comparison;.</t>
   </list>
</t>
</section>

<section title="Conformance and Error Handling" anchor="intro.conformance.and.error.handling">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   This document defines conformance criteria for several roles in HTTP
   communication, including Senders, Recipients, Clients, Servers, User-Agents,
   Origin Servers, Intermediaries, Proxies and Gateways. See &architecture;
   for definitions of these terms.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with its role(s). Note that SHOULD-level requirements
   are relevant here, unless one of the documented exceptions is applicable.
</t>
<t>
   This document also uses ABNF to define valid protocol elements
   (<xref target="notation"/>). In addition to the prose requirements placed
   upon them, Senders &MUST-NOT; generate protocol elements that are invalid.
</t>
<t>
   Unless noted otherwise, Recipients &MAY; take steps to recover a usable
   protocol element from an invalid construct. However, HTTP does not define
   specific error handling mechanisms, except in cases where it has direct
   impact on security. This is because different uses of the protocol require
   different error handling strategies; for example, a Web browser may wish to
   transparently recover from a response where the Location header field
   doesn't parse according to the ABNF, whereby in a systems control protocol
   using HTTP, this type of error recovery could lead to dangerous consequences.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
   <x:anchor-alias value="ALPHA"/>
   <x:anchor-alias value="CR"/>
   <x:anchor-alias value="DIGIT"/>
   <x:anchor-alias value="DQUOTE"/>
   <x:anchor-alias value="LF"/>
   <x:anchor-alias value="OCTET"/>
   <x:anchor-alias value="SP"/>
   <x:anchor-alias value="VCHAR"/>
<t>
   This specification uses the ABNF syntax defined in &notation; (which
   extends the syntax defined in <xref target="RFC5234"/> with a list rule).
   <xref target="collected.abnf"/> shows the collected ABNF, with the list
   rule expanded.
</t>
<t>
   The following core rules are included by reference, as defined in <xref
   target="RFC5234" x:fmt="," x:sec="B.1"/>: ALPHA (letters), CR (carriage
   return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit
   sequence of data), SP (space), and VCHAR (any visible US-ASCII character).
</t>

<section title="Core Rules" anchor="core.rules">
   <x:anchor-alias value="quoted-string"/>
   <x:anchor-alias value="token"/>
   <x:anchor-alias value="OWS"/>
<t>
   The core rules below are defined in <xref target="Part1"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &basic-rules;&gt;
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in &field-rules;&gt;
  <x:ref>token</x:ref>         = &lt;token, defined in &field-rules;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification"
    anchor="abnf.dependencies">
   <x:anchor-alias value="field-name"/>
   <x:anchor-alias value="HTTP-date"/>
   <x:anchor-alias value="port"/>
   <x:anchor-alias value="pseudonym"/>
   <x:anchor-alias value="uri-host"/>
<t>
   The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part1--><artwork type="abnf2616">
  <x:ref>field-name</x:ref>    = &lt;field-name, defined in &header-fields;&gt;
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &http-date;&gt;
  <x:ref>port</x:ref>          = &lt;port, defined in &uri;&gt;
  <x:ref>pseudonym</x:ref>     = &lt;pseudonym, defined in &header-via;&gt; 
  <x:ref>uri-host</x:ref>      = &lt;uri-host, defined in &uri;&gt;
</artwork></figure>
</section>
</section>

<section title="Delta Seconds" anchor="delta-seconds">
<t>
   The delta-seconds rule specifies a non-negative integer, representing time
   in seconds.
</t>
<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" subitem="delta-seconds" />
  <x:ref>delta-seconds</x:ref>  = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   If an implementation receives a delta-seconds value larger than the largest
   positive integer it can represent, or if any of its subsequent calculations
   overflows, it &MUST; consider the value to be 2147483648 (2<x:sup>31</x:sup>).
   Recipients parsing a delta-seconds value &MUST; use an arithmetic type of
   at least 31 bits of range, and senders &MUST-NOT; send delta-seconds with a
   value greater than 2147483648.
</t>
</section>

</section>

<section anchor="caching.overview" title="Cache Operation">
<iref item="cache entry" />
<iref item="cache key" />
<t>
   Proper cache operation preserves the semantics of HTTP transfers
   (&semantics;) while eliminating the transfer of information already held
   in the cache.  Although caching is an entirely &OPTIONAL; feature of HTTP,
   we assume that reusing the cached response is desirable and that such
   reuse is the default behavior when no requirement or locally-desired
   configuration prevents it.  Therefore, HTTP cache requirements are focused
   on preventing a cache from either storing a non-reusable response or
   reusing a stored response inappropriately.
</t>
<t>
   Each <x:dfn>cache entry</x:dfn> consists of a cache key and one or more
   HTTP responses corresponding to prior requests that used the same key.
   The most common form of cache entry is a successful result of a retrieval
   request: i.e., a 200 (OK) response containing a representation of the
   resource identified by the request target.  However, it is also possible
   to cache negative results (e.g., 404 not found), incomplete results
   (e.g., 206 partial content), and responses to safe methods other than
   GET if the method's definition allows such caching and defines something
   suitable for use as a cache key.
</t>
<t>
   The default <x:dfn>cache key</x:dfn> consists of the request method and
   target URI.  However, since HTTP caches in common use today are typically
   limited to caching responses to GET, most implementations simply decline
   other methods and use only the URI as the key.
</t>
<t>
   If a request target is subject to content negotiation, its cache entry
   might consist of multiple stored responses, each differentiated by a
   secondary key for the values of the original request's selecting header
   fields (<xref target="caching.negotiated.responses"/>).
</t>

<section anchor="response.cacheability" title="Response Cacheability">
<t>
   A cache &MUST-NOT; store a response to any request, unless:
   <list style="symbols">
      <t>The request method is understood by the cache and defined as being
      cacheable, and</t>
      <t>the response status code is understood by the cache, and</t>
      <t>the "no-store" cache directive (see <xref
      target="header.cache-control" />) does not appear in request or response
      header fields, and</t>
      <t>the "private" cache response directive (see <xref
      target="cache-response-directive" /> does not appear in the response, if
      the cache is shared, and</t>
      <t>the "Authorization" header field (see &header-authorization;) does not
      appear in the request, if the cache is shared, unless the response
      explicitly allows it (see <xref target="caching.authenticated.responses"
      />), and</t>
      <t>the response either:
         <list style="symbols">
            <t>contains an Expires header field (see <xref target="header.expires"
            />), or</t>
            <t>contains a max-age response cache directive (see <xref
            target="cache-response-directive" />), or</t>
            <t>contains a s-maxage response cache directive and the cache is
            shared, or</t>
            <t>contains a Cache Control Extension (see <xref
            target="cache.control.extensions" />) that allows it to be cached,
            or</t>
            <t>has a status code that can be served with heuristic freshness
            (see <xref target="heuristic.freshness" />).</t>
         </list>
      </t>
   </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions" />.
</t>
<t>
   In this context, a cache has "understood" a request method or a response
   status code if it recognizes it and implements any cache-specific
   behavior.
</t>
<t>
   Note that, in normal operation, most caches will not store a response that
   has neither a cache validator nor an explicit expiration time, as such
   responses are not usually useful to store. However, caches are not
   prohibited from storing such responses.
</t>
<t>
   A response message is considered complete when all of the octets
   indicated by the message framing (&messaging;) are received
   prior to the connection being closed.
   If the request is GET, the response status is 200 (OK), and the entire
   response header block has been received, a cache &MAY; store an incomplete
   response message-body if the cache entry is recorded as incomplete.
   Likewise, a 206 (Partial Content) response &MAY; be stored as if it were
   an incomplete 200 (OK) cache entry.  However, a cache &MUST-NOT; store
   incomplete or partial content responses if it does not support the Range
   and Content-Range header fields or if it does not understand the
   range units used in those fields.
</t>
<t>
   A cache &MAY; complete a stored incomplete response by making a subsequent
   range request (&partial;) and combining the successful response with the
   stored entry, as defined in <xref target="combining.responses"/>.
   A cache &MUST-NOT; use an incomplete response to answer requests
   unless the response has been made complete or the request is partial and
   specifies a range that is wholly within the incomplete response.
   A cache &MUST-NOT; send a partial response to a client without explicitly
   marking it as such using the 206 (Partial Content) status code.
</t>
</section>


<section anchor="constructing.responses.from.caches" 
   title="Constructing Responses from Caches">
<t>
   For a presented request, a cache &MUST-NOT; return a stored response,
   unless:
   <list style="symbols">
      <t>The presented effective request URI (&effective-request-uri;) and
      that of the stored response match, and</t>
      <t>the request method associated with the stored response allows it to
      be used for the presented request, and</t>
      <t>selecting header fields nominated by the stored response (if any)
      match those presented (see <xref target="caching.negotiated.responses"
      />), and</t>
      <t>the presented request and stored response are free from directives
      that would prevent its use (see <xref target="header.cache-control" />
      and <xref target="header.pragma"/>), and</t>
      <t>the stored response is either:
         <list style="symbols">
            <t>fresh (see <xref target="expiration.model" />), or</t>
            <t>allowed to be served stale (see <xref
            target="serving.stale.responses" />), or</t>
            <t>successfully validated (see <xref target="validation.model"
            />).</t>
         </list>
      </t>
  </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions" />.
</t>
<t>
   When a stored response is used to satisfy a request without validation,
   a cache &MUST; include a single Age header field (<xref target="header.age"
   />) in the response with a value equal to the stored response's
   current_age; see <xref target="age.calculations" />.
</t>
<t>
   A cache &MUST; write through requests with methods that are unsafe 
   (&safe-methods;) to the origin server; i.e., a cache must not generate 
   a reply to such a request before having forwarded the request and having 
   received a corresponding response.
</t>
<t>
   Also, note that unsafe requests might invalidate already stored responses;
   see <xref target="invalidation.after.updates.or.deletions" />.
</t>
<t>
   When more than one suitable response is stored, a cache &MUST; use the 
   most recent response (as determined by the Date header field). It can also
   forward a request with "Cache-Control: max-age=0" or "Cache-Control:
   no-cache" to disambiguate which response to use.
</t>
<t>
   A cache that does not have a clock available &MUST-NOT; use stored responses
   without revalidating them on every use. A cache, especially a shared
   cache, &SHOULD; use a mechanism, such as NTP <xref target="RFC1305"/>, to
   synchronize its clock with a reliable external standard.
</t>

</section>

<section anchor="expiration.model" title="Freshness Model">
<t>
   When a response is "fresh" in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby improving
   efficiency.
</t>
<t>
   The primary mechanism for determining freshness is for an origin server to
   provide an explicit expiration time in the future, using either the Expires
   header field (<xref target="header.expires" />) or the max-age response cache
   directive (<xref target="cache-response-directive" />). Generally, origin
   servers will assign future explicit expiration times to responses in the
   belief that the representation is not likely to change in a semantically
   significant way before the expiration time is reached.
</t>
<t>
   If an origin server wishes to force a cache to validate every request, it
   can assign an explicit expiration time in the past to indicate that the
   response is already stale. Compliant caches will normally validate the 
   cached response before reusing it for subsequent requests (see <xref
   target="serving.stale.responses" />).
</t>
<t>
   Since origin servers do not always provide explicit expiration times, 
   a cache &MAY; assign a heuristic expiration time when an explicit time is not
   specified, employing algorithms that use other header field values (such as the
   Last-Modified time) to estimate a plausible expiration time. This
   specification does not provide specific algorithms, but does impose
   worst-case constraints on their results.
</t>
<figure>
<preamble>
  The calculation to determine if a response is fresh is:
</preamble>
<artwork type="code">
   response_is_fresh = (freshness_lifetime &gt; current_age)
</artwork>
</figure>
<t>
   The freshness_lifetime is defined in <xref
   target="calculating.freshness.lifetime" />; the current_age is defined in
   <xref target="age.calculations" />.
</t>
<t>
   Additionally, clients might need to influence freshness calculation. They
   can do this using several request cache directives, with the effect of
   either increasing or loosening constraints on freshness. See <xref
   target="cache-request-directive" />.
</t>
<t>
   Note that freshness applies only to cache operation; it cannot be used to
   force a user agent to refresh its display or reload a resource. See <xref
   target="history.lists" /> for an explanation of the difference between
   caches and history mechanisms.
</t>

<section anchor="calculating.freshness.lifetime" 
   title="Calculating Freshness Lifetime">
<t>
   A cache can calculate the freshness lifetime (denoted as
   freshness_lifetime) of a response by using the first match of:
   <list style="symbols">
      <t>If the cache is shared and the s-maxage response cache directive
      (<xref target="cache-response-directive" />) is present, use its value,
      or</t>
      <t>If the max-age response cache directive (<xref
      target="cache-response-directive" />) is present, use its value, or</t>
      <t>If the Expires response header field (<xref target="header.expires" />) is
      present, use its value minus the value of the Date response header field,
      or</t>
      <t>Otherwise, no explicit expiration time is present in the response. A
      heuristic freshness lifetime might be applicable; see <xref
      target="heuristic.freshness" />.</t>
   </list>
</t>
<t>
   Note that this calculation is not vulnerable to clock skew, since all of
   the information comes from the origin server.
</t>

<section anchor="heuristic.freshness" title="Calculating Heuristic Freshness">
<t>
   If no explicit expiration time is present in a stored response that has a
   status code whose definition allows heuristic freshness to be used
   (including the following in &status-codes;: 200, 203, 206, 300, 301 and
   410), a cache &MAY; calculate a heuristic expiration time. A cache &MUST-NOT; 
   use heuristics to determine freshness for responses with status codes that do 
   not explicitly allow it.
</t>
<t>
   When a heuristic is used to calculate freshness lifetime, a cache
   &SHOULD; attach a Warning header field with a 113 warn-code to the response if
   its current_age is more than 24 hours and such a warning is not already
   present.
</t>
<t>
   Also, if the response has a Last-Modified header field
   (&header-last-modified;), caches are encouraged to use a heuristic
   expiration value that is no more than some fraction of the interval since
   that time. A typical setting of this fraction might be 10%.
</t>
<x:note>
   <t>
      <x:h>Note:</x:h> RFC 2616 (<xref target="RFC2616" x:fmt=","
      x:sec="13.9"/>) required that caches do not calculate heuristic
      freshness for URIs with query components (i.e., those containing '?').
      In practice, this has not been widely implemented. Therefore, servers
      are encouraged to send explicit directives (e.g., Cache-Control:
      no-cache) if they wish to preclude caching.
   </t>
</x:note>
</section>
</section>

<section anchor="age.calculations" title="Calculating Age">
<t>
   HTTP/1.1 uses the Age header field to convey the estimated age of the
   response message when obtained from a cache. The Age field value is the
   cache's estimate of the amount of time since the response was generated or
   validated by the origin server. In essence, the Age value is the sum of the
   time that the response has been resident in each of the caches along the
   path from the origin server, plus the amount of time it has been in transit
   along network paths.
</t>
<t>
   The following data is used for the age calculation:
</t>
<t>
   <x:dfn>age_value</x:dfn>
   <list>
      <t>
         The term "age_value" denotes the value of the Age header field (<xref
         target="header.age"/>), in a form appropriate for arithmetic
         operation; or 0, if not available.
      </t>
   </list>
</t>
<t>
   <x:dfn>date_value</x:dfn>
   <list>
      <t>
         HTTP/1.1 requires origin servers to send a Date header field, if possible,
         with every response, giving the time at which the response was
         generated. The term "date_value" denotes the value of the Date
         header field, in a form appropriate for arithmetic operations. See
         &header-date; for the definition of the Date header field, and for
         requirements regarding responses without it.
      </t>
   </list>
</t>
<t>
   <x:dfn>now</x:dfn>
   <list>
      <t>
         The term "now" means "the current value of the clock at the host
         performing the calculation". A cache &SHOULD; use NTP (<xref
         target="RFC1305"/>) or some similar protocol to synchronize its
         clocks to a globally accurate time standard.
      </t>
   </list>
</t>
<t>
   <x:dfn>request_time</x:dfn>
   <list>
      <t>
         The current value of the clock at the host at the time the request
         resulting in the stored response was made.
      </t>
   </list>
</t>
<t>
   <x:dfn>response_time</x:dfn>
   <list>
      <t>
         The current value of the clock at the host at the time the response
         was received.
      </t>
   </list>
</t>
<t>
   A response's age can be calculated in two entirely independent ways:
   <list style="numbers">
      <t>the "apparent_age": response_time minus date_value, if the local
      clock is reasonably well synchronized to the origin server's clock. If
      the result is negative, the result is replaced by zero.</t>
      <t>the "corrected_age_value", if all of the caches along the response
      path implement HTTP/1.1. A cache &MUST; interpret this value relative
      to the time the request was initiated, not the time that the response
      was received.</t>
   </list>
</t>
<figure>
<artwork type="code">
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;  
</artwork>
</figure>
<figure>
<preamble>These are combined as</preamble>
<artwork type="code">
  corrected_initial_age = max(apparent_age, corrected_age_value);
</artwork></figure>
<t>
   The current_age of a stored response can then be calculated by adding the
   amount of time (in seconds) since the stored response was last validated by
   the origin server to the corrected_initial_age.
</t>
<figure><artwork type="code">
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
</artwork></figure>
<t>
   Additionally, to avoid common problems in date parsing:
</t>
<t>
  <list style="symbols">
     <t>HTTP/1.1 clients and caches &SHOULD; assume that an RFC-850 date
        which appears to be more than 50 years in the future is in fact
        in the past (this helps solve the "year 2000" problem).</t>

     <t>Although all date formats are specified to be case-sensitive, 
        recipients &SHOULD; match day, week and timezone names
        case-insensitively.</t>
             
     <t>An HTTP/1.1 implementation &MAY; internally represent a parsed
        Expires date as earlier than the proper value, but &MUST-NOT;
        internally represent a parsed Expires date as later than the
        proper value.</t>

     <t>All expiration-related calculations &MUST; be done in GMT. The
        local time zone &MUST-NOT; influence the calculation or comparison
        of an age or expiration time.</t>

     <t>If an HTTP header field incorrectly carries a date value with a time
        zone other than GMT, it &MUST; be converted into GMT using the
        most conservative possible conversion.</t>
  </list>
</t>
</section>

<section anchor="serving.stale.responses" title="Serving Stale Responses">
<t>
   A "stale" response is one that either has explicit expiry information or is
   allowed to have heuristic expiry calculated, but is not fresh according to
   the calculations in <xref target="expiration.model" />.
</t>
<t>
   A cache &MUST-NOT; return a stale response if it is prohibited by an
   explicit in-protocol directive (e.g., by a "no-store" or "no-cache" cache
   directive, a "must-revalidate" cache-response-directive, or an applicable
   "s-maxage" or "proxy-revalidate" cache-response-directive; see <xref
   target="cache-response-directive"/>).
</t>
<t>
   A cache &MUST-NOT; return stale responses unless it is disconnected
   (i.e., it cannot contact the origin server or otherwise find a forward
   path) or doing so is explicitly allowed (e.g., by the max-stale request
   directive; see <xref target="cache-request-directive" />).
</t>
<t>
   A cache &SHOULD; append a Warning header field with the 110 warn-code (see
   <xref target="header.warning" />) to stale responses. Likewise, a cache
   &SHOULD; add the 112 warn-code to stale responses if the cache is 
   disconnected.
</t>
<t>
   If a cache receives a first-hand response (either an entire response, or a
   304 (Not Modified) response) that it would normally forward to the
   requesting client, and the received response is no longer fresh, the cache
   can forward it to the requesting client without adding a new Warning (but
   without removing any existing Warning header fields). A cache shouldn't
   attempt to validate a response simply because that response became stale in
   transit.
</t>
</section>
</section>

<section anchor="validation.model" title="Validation Model">
<t>
   When a cache has one or more stored responses for a requested URI, but
   cannot serve any of them (e.g., because they are not fresh, or one cannot
   be selected; see <xref target="caching.negotiated.responses"/>), it can use
   the conditional request mechanism &conditional; in the forwarded request to
   give the origin server an opportunity to both select a valid stored
   response to be used, and to update it. This process is known as
   "validating" or "revalidating" the stored response.
</t>
<t>
   When sending such a conditional request, a cache adds an If-Modified-Since
   header field whose value is that of the Last-Modified header field from the
   selected (see <xref target="caching.negotiated.responses"/>) stored
   response, if available.
</t>
<t>
   Additionally, a cache can add an If-None-Match header field whose value is
   that of the ETag header field(s) from all responses stored for the
   requested URI, if present. However, if any of the stored responses contains
   only partial content, the cache shouldn't include its entity-tag in the
   If-None-Match header field unless the request is for a range that would be
   fully satisfied by that stored response.
</t>

<t>Cache handling of a response to a conditional request is dependent upon its status code:</t>

<t>
   <list style="symbols">
      <t>
         A 304 (Not Modified) response status code indicates that the stored
         response can be updated and reused; see <xref
         target="freshening.responses"/>.
      </t>
      <t>
         A full response (i.e., one with a response body) indicates that none
         of the stored responses nominated in the conditional request is
         suitable. Instead, the cache can use the full response to
         satisfy the request and &MAY; replace the stored response(s).
      </t>
      <t>
         However, if a cache receives a 5xx response while attempting to
         validate a response, it can either forward this response to the
         requesting client, or act as if the server failed to respond. In the
         latter case, it can return a previously stored response (see <xref
         target="serving.stale.responses" />).
      </t>
   </list>
</t>

<section anchor="freshening.responses" title="Freshening Responses">
<t>
   When a cache receives a 304 (Not Modified) response and already has one
   or more stored 200 (OK) responses for the same cache key, the cache needs
   to identify which of the stored responses are updated by this new response
   and then update the stored response(s) with the new information provided in
   the 304 response.
   <list style="symbols">
    <t>
     If the new response contains a strong validator, then that strong
     validator identifies the selected representation.  All of the stored
     responses with the same strong validator are selected.
     If none of the stored responses contain the same strong validator, then
     this new response corresponds to a new selected representation and
     &MUST-NOT; update the existing stored responses.
    </t>
    <t>
     If the new response contains a weak validator and that validator
     corresponds to one of the cache's stored responses, then the most
     recent of those matching stored responses is selected.
    </t>
    <t>
     If the new response does not include any form of validator, there is
     only one stored response, and that stored response also lacks a
     validator, then that stored response is selected.
    </t>
   </list>
</t>
<t>
   If a stored response is selected for update, the cache &MUST;:
   <list style="symbols">
      <t>delete any Warning header fields in the stored response with
         warn-code 1xx (see <xref target="header.warning" />);</t>
      <t>retain any Warning header fields in the stored response with
         warn-code 2xx; and,</t>
      <t>use other header fields provided in the 304 response to replace
         all instances of the corresponding header fields in the stored
         response.</t>
   </list>
</t>
</section>

</section>

<section anchor="invalidation.after.updates.or.deletions" 
   title="Request Methods that Invalidate">
<t>
   Because unsafe request methods (&safe-methods;) such as PUT, POST or DELETE
   have the potential for changing state on the origin server, intervening
   caches can use them to keep their contents up-to-date.
</t>
<t>
   A cache &MUST; invalidate the effective Request URI 
   (&effective-request-uri;) as well as the URI(s) in the Location
   and Content-Location header fields (if present) when a non-error 
   response to a request with an unsafe method is received.
</t>
<t>
   However, a cache &MUST-NOT; invalidate a URI from a 
   Location or Content-Location header field if the host part of that URI 
   differs from the host part in the effective request URI 
   (&effective-request-uri;). This helps prevent denial of service attacks.
</t>
<t>
   A cache &MUST; invalidate the effective request URI 
   (&effective-request-uri;) when it receives a non-error response 
   to a request with a method whose safety is unknown.
</t>
<t>
   Here, a "non-error response" is one with a 2xx or 3xx status code.
   "Invalidate" means that the cache will either remove all stored
   responses related to the effective request URI, or will mark these as
   "invalid" and in need of a mandatory validation before they can be returned
   in response to a subsequent request.
</t>
<t>
   Note that this does not guarantee that all appropriate responses are
   invalidated. For example, the request that caused the change at the origin
   server might not have gone through the cache where a response is stored.
</t>
</section>

<section anchor="caching.authenticated.responses" 
   title="Shared Caching of Authenticated Responses">

<t>
   A shared cache &MUST-NOT; use a cached response to a request with an
   Authorization header field (&header-authorization;) to satisfy any subsequent
   request unless a cache directive that allows such responses to be stored is
   present in the response.
</t>

<t>
   In this specification, the following Cache-Control response directives
   (<xref target="cache-response-directive"/>) have such an effect:
   must-revalidate, public, s-maxage.
</t>

<t>
   Note that cached responses that contain the "must-revalidate" and/or
   "s-maxage" response directives are not allowed to be served stale (<xref
   target="serving.stale.responses"/>) by shared caches. In particular, a
   response with either "max-age=0, must-revalidate" or "s-maxage=0" cannot be
   used to satisfy a subsequent request without revalidating it on the origin
   server.
</t>
</section>

<section anchor="caching.negotiated.responses" 
   title="Caching Negotiated Responses">
<t>
   When a cache receives a request that can be satisfied by a stored response
   that has a Vary header field (<xref target="header.vary"/>), it &MUST-NOT;
   use that response unless all of the selecting header fields nominated by
   the Vary header field match in both the original request (i.e., that associated
   with the stored response), and the presented request.
</t>
<t>
   The selecting header fields from two requests are defined to match if and
   only if those in the first request can be transformed to those in the
   second request by applying any of the following:
   <list style="symbols">
      <t>
         adding or removing whitespace, where allowed in the header field's syntax
      </t>
      <t>
         combining multiple header fields with the same field name
         (see &header-fields;)
      </t>
      <t>
         normalizing both header field values in a way that is known to have
         identical semantics, according to the header field's specification (e.g.,
         re-ordering field values when order is not significant;
         case-normalization, where values are defined to be case-insensitive)
      </t>
  </list>
</t>
<t>
   If (after any normalization that might take place) a header field is absent
   from a request, it can only match another request if it is also absent
   there.
</t>
<t>
   A Vary header field-value of "*" always fails to match, and subsequent
   requests to that resource can only be properly interpreted by the origin
   server.
</t>
<t>
   The stored response with matching selecting header fields is known as the
   selected response.
</t>
<t>
   If multiple selected responses are available, the most recent response 
   (as determined by the Date header field) is used; see <xref 
   target="constructing.responses.from.caches"/>.
</t>
<t>
   If no selected response is available, the cache can forward the presented
   request to the origin server in a conditional request; see <xref
   target="validation.model"/>.
</t>
</section>

<section anchor="combining.responses" title="Combining Partial Content">
<t>
   A response might transfer only a partial representation if the
   connection closed prematurely or if the request used one or more Range
   specifiers (&partial;).  After several such transfers, a cache might have
   received several ranges of the same representation.  A cache &MAY; combine
   these ranges into a single stored response, and reuse that response to
   satisfy later requests, if they all share the same strong validator and
   the cache complies with the client requirements in &combining-byte-ranges;.
</t>
<t>
   When combining the new response with one or more stored responses, a
   cache &MUST;:
   <list style="symbols">
      <t>delete any Warning header fields in the stored response with
         warn-code 1xx (see <xref target="header.warning" />);</t>
      <t>retain any Warning header fields in the stored response with
         warn-code 2xx; and,</t>
      <t>use other header fields provided in the new response, aside
         from Content-Range, to replace all instances of the corresponding
         header fields in the stored response.</t>
   </list>
</t>
</section>


</section>

<section anchor="header.field.definitions" title="Header Field Definitions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to caching.
</t>

<section anchor="header.age" title="Age">
   <iref item="Age header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Age" x:for-anchor="" />
   <x:anchor-alias value="Age"/>
   <x:anchor-alias value="age-value"/>
<t>
   The "Age" header field conveys the sender's estimate of the amount
   of time since the response was generated or successfully validated at the
   origin server. Age values are calculated as specified in <xref
   target="age.calculations" />.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Age"/>
  <x:ref>Age</x:ref> = <x:ref>delta-seconds</x:ref>
</artwork></figure>
<t>
  Age field-values are non-negative integers, representing time in seconds
  (see <xref target="delta-seconds"/>).
</t>
<t>
   The presence of an Age header field in a response implies that a response
   is not first-hand. However, the converse is not true, since HTTP/1.0 caches
   might not implement the Age header field.
</t>
</section>

<section anchor="header.cache-control" title="Cache-Control">
   <iref item="Cache-Control header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Cache-Control" 
      x:for-anchor="" />
   <x:anchor-alias value="Cache-Control"/>
   <x:anchor-alias value="cache-directive"/>
   <x:anchor-alias value="cache-extension"/>
   <x:anchor-alias value="cache-request-directive"/>
   <x:anchor-alias value="cache-response-directive"/>
<t>
   The "Cache-Control" header field is used to specify directives for
   caches along the request/response chain. Such cache directives are
   unidirectional in that the presence of a directive in a request does not
   imply that the same directive is to be given in the response.
</t>
<t>
   A cache &MUST; obey the requirements of the Cache-Control
   directives defined in this section. See <xref
   target="cache.control.extensions"/> for information about how Cache-Control
   directives defined elsewhere are handled.
</t>
<x:note>
   <t>
       <x:h>Note:</x:h> HTTP/1.0 caches might not implement Cache-Control and
       might only implement Pragma: no-cache (see <xref target="header.pragma"
       />).
   </t>
</x:note>
<t>
   A proxy, whether or not it implements a cache, &MUST; pass cache directives
   through in forwarded messages, regardless of their 
   significance to that application, since the directives might be applicable 
   to all recipients along the request/response chain. It is not possible to 
   target a directive to a specific cache.
</t>
<t>Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument.</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Cache-Control"/><iref primary="true" item="Grammar" subitem="cache-extension"/>
  <x:ref>Cache-Control</x:ref>   = 1#<x:ref>cache-directive</x:ref>

  <x:ref>cache-directive</x:ref> = <x:ref>cache-request-directive</x:ref>
     / <x:ref>cache-response-directive</x:ref>

  <x:ref>cache-extension</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>

<section anchor="cache-request-directive" 
   title="Request Cache-Control Directives">
   <x:anchor-alias value="cache-request-directive" />

<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" 
   subitem="cache-request-directive" />
  <x:ref>cache-request-directive</x:ref> =
       "no-cache"
     / "no-store"
     / "max-age" "=" <x:ref>delta-seconds</x:ref>
     / "max-stale" [ "=" <x:ref>delta-seconds</x:ref> ]
     / "min-fresh" "=" <x:ref>delta-seconds</x:ref>
     / "no-transform"
     / "only-if-cached"
     / <x:ref>cache-extension</x:ref>
</artwork></figure>

<t>
   <x:dfn>no-cache</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-cache" />
   <iref item="no-cache" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-cache request directive indicates that a cache &MUST-NOT; 
      use a stored response to satisfy the request without successful 
      validation on the origin server.</t> 
   </list>
</t>
<t>
   <x:dfn>no-store</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-store" />
   <iref item="no-store" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-store request directive indicates that a cache &MUST-NOT;
      store any part of either this request or any response to it. This
      directive applies to both private and shared caches. "&MUST-NOT;
      store" in this context means that the cache &MUST-NOT; intentionally
      store the information in non-volatile storage, and &MUST; make a
      best-effort attempt to remove the information from volatile storage as
      promptly as possible after forwarding it.</t>
      <t>This directive is NOT a reliable or sufficient mechanism for ensuring
      privacy. In particular, malicious or compromised caches might not
      recognize or obey this directive, and communications networks might be
      vulnerable to eavesdropping.</t>
      <t>Note that if a request containing this directive is satisfied from a
      cache, the no-store request directive does not apply to the already
      stored response.</t>
   </list>
</t>
<t>
   <x:dfn>max-age</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="max-age" />
   <iref item="max-age" primary="true" subitem="Cache Directive" />
   <list>
      <t>The max-age request directive indicates that the client is unwilling to
      accept a response whose age is greater than the specified number of
      seconds. Unless the max-stale request directive is also present, the
      client is not willing to accept a stale response.</t>
   </list>
</t>
<t>
   <x:dfn>max-stale</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="max-stale" />
   <iref item="max-stale" primary="true" subitem="Cache Directive" />
   <list>
      <t>The max-stale request directive indicates that the client is willing
      to accept a response that has exceeded its expiration time. If max-stale
      is assigned a value, then the client is willing to accept a response
      that has exceeded its expiration time by no more than the specified
      number of seconds. If no value is assigned to max-stale, then the client
      is willing to accept a stale response of any age.</t>
   </list>
</t>
<t>
   <x:dfn>min-fresh</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="min-fresh" />
   <iref item="min-fresh" primary="true" subitem="Cache Directive" />
   <list>
      <t>The min-fresh request directive indicates that the client is willing
      to accept a response whose freshness lifetime is no less than its
      current age plus the specified time in seconds. That is, the client
      wants a response that will still be fresh for at least the specified
      number of seconds.</t>
   </list>
</t>
<t>
   <x:dfn>no-transform</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-transform" />
   <iref item="no-transform" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-transform request directive indicates that an intermediary
        (whether or not it implements a cache) &MUST-NOT; change the 
        Content-Encoding, Content-Range or Content-Type request header fields, 
        nor the request representation.</t>
   </list>
</t>
<t>
   <x:dfn>only-if-cached</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="only-if-cached" />
   <iref item="only-if-cached" primary="true" subitem="Cache Directive" />
   <list>
      <t>The only-if-cached request directive indicates that the client only
      wishes to obtain a stored response. If it receives this directive, a
      cache &SHOULD; either respond using a stored response that is consistent
      with the other constraints of the request, or respond with a 504
      (Gateway Timeout) status code. If a group of caches is being operated as
      a unified system with good internal connectivity, a member cache &MAY;
      forward such a request within that group of caches.</t>
   </list>
</t>
</section>

<section anchor="cache-response-directive" 
   title="Response Cache-Control Directives">
   <x:anchor-alias value="cache-response-directive" />

<figure><artwork type="abnf2616"><iref item="Grammar" primary="true" 
   subitem="cache-response-directive" />
  <x:ref>cache-response-directive</x:ref> =
       "public"
     / "private" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ]
     / "no-cache" [ "=" <x:ref>DQUOTE</x:ref> 1#<x:ref>field-name</x:ref> <x:ref>DQUOTE</x:ref> ]
     / "no-store"
     / "no-transform"
     / "must-revalidate"
     / "proxy-revalidate"
     / "max-age" "=" <x:ref>delta-seconds</x:ref>
     / "s-maxage" "=" <x:ref>delta-seconds</x:ref>
     / <x:ref>cache-extension</x:ref>
</artwork></figure>

<t>
   <x:dfn>public</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="public" />
   <iref item="public" primary="true" subitem="Cache Directive" />
   <list>
      <t>The public response directive indicates that a response whose 
        associated request contains an 'Authentication' header &MAY; be 
        stored (see <xref target="caching.authenticated.responses" />).</t>
  </list>
</t>
<t>
   <x:dfn>private</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="private" />
   <iref item="private" primary="true" subitem="Cache Directive" />
   <list>
      <t>The private response directive indicates that the response message is
      intended for a single user and &MUST-NOT; be stored by a shared cache. A
      private cache &MAY; store the response.</t>
      <t>If the private response directive specifies one or more field-names,
      this requirement is limited to the field-values associated with the
      listed response header fields. That is, a shared cache &MUST-NOT; store
      the specified field-names(s), whereas it &MAY; store the remainder of the
      response message.</t>
      <t> <x:h>Note:</x:h> This usage of the word private only controls where
      the response can be stored; it cannot ensure the privacy of the message
      content. Also, private response directives with field-names are often
      handled by implementations as if an unqualified private directive was
      received; i.e., the special handling for the qualified form is not
      widely implemented.</t>
   </list>
</t>
<t>
   <x:dfn>no-cache</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-cache" />
   <iref item="no-cache" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-cache response directive indicates that the response MUST NOT
      be used to satisfy a subsequent request without successful validation on
      the origin server. This allows an origin server to prevent a cache from
      using it to satisfy a request without contacting it, even by caches that
      have been configured to return stale responses.</t>
      <t>If the no-cache response directive specifies one or more field-names,
      this requirement is limited to the field-values associated with the
      listed response header fields. That is, a cache &MUST-NOT; send the 
      specified field-name(s) in the response to a subsequent request without successful
      validation on the origin server. This allows an origin server to prevent
      the re-use of certain header fields in a response, while still allowing
      caching of the rest of the response.</t>
      <t> <x:h>Note:</x:h> Most HTTP/1.0 caches will not recognize or obey
      this directive. Also, no-cache response directives with field-names are
      often handled by implementations as if an unqualified no-cache directive
      was received; i.e., the special handling for the qualified form is not
      widely implemented. </t>
   </list>
</t>
<t>
   <x:dfn>no-store</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-store" />
   <iref item="no-store" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-store response directive indicates that a cache &MUST-NOT;
      store any part of either the immediate request or response. This
      directive applies to both private and shared caches. "&MUST-NOT;
      store" in this context means that the cache &MUST-NOT; intentionally
      store the information in non-volatile storage, and &MUST; make a
      best-effort attempt to remove the information from volatile storage as
      promptly as possible after forwarding it.</t>
      <t>This directive is NOT a reliable or sufficient mechanism for ensuring
      privacy. In particular, malicious or compromised caches might not
      recognize or obey this directive, and communications networks might be
      vulnerable to eavesdropping.</t>
   </list>
</t>
<t>
   <x:dfn>must-revalidate</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="must-revalidate" />
   <iref item="must-revalidate" primary="true" subitem="Cache Directive" />
   <list>
      <t>The must-revalidate response directive indicates that once it has
      become stale, a cache &MUST-NOT; use the response to satisfy subsequent
      requests without successful validation on the origin server.</t>
      <t>The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances a
      cache &MUST; obey the must-revalidate directive; in particular,
      if a cache cannot reach the origin server for any reason, it &MUST;
      generate a 504 (Gateway Timeout) response.</t>
      <t>The must-revalidate directive ought to be used by servers if and only
      if failure to validate a request on the representation could result in
      incorrect operation, such as a silently unexecuted financial
      transaction.</t>
   </list>
</t>
<t>
   <x:dfn>proxy-revalidate</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="proxy-revalidate" />
   <iref item="proxy-revalidate" primary="true" subitem="Cache Directive" />
   <list>
      <t>The proxy-revalidate response directive has the same meaning as the
      must-revalidate response directive, except that it does not apply to
      private caches.</t>
   </list>
</t>
<t>
   <x:dfn>max-age</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="max-age" />
   <iref item="max-age" primary="true" subitem="Cache Directive" />
   <list>
      <t>The max-age response directive indicates that the response is to be
      considered stale after its age is greater than the specified number of
      seconds.</t>
   </list>
</t>
<t>
   <x:dfn>s-maxage</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="s-maxage" />
   <iref item="s-maxage" primary="true" subitem="Cache Directive" />
   <list>
      <t>The s-maxage response directive indicates that, in shared caches, the
      maximum age specified by this directive overrides the maximum age
      specified by either the max-age directive or the Expires header field. The
      s-maxage directive also implies the semantics of the proxy-revalidate
      response directive.</t>
   </list>
</t>
<t>
   <x:dfn>no-transform</x:dfn>
   <iref item="Cache Directives" primary="true" subitem="no-transform" />
   <iref item="no-transform" primary="true" subitem="Cache Directive" />
   <list>
      <t>The no-transform response directive indicates that an intermediary
      (regardless of whether it implements a cache) &MUST-NOT; change the 
      Content-Encoding, Content-Range or Content-Type response header fields, 
      nor the response representation.</t>
   </list>
</t>

</section>

<section anchor="cache.control.extensions" title="Cache Control Extensions">
<t>
   The Cache-Control header field can be extended through the use of one or
   more cache-extension tokens, each with an optional value. Informational
   extensions (those that do not require a change in cache behavior) can be
   added without changing the semantics of other directives. Behavioral
   extensions are designed to work by acting as modifiers to the existing base
   of cache directives. Both the new directive and the standard directive are
   supplied, such that applications that do not understand the new directive
   will default to the behavior specified by the standard directive, and those
   that understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without requiring
   changes to the base protocol.
</t>
<t>
   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.
</t>
<t>
   For example, consider a hypothetical new response directive called
   "community" that acts as a modifier to the private directive. We define
   this new directive to mean that, in addition to any private cache, any
   cache that is shared only by members of the community named within its
   value may cache the response. An origin server wishing to allow the UCI
   community to use an otherwise private response in their shared cache(s)
   could do so by including
</t>
<figure><artwork type="example">
  Cache-Control: private, community="UCI"
</artwork></figure>
<t>
   A cache seeing this header field will act correctly even if the cache does
   not understand the community cache-extension, since it will also see and
   understand the private directive and thus default to the safe behavior.
</t>
<t>
   A cache &MUST; ignore unrecognized cache directives; it is assumed that any
   cache directive likely to be unrecognized by an HTTP/1.1 cache will be
   combined with standard directives (or the response's default cacheability)
   such that the cache behavior will remain minimally correct even if the
   cache does not understand the extension(s).
</t>
<t>
   The HTTP Cache Directive Registry defines the name space for the cache
   directives.
</t>
<t>
   A registration &MUST; include the following fields:
   <list style="symbols">
      <t>Cache Directive Name</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to this name space are subject to IETF review (<xref
   target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
<t>
   The registry itself is maintained at <eref
   target="http://www.iana.org/assignments/http-cache-directives"/>.
</t>
</section>

</section>

<section anchor="header.expires" title="Expires">
   <iref item="Expires header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Expires" x:for-anchor="" />
   <x:anchor-alias value="Expires"/>
<t>
   The "Expires" header field gives the date/time after which the
   response is considered stale. See <xref target="expiration.model" /> for
   further discussion of the freshness model.
</t>
<t>
   The presence of an Expires field does not imply that the original resource
   will change or cease to exist at, before, or after that time.
</t>
<t>
   The field-value is an absolute date and time as defined by HTTP-date in
   &http-date;; a sender &MUST; use the rfc1123-date format.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Expires"/>
  <x:ref>Expires</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<figure>
  <preamble>For example</preamble>
<artwork type="example">
  Expires: Thu, 01 Dec 1994 16:00:00 GMT
</artwork></figure>
<t>
   A cache &MUST; treat other invalid date formats,
   especially including the value "0", as in the past (i.e., "already
   expired").
</t>
<x:note>
   <t>
       <x:h>Note:</x:h> If a response includes a Cache-Control field with the
       max-age directive (see <xref target="cache-response-directive" />),
       that directive overrides the Expires field. Likewise, the s-maxage
       directive overrides Expires in shared caches.
   </t>
</x:note>
<t>
   Historically, HTTP required the Expires field-value to be no more than a 
   year in the future. While longer freshness lifetimes are no longer 
   prohibited, extremely large values have been demonstrated to cause 
   problems (e.g., clock overflows due to use of 32-bit integers for 
   time values), and most caches will evict a response far sooner than 
   that. Therefore, senders ought not produce them.
</t>
<t>
   An origin server without a clock &MUST-NOT; assign Expires
   values to a response unless these values were associated
   with the resource by a system or user with a reliable clock. It &MAY;
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows "pre-expiration"
   of responses without storing separate Expires values for each
   resource).
</t>
</section>

<section anchor="header.pragma" title="Pragma">
   <iref item="Pragma header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Pragma" x:for-anchor="" />
   <x:anchor-alias value="extension-pragma"/>
   <x:anchor-alias value="Pragma"/>
   <x:anchor-alias value="pragma-directive"/>
<t>
   The "Pragma" header field allows backwards compatibility with HTTP/1.0
   caches, so that clients can specify a "no-cache" request that they will
   understand (as Cache-Control was not defined until HTTP/1.1). When the
   Cache-Control header is also present and understood in a request, Pragma is
   ignored.
</t>
<t>
   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients. This specification
   deprecates such extensions to improve interoperability.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Pragma"/><iref primary="true" item="Grammar" subitem="pragma-directive"/><iref primary="true" item="Grammar" subitem="extension-pragma"/>
  <x:ref>Pragma</x:ref>           = 1#<x:ref>pragma-directive</x:ref>
  <x:ref>pragma-directive</x:ref> = "no-cache" / <x:ref>extension-pragma</x:ref>
  <x:ref>extension-pragma</x:ref> = <x:ref>token</x:ref> [ "=" ( <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref> ) ]
</artwork></figure>
<t>
   When the Cache-Control header is not present in a request, the no-cache
   request pragma-directive &MUST; have the same effect on caches as if
   "Cache-Control: no-cache" were present (see <xref
   target="cache-request-directive" />).
</t>
<t>
   When sending a no-cache request, a client ought to include both the pragma
   and cache-control directives, unless Cache-Control: no-cache is
   purposefully omitted to target other Cache-Control response directives at
   HTTP/1.1 caches. For example:
</t>
<figure>
<artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
GET / HTTP/1.1
Host: www.example.com
Cache-Control: max-age=30
Pragma: no-cache

</artwork>
</figure>
<t>
   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.
</t>
<x:note>
   <t>
      <x:h>Note:</x:h> Because the meaning of "Pragma: no-cache" in responses is not
      specified, it does not provide a reliable replacement for
      "Cache-Control: no-cache" in them.
   </t>
</x:note>
</section>

<section anchor="header.vary" title="Vary">
   <iref item="Vary header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Vary" x:for-anchor="" />
   <x:anchor-alias value="Vary"/>
<t>
   The "Vary" header field conveys the set of header fields
   that were used to select the representation.
</t>
<t>
   Caches use this information, in part, to determine whether a stored
   response can be used to satisfy a given request; see <xref
   target="caching.negotiated.responses" />. determines, while the response is
   fresh, whether a cache is permitted to use the response to reply to a
   subsequent request without validation; see <xref
   target="caching.negotiated.responses" />.
</t>
<t>
   In uncacheable or stale responses, the Vary field value advises the user
   agent about the criteria that were used to select the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Vary"/>
  <x:ref>Vary</x:ref> = "*" / 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
   The set of header fields named by the Vary field value is known as the
   selecting header fields.
</t>
<t>
   A server &SHOULD; include a Vary header field with any cacheable response
   that is subject to server-driven negotiation. Doing so allows a cache to
   properly interpret future requests on that resource and informs the user
   agent about the presence of negotiation on that resource. A server &MAY;
   include a Vary header field with a non-cacheable response that is subject
   to server-driven negotiation, since this might provide the user agent with
   useful information about the dimensions over which the response varies at
   the time of the response.
</t>
<t>
   A Vary field value of "*" signals that unspecified parameters not limited
   to the header fields (e.g., the network address of the client), play a
   role in the selection of the response representation; therefore, a cache
   cannot determine whether this response is appropriate. A proxy &MUST-NOT;
   generate the "*" value.
</t>
<t>
   The field-names given are not limited to the set of standard header
   fields defined by this specification. Field names are case-insensitive.
</t>
</section>

<section anchor="header.warning" title="Warning">
   <iref item="Warning header field" primary="true" x:for-anchor="" />
   <iref item="Header Fields" primary="true" subitem="Warning" x:for-anchor="" />
   <x:anchor-alias value="Warning"/>
   <x:anchor-alias value="warning-value"/>
   <x:anchor-alias value="warn-agent"/>
   <x:anchor-alias value="warn-code"/>
   <x:anchor-alias value="warn-date"/>
   <x:anchor-alias value="warn-text"/>
<t>
   The "Warning" header field is used to carry additional information
   about the status or transformation of a message that might not be reflected
   in the message. This information is typically used to warn about possible
   incorrectness introduced by caching operations or transformations applied
   to the payload of the message.
</t>
<t>
   Warnings can be used for other purposes, both cache-related and otherwise.
   The use of a warning, rather than an error status code, distinguishes these
   responses from true failures.
</t>
<t>
   Warning header fields can in general be applied to any message, however some
   warn-codes are specific to caches and can only be applied to response
   messages.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Warning"/><iref primary="true" item="Grammar" subitem="warning-value"/><iref primary="true" item="Grammar" subitem="warn-code"/><iref primary="true" item="Grammar" subitem="warn-agent"/><iref primary="true" item="Grammar" subitem="warn-text"/><iref primary="true" item="Grammar" subitem="warn-date"/>
  <x:ref>Warning</x:ref>       = 1#<x:ref>warning-value</x:ref>
  
  <x:ref>warning-value</x:ref> = <x:ref>warn-code</x:ref> <x:ref>SP</x:ref> <x:ref>warn-agent</x:ref> <x:ref>SP</x:ref> <x:ref>warn-text</x:ref>
                                        [<x:ref>SP</x:ref> <x:ref>warn-date</x:ref>]
  
  <x:ref>warn-code</x:ref>  = 3<x:ref>DIGIT</x:ref>
  <x:ref>warn-agent</x:ref> = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
                  ; the name or pseudonym of the server adding
                  ; the Warning header field, for use in debugging
  <x:ref>warn-text</x:ref>  = <x:ref>quoted-string</x:ref>
  <x:ref>warn-date</x:ref>  = <x:ref>DQUOTE</x:ref> <x:ref>HTTP-date</x:ref> <x:ref>DQUOTE</x:ref>
</artwork></figure>
<t>
   Multiple warnings can be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number, only differing in warn-text.
</t>
<t>
   When this occurs, the user agent &SHOULD; inform the user of as many of
   them as possible, in the order that they appear in the response.
</t>
<t>
   Systems that generate multiple Warning header fields are encouraged to
   order them with this user agent behavior in mind. New Warning header fields
   are added after any existing Warning headers fields.
</t>
<t>
   Warnings are assigned three digit warn-codes. The first digit indicates
   whether the Warning is required to be deleted from a stored response after
   validation:
   <list style="symbols">
      <t>1xx Warnings describe the freshness or validation status of the
      response, and so &MUST; be deleted by a cache after validation. They can
      only be generated by a cache when validating a cached entry, and
      &MUST-NOT; be generated in any other situation.</t>
      <t>2xx Warnings describe some aspect of the representation that is not
      rectified by a validation (for example, a lossy compression of the
      representation) and &MUST-NOT; be deleted by a cache after validation,
      unless a full response is returned, in which case they &MUST; be.</t>
   </list>
</t>
<t>
   If an implementation sends a message with one or more Warning header fields to a
   receiver whose version is HTTP/1.0 or lower, then the sender &MUST; include
   in each warning-value a warn-date that matches the Date header field in the
   message.
</t>
<t>
   If a system receives a message with a warning-value that includes
   a warn-date, and that warn-date is different from the Date value in the
   response, then that warning-value &MUST; be deleted from the message before
   storing, forwarding, or using it. (preventing the consequences of naive
   caching of Warning header fields.) If all of the warning-values are deleted
   for this reason, the Warning header field &MUST; be deleted as well.
</t>
<t>
   The following warn-codes are defined by this specification, each with a
   recommended warn-text in English, and a description of its meaning.
</t>
<t><?rfc needLines="4"?>
   110 Response is stale
   <list>
      <t>A cache &SHOULD; include this whenever the returned response is stale.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   111 Revalidation failed
   <list>
      <t>A cache &SHOULD; include this when returning a stale response because an
      attempt to validate the response failed, due to an inability to reach
      the server.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   112 Disconnected operation
   <list>
      <t>A cache &SHOULD; include this if it is intentionally disconnected from
      the rest of the network for a period of time.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   113 Heuristic expiration
   <list>
      <t>A cache &SHOULD; include this if it heuristically chose a freshness
      lifetime greater than 24 hours and the response's age is greater than 24
      hours.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   199 Miscellaneous warning
   <list>
      <t>The warning text can include arbitrary information to be presented to
      a human user, or logged. A system receiving this warning &MUST-NOT; take
      any automated action, besides presenting the warning to the user.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   214 Transformation applied
   <list>
      <t>&MUST; be added by a proxy if it applies any
      transformation to the representation, such as changing the
      content-coding, media-type, or modifying the representation data, unless
      this Warning code already appears in the response.</t>
   </list>
</t>
<t><?rfc needLines="4"?>
   299 Miscellaneous persistent warning
   <list>
      <t>The warning text can include arbitrary information to be presented to
      a human user, or logged. A system receiving this warning &MUST-NOT; take
      any automated action.</t>
   </list>
</t>
</section>

</section>

<section anchor="history.lists" title="History Lists">
<t>
   User agents often have history mechanisms, such as "Back" buttons and
   history lists, that can be used to redisplay a representation retrieved
   earlier in a session.
</t>
<t>
   The freshness model (<xref target="expiration.model"/>) does not
   necessarily apply to history mechanisms. I.e., a history mechanism can
   display a previous representation even if it has expired.
</t>
<t>
   This does not prohibit the history mechanism from telling the user that a
   view might be stale, or from honoring cache directives (e.g.,
   Cache-Control: no-store).
</t>
</section>


<section anchor="IANA.considerations" title="IANA Considerations">

<section title="Cache Directive Registry" 
   anchor="cache.directive.registration">
<t>
   The registration procedure for HTTP Cache Directives is defined by <xref
   target="cache.control.extensions"/> of this document.
</t>
<t>
   The HTTP Cache Directive Registry shall be created at <eref
   target="http://www.iana.org/assignments/http-cache-directives"/> and be
   populated with the registrations below:
</t>
<?BEGININC p6-cache.cache-directives ?>
<!--AUTOGENERATED FROM extract-cache-directives-defs.xslt, do not edit manually-->
<texttable xmlns:my="#my" align="left" suppress-title="true"
           anchor="iana.cache.directive.registration.table">
   <ttcol>Cache Directive</ttcol>
   <ttcol>Reference</ttcol>

   <c>max-age</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>max-stale</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>min-fresh</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>must-revalidate</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>no-cache</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>no-store</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>no-transform</c>
   <c>
      <xref target="cache-request-directive"/>, <xref target="cache-response-directive"/>
   </c>
   <c>only-if-cached</c>
   <c>
      <xref target="cache-request-directive"/>
   </c>
   <c>private</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>proxy-revalidate</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>public</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>s-maxage</c>
   <c>
      <xref target="cache-response-directive"/>
   </c>
   <c>stale-if-error</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="4"/>
   </c>
   <c>stale-while-revalidate</c>
   <c>
      <xref xmlns:x="http://purl.org/net/xml2rfc/ext" target="RFC5861" x:fmt="," x:sec="3"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.cache-directives ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
  The Message Header Field Registry located at <eref  
  target="http://www.iana.org/assignments/message-headers/message-header-index.html" />
  shall be updated with the permanent registrations below (see <xref target="RFC3864" />):
</t>
<?BEGININC p6-cache.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Age</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.age"/>
   </c>
   <c>Cache-Control</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.cache-control"/>
   </c>
   <c>Expires</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expires"/>
   </c>
   <c>Pragma</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.pragma"/>
   </c>
   <c>Vary</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.vary"/>
   </c>
   <c>Warning</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.warning"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p6-cache.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task
   Force".
</t>
</section>

</section>

<section anchor="security.considerations" title="Security Considerations">
<t>
   Caches expose additional potential vulnerabilities, since the contents of
   the cache represent an attractive target for malicious exploitation.
   Because cache contents persist after an HTTP request is complete, an attack
   on the cache can reveal information long after a user believes that the
   information has been removed from the network. Therefore, cache contents
   need to be protected as sensitive information.
</t>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>

</middle>

<back>
<references title="Normative References">

  <reference anchor="Part1">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;" />
    <x:source basename="p1-messaging" href="p1-messaging.xml" />
  </reference>

  <reference anchor="Part2">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;" />
    <x:source basename="p2-semantics" href="p2-semantics.xml" />
  </reference>

  <reference anchor="Part4">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 4: Conditional Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;" />
    <x:source basename="p4-conditional" href="p4-conditional.xml" />
  </reference>

  <reference anchor="Part5">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;" />
    <x:source basename="p5-range" href="p5-range.xml" />
  </reference>

  <reference anchor="Part7">
    <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 7: Authentication</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Jim Gettys" initials="J." surname="Gettys">
        <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
        <address><email>jg@freedesktop.org</email></address>
      </author>
      <author fullname="Jeffrey C. Mogul" initials="J." surname="Mogul">
        <organization abbrev="HP">Hewlett-Packard Company</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author fullname="Henrik Frystyk Nielsen" initials="H." surname="Frystyk">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author fullname="Larry Masinter" initials="L." surname="Masinter">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>LMM@acm.org</email></address>
      </author>
      <author fullname="Paul J. Leach" initials="P." surname="Leach">
        <organization abbrev="Microsoft">Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="Tim Berners-Lee" initials="T." surname="Berners-Lee">
        <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;" />
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-&ID-VERSION;" />
    <x:source basename="p7-auth" href="p7-auth.xml" />
  </reference>

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author fullname="Scott Bradner" initials="S." surname="Bradner">
        <organization>Harvard University</organization>
        <address><email>sob@harvard.edu</email></address>
      </author>
      <date month="March" year="1997" />
    </front>
    <seriesInfo name="BCP" value="14" />
    <seriesInfo name="RFC" value="2119" />
  </reference>

  <reference anchor="RFC5234">
    <front>
      <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
      <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
        <organization>Brandenburg InternetWorking</organization>
        <address>
          <email>dcrocker@bbiw.net</email>
        </address>  
      </author>
      <author initials="P." surname="Overell" fullname="Paul Overell">
        <organization>THUS plc.</organization>
        <address>
          <email>paul.overell@thus.net</email>
        </address>
      </author>
      <date month="January" year="2008"/>
    </front>
    <seriesInfo name="STD" value="68"/>
    <seriesInfo name="RFC" value="5234"/>
  </reference>
  
</references>

<references title="Informative References">

  <reference anchor="RFC1305">
    <front>
      <title>Network Time Protocol (Version 3) Specification, Implementation</title>
      <author fullname="David L. Mills" initials="D." surname="Mills">
        <organization>University of Delaware, Electrical Engineering Department</organization>
        <address><email>mills@udel.edu</email></address>
      </author>
      <date month="March" year="1992" />
    </front>
    <seriesInfo name="RFC" value="1305" />
  </reference>

  <reference anchor="RFC2616">
    <front>
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
      <author fullname="R. Fielding" initials="R." surname="Fielding">
        <organization>University of California, Irvine</organization>
        <address><email>fielding@ics.uci.edu</email></address>
      </author>
      <author fullname="J. Gettys" initials="J." surname="Gettys">
        <organization>W3C</organization>
        <address><email>jg@w3.org</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>Compaq Computer Corporation</organization>
        <address><email>mogul@wrl.dec.com</email></address>
      </author>
      <author fullname="H. Frystyk" initials="H." surname="Frystyk">
        <organization>MIT Laboratory for Computer Science</organization>
        <address><email>frystyk@w3.org</email></address>
      </author>
      <author fullname="L. Masinter" initials="L." surname="Masinter">
        <organization>Xerox Corporation</organization>
        <address><email>masinter@parc.xerox.com</email></address>
      </author>
      <author fullname="P. Leach" initials="P." surname="Leach">
        <organization>Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee">
        <organization>W3C</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <date month="June" year="1999" />
    </front>
    <seriesInfo name="RFC" value="2616" />
  </reference>

  <reference anchor="RFC3864">
    <front>
      <title>Registration Procedures for Message Header Fields</title>
      <author fullname="G. Klyne" initials="G." surname="Klyne">
        <organization>Nine by Nine</organization>
        <address><email>GK-IETF@ninebynine.org</email></address>
      </author>
      <author fullname="M. Nottingham" initials="M." surname="Nottingham">
        <organization>BEA Systems</organization>
        <address><email>mnot@pobox.com</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>HP Labs</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <date month="September" year="2004" />
    </front>
    <seriesInfo name="BCP" value="90" />
    <seriesInfo name="RFC" value="3864" />
  </reference>

  <reference anchor='RFC5226'>
    <front>
      <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
      <author initials='T.' surname='Narten' fullname='T. Narten'>
        <organization>IBM</organization>
        <address><email>narten@us.ibm.com</email></address>
      </author>
      <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
        <organization>Google</organization>
        <address><email>Harald@Alvestrand.no</email></address>
      </author>
      <date year='2008' month='May' />
    </front>
    <seriesInfo name='BCP' value='26' />
    <seriesInfo name='RFC' value='5226' />
  </reference>

  <reference anchor='RFC5861'>
    <front>
      <title abbrev="HTTP stale controls">HTTP Cache-Control Extensions for Stale Content</title>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization>Yahoo! Inc.</organization>
        <address><email>mnot@yahoo-inc.com</email></address>
      </author>
      <date month="April" year="2010"/>
    </front>
    <seriesInfo name='RFC' value='5861' />
  </reference>

</references>

<section anchor="changes.from.rfc.2616" title="Changes from RFC 2616">
<t>
  Make the specified age calculation algorithm less conservative.
  (<xref target="age.calculations"/>)
</t>
<t>
  Remove requirement to consider Content-Location in successful responses
  in order to determine the appropriate response to use.
  (<xref target="validation.model" />)
</t>
<t>
  Clarify denial of service attack avoidance requirement.
  (<xref target="invalidation.after.updates.or.deletions" />)
</t>
<t>
  Change ABNF productions for header fields to only define the field value.
  (<xref target="header.field.definitions"/>)
</t>
<t>
  Do not mention RFC 2047 encoding and multiple languages in Warning header fields
  anymore, as these aspects never were implemented. 
  (<xref target="header.warning" />)
</t>
</section>

<?BEGININC p6-cache.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p6-cache.parsed-abnf">
<x:ref>Age</x:ref> = delta-seconds

<x:ref>Cache-Control</x:ref> = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

<x:ref>Expires</x:ref> = HTTP-date

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part2], Section 8&gt;

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>Pragma</x:ref> = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

<x:ref>Vary</x:ref> = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name ]
 ) )

<x:ref>Warning</x:ref> = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value ]
 )

<x:ref>cache-directive</x:ref> = cache-request-directive / cache-response-directive
<x:ref>cache-extension</x:ref> = token [ "=" ( token / quoted-string ) ]
<x:ref>cache-request-directive</x:ref> = "no-cache" / "no-store" / ( "max-age="
 delta-seconds ) / ( "max-stale" [ "=" delta-seconds ] ) / (
 "min-fresh=" delta-seconds ) / "no-transform" / "only-if-cached" /
 cache-extension
<x:ref>cache-response-directive</x:ref> = "public" / ( "private" [ "=" DQUOTE *( ","
 OWS ) field-name *( OWS "," [ OWS field-name ] ) DQUOTE ] ) / (
 "no-cache" [ "=" DQUOTE *( "," OWS ) field-name *( OWS "," [ OWS
 field-name ] ) DQUOTE ] ) / "no-store" / "no-transform" /
 "must-revalidate" / "proxy-revalidate" / ( "max-age=" delta-seconds
 ) / ( "s-maxage=" delta-seconds ) / cache-extension

<x:ref>delta-seconds</x:ref> = 1*DIGIT

<x:ref>extension-pragma</x:ref> = token [ "=" ( token / quoted-string ) ]

<x:ref>field-name</x:ref> = &lt;field-name, defined in [Part1], Section 3.2&gt;

<x:ref>port</x:ref> = &lt;port, defined in [Part1], Section 2.7&gt;
<x:ref>pragma-directive</x:ref> = "no-cache" / extension-pragma
<x:ref>pseudonym</x:ref> = &lt;pseudonym, defined in [Part1], Section 8.8&gt;

<x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in [Part1], Section 3.2.3&gt;

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 3.2.3&gt;

<x:ref>uri-host</x:ref> = &lt;uri-host, defined in [Part1], Section 2.7&gt;

<x:ref>warn-agent</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>warn-code</x:ref> = 3DIGIT
<x:ref>warn-date</x:ref> = DQUOTE HTTP-date DQUOTE
<x:ref>warn-text</x:ref> = quoted-string
<x:ref>warning-value</x:ref> = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; Age defined but not used
; Cache-Control defined but not used
; Expires defined but not used
; Pragma defined but not used
; Vary defined but not used
; Warning defined but not used
</artwork></figure></section>
<?ENDINC p6-cache.abnf-appendix ?>

<section anchor="change.log" title="Change Log (to be removed by RFC Editor before publication)">

<section title="Since RFC 2616">
  <t>Extracted relevant partitions from <xref target="RFC2616" />.</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-00">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/9" />: "Trailer" (<eref target="http://purl.org/NET/http-errata#trailer-hop" />)</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/12" />: "Invalidation after Update or Delete" (<eref target="http://purl.org/NET/http-errata#invalidupd" />)</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35" />: "Normative and Informative references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/48" />: "Date reference typo"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/49" />: "Connection header text"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/65" />: "Informative references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/66" />: "ISO-8859-1 Reference"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86" />: "Normative up-to-date references"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/87" />: "typo in 13.2.2"</t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols">
    <t>Use names of RFC4234 core rules DQUOTE and HTAB (work in progress on <eref
        target="http://tools.ietf.org/wg/httpbis/trac/ticket/36" />)</t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-01">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/82" />: "rel_path not used"</t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols">
    <t>Get rid of duplicate BNF rule names ("host" -&gt; "uri-host") (work in progress
      on <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36" />)</t>
    <t>Add explicit references to BNF syntax and rules imported from other parts of the
      specification.</t>
  </list>
</t>
</section>

<section anchor="changes.since.02" title="Since draft-ietf-httpbis-p6-cache-02">
<t>
  Ongoing work on IANA Message Header Field Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40" />):
  <list style="symbols">
    <t>Reference RFC 3984, and update header field registrations for header fields defined in this
      document.</t>
  </list>
</t>
</section>

<section anchor="changes.since.03" title="Since draft-ietf-httpbis-p6-cache-03">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/106" />: "Vary header classification"</t>
  </list>
</t>
</section>

<section anchor="changes.since.04" title="Since draft-ietf-httpbis-p6-cache-04">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header field value format definitions.
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.05" title="Since draft-ietf-httpbis-p6-cache-05">
<t>
  This is a total rewrite of this part of the specification.
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/54" />: "Definition of 1xx Warn-Codes"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60" />: "Placement of 13.5.1 and 13.5.2"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/138" />: "The role of Warning and Semantic Transparency in Caching"</t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/139" />: "Methods and Caching"</t>
  </list>
</t>
<t>
  In addition: Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.06" title="Since draft-ietf-httpbis-p6-cache-06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/161"/>:
      "base for numeric protocol elements"
    </t>
  </list>
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/37"/>: 
      "Vary and non-existant headers"
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.07" title="Since draft-ietf-httpbis-p6-cache-07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/54" />:
      "Definition of 1xx Warn-Codes"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/167"/>:
      "Content-Location on 304 responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/169" />:
      "private and no-cache CC directives with headers"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/187"/>:
      "RFC2047 and warn-text"
    </t>
  </list>
</t>
</section>

<section anchor="changes.since.08" title="Since draft-ietf-httpbis-p6-cache-08">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/147" />:
      "serving negotiated responses from cache: header-specific canonicalization"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/197" />:
      "Effect of CC directives on history lists"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/291" />:
      "Cache Extensions can override no-store, etc."
    </t>
  </list>
</t>
<t>
  Affected issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/199"/>: 
      Status codes and caching
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60"/>:
      "Placement of 13.5.1 and 13.5.2"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-09" anchor="changes.since.09">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/29" />:
      "Age calculation"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/168" />:
      "Clarify differences between / requirements for request and response CC directives"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/174" />:
      "Caching authenticated responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/208" />:
      "IANA registry for cache-control directives"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/211" />:
      "Heuristic caching of URLs with query components"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/196"/>:
      "Term for the requested resource's URI"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/223"/>:
      "Allowing heuristic caching for new status codes"
    </t>
    <t>
      Clean up TODOs and prose in "Combining Responses."
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-11" anchor="changes.since.11">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/204"/>:
      "Text about clock requirement for caches belongs in p6"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-12" anchor="changes.since.12">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/224"/>:
      "Header Classification"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/268"/>:
      "Clarify 'public'"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-13" anchor="changes.since.13">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/276"/>:
      "untangle ABNFs for header fields"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-14" anchor="changes.since.14">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/38"/>:
      "Mismatch Vary"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/235"/>:
      "Cache Invalidation only happens upon successful responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/282"/>:
      "Recommend minimum sizes for protocol elements"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/289"/>:
      "Proxies don't 'understand' methods"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/291"/>:
      "Cache Extensions can override no-store, etc."
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/292"/>:
      "Pragma"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-15" anchor="changes.since.15">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/290"/>:
      "Motivate one-year limit for Expires"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-16" anchor="changes.since.16">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/186"/>:
      "Document HTTP's error-handling philosophy"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/317"/>:
      "Cache-Control directive case sensitivity"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p6-cache-17" anchor="changes.since.17">
<t>
  No changes yet.
</t>
</section>

</section>
  </back>
</rfc>
