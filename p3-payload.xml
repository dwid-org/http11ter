<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "December">
  <!ENTITY ID-YEAR "2007">
  <!ENTITY caching                  "<xref target='Part6' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-transfer-encoding "<xref target='Part1' x:rel='#header.transfer-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-allow             "<xref target='Part2' x:rel='#header.allow' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-length    "<xref target='Part1' x:rel='#header.content-length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-range     "<xref target='Part5' x:rel='#header.content-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expires           "<xref target='Part6' x:rel='#header.expires' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified     "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-user-agent        "<xref target='Part2' x:rel='#header.user-agent' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-body             "<xref target='Part1' x:rel='#message.body' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-length           "<xref target='Part1' x:rel='#message.length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY multipart-byteranges     "<xref target='Part5' x:rel='#internet.media.type.multipart.byteranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2068, 2616" category="std"
     ipr="full3978" docName="draft-ietf-httpbis-p3-payload-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext' xmlns:ed="http://greenbytes.de/2002/rfcedit">
<front>

  <title abbrev="HTTP/1.1">HTTP/1.1, part 3: Message Payload and Content Negotiation</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <postal>
        <street>23 Corporate Plaza DR, Suite 280</street>
        <city>Newport Beach</city>
        <region>CA</region>
        <code>92660</code>
        <country>USA</country>
      </postal>
      <phone>+1-949-706-5300</phone>
      <facsimile>+1-949-706-5305</facsimile>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization>One Laptop per Child</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@laptop.org</email>
      <uri>http://www.laptop.org/</uri>
    </address>
  </author>
  
  <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author initials="L." surname="Masinter" fullname="Larry Masinter">
    <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  
  <author initials="P." surname="Leach" fullname="Paul J. Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>
   
  <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World Wide Web global information
   initiative since 1990. This document is Part 3 of the seven-part specification
   that defines the protocol referred to as "HTTP/1.1" and, taken together,
   obsoletes RFC 2616.  Part 3 defines HTTP message content,
   metadata, and content negotiation.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    This version of the HTTP specification contains only minimal editorial
    changes from <xref target="RFC2616"/> (abstract, introductory paragraph,
    and authors' addresses).  All other changes are due to partitioning the
    original into seven mostly independent parts.  The intent is for readers
    of future drafts to able to use draft 00 as the basis for comparison
    when the WG makes later changes to the specification text.  This draft
    will shortly be followed by draft 01 (containing the first round of changes
    that have already been agreed to on the mailing list). There is no point in
    reviewing this draft other than to verify that the partitioning has been
    done correctly.  Roy T. Fielding, Yves Lafon, and Julian Reschke
    will be the editors after draft 00 is submitted.
  </t>
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org). The current issues list is
    at <eref target="http://www3.tools.ietf.org/wg/httpbis/trac/report/11"/>
    and related documents (including fancy diffs) can be found at
    <eref target="http://www3.tools.ietf.org/wg/httpbis/"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   This document will define aspects of HTTP related to the payload of
   messages (message content), including metadata and media types, along
   with HTTP content negotiation.  Right now it only includes the extracted
   relevant sections of RFC 2616 without edit.
</t>
</section>

<section title="Protocol Parameters" anchor="protocol.parameters">

<section title="Character Sets" anchor="character.sets">
<t>
   HTTP uses the same definition of the term "character set" as that
   described for MIME:
</t>
<t>
   The term "character set" is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name &MUST; fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.
</t>
<t><list><t>
      <x:h>Note:</x:h> This use of the term "character set" is more commonly
      referred to as a "character encoding." However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.
</t></list></t>
<t>
   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   (<eref target="http://www.iana.org/assignments/character-sets"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="charset"/>
    charset = token
</artwork></figure>
<t>
   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry &MUST; represent the character set defined
   by that registry. Applications &SHOULD; limit their use of character
   sets to those defined by the IANA registry.
</t>
<t>
   HTTP uses charset in two contexts: within an Accept-Charset request
   header (in which the charset value is an unquoted token) and as the
   value of a parameter in a Content-type header (within a request or
   response), in which case the parameter value of the charset parameter
   may be quoted.
</t>
<t>
   Implementors should be aware of IETF character set requirements <xref target="RFC2279"/>
   <xref target="RFC2277"/>.
</t>

<section title="Missing Charset" anchor="missing.charset">
<t>
   Some HTTP/1.0 software has interpreted a Content-Type header without
   charset parameter incorrectly to mean "recipient should guess."
   Senders wishing to defeat this behavior &MAY; include a charset
   parameter even when the charset is ISO-8859-1 and &SHOULD; do so when
   it is known that it will not confuse the recipient.
</t>
<t>
   Unfortunately, some older HTTP/1.0 clients did not deal properly with
   an explicit charset parameter. HTTP/1.1 recipients &MUST; respect the
   charset label provided by the sender; and those user agents that have
   a provision to "guess" a charset &MUST; use the charset from the
   content-type field if they support that charset, rather than the
   recipient's preference, when initially displaying a document. See
   <xref target="canonicalization.and.text.defaults"/>.
</t>
</section>
</section>

<section title="Content Codings" anchor="content.codings">
<t>
   Content coding values indicate an encoding transformation that has
   been or can be applied to an entity. Content codings are primarily
   used to allow a document to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the entity is stored in
   coded form, transmitted directly, and only decoded by the recipient.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="content-coding"/>
    content-coding   = token
</artwork></figure>
<t>
   All content-coding values are case-insensitive. HTTP/1.1 uses
   content-coding values in the Accept-Encoding (<xref target="header.accept-encoding"/>) and
   Content-Encoding (<xref target="header.content-encoding"/>) header fields. Although the value
   describes the content-coding, what is more important is that it
   indicates what decoding mechanism will be required to remove the
   encoding.
</t>
<t>
   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   content-coding value tokens. Initially, the registry contains the
   following tokens:
</t>
<t>
   gzip<iref item="gzip"/>
  <list>
    <t>
        An encoding format produced by the file compression program
        "gzip" (GNU zip) as described in RFC 1952 <xref target="RFC1952"/>. This format is a
        Lempel-Ziv coding (LZ77) with a 32 bit CRC.
    </t>
  </list>
</t>
<t>
   compress<iref item="compress"/>
  <list><t>
        The encoding format produced by the common UNIX file compression
        program "compress". This format is an adaptive Lempel-Ziv-Welch
        coding (LZW).
</t><t>
        Use of program names for the identification of encoding formats
        is not desirable and is discouraged for future encodings. Their
        use here is representative of historical practice, not good
        design. For compatibility with previous implementations of HTTP,
        applications &SHOULD; consider "x-gzip" and "x-compress" to be
        equivalent to "gzip" and "compress" respectively.
  </t></list>
</t>
<t>
   deflate<iref item="deflate"/>
  <list><t>
        The "zlib" format defined in RFC 1950 <xref target="RFC1950"/> in combination with
        the "deflate" compression mechanism described in RFC 1951 <xref target="RFC1951"/>.
  </t></list>
</t>
<t>
   identity<iref item="identity"/>
  <list><t>
        The default (identity) encoding; the use of no transformation
        whatsoever. This content-coding is used only in the Accept-Encoding
        header, and &SHOULD-NOT;  be used in the Content-Encoding
        header.
  </t></list>
</t>
<t>
   New content-coding value tokens &SHOULD; be registered; to allow
   interoperability between clients and servers, specifications of the
   content coding algorithms needed to implement a new value &SHOULD; be
   publicly available and adequate for independent implementation, and
   conform to the purpose of content coding defined in this section.
</t>
</section>

<section title="Media Types" anchor="media.types">
<t>
   HTTP uses Internet Media Types <xref target="RFC4288"/> in the Content-Type (<xref target="header.content-type"/>)
   and Accept (<xref target="header.accept"/>) header fields in order to provide
   open and extensible data typing and type negotiation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="media-type"/><iref primary="true" item="Grammar" subitem="type"/><iref primary="true" item="Grammar" subitem="subtype"/>
    media-type     = type "/" subtype *( ";" parameter )
    type           = token
    subtype        = token
</artwork></figure>
<t>
   Parameters &MAY; follow the type/subtype in the form of attribute/value
   pairs.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="parameter"/><iref primary="true" item="Grammar" subitem="attribute"/><iref primary="true" item="Grammar" subitem="value"/>
    parameter               = attribute "=" value
    attribute               = token
    value                   = token | quoted-string
</artwork></figure>
<t>
   The type, subtype, and parameter attribute names are case-insensitive.
   Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) &MUST-NOT; be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry.
</t>
<t>
   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations &SHOULD; only use media type parameters when they are
   required by that type/subtype definition.
</t>
<t>
   Media-type values are registered with the Internet Assigned Number
   Authority (IANA). The media type registration process is
   outlined in RFC 4288 <xref target="RFC4288"/>. Use of non-registered media types is
   discouraged.
</t>

<section title="Canonicalization and Text Defaults" anchor="canonicalization.and.text.defaults">
<t>
   Internet media types are registered with a canonical form. An
   entity-body transferred via HTTP messages &MUST; be represented in the
   appropriate canonical form prior to its transmission except for
   "text" types, as defined in the next paragraph.
</t>
<t>
   When in canonical form, media subtypes of the "text" type use CRLF as
   the text line break. HTTP relaxes this requirement and allows the
   transport of text media with plain CR or LF alone representing a line
   break when it is done consistently for an entire entity-body. HTTP
   applications &MUST; accept CRLF, bare CR, and bare LF as being
   representative of a line break in text media received via HTTP. In
   addition, if the text is represented in a character set that does not
   use octets 13 and 10 for CR and LF respectively, as is the case for
   some multi-byte character sets, HTTP allows the use of whatever octet
   sequences are defined by that character set to represent the
   equivalent of CR and LF for line breaks. This flexibility regarding
   line breaks applies only to text media in the entity-body; a bare CR
   or LF &MUST-NOT; be substituted for CRLF within any of the HTTP control
   structures (such as header fields and multipart boundaries).
</t>
<t>
   If an entity-body is encoded with a content-coding, the underlying
   data &MUST; be in a form defined above prior to being encoded.
</t>
<t>
   The "charset" parameter is used with some media types to define the
   character set (<xref target="character.sets"/>) of the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the "text"
   type are defined to have a default charset value of "ISO-8859-1" when
   received via HTTP. Data in character sets other than "ISO-8859-1" or
   its subsets &MUST; be labeled with an appropriate charset value. See
   <xref target="missing.charset"/> for compatibility problems.
</t>
</section>

<section title="Multipart Types" anchor="multipart.types">
<t>
   MIME provides for a number of "multipart" types -- encapsulations of
   one or more entities within a single message-body. All multipart
   types share a common syntax, as defined in section <xref target="RFC2046" x:sec="5.1.1" x:fmt="number"/> of RFC 2046
   <xref target="RFC2046"/>, and &MUST; include a boundary parameter as part of the media type
   value. The message body is itself a protocol element and &MUST;
   therefore use only CRLF to represent line breaks between body-parts.
   Unlike in RFC 2046, the epilogue of any multipart message &MUST; be
   empty; HTTP applications &MUST-NOT; transmit the epilogue (even if the
   original multipart contains an epilogue). These restrictions exist in
   order to preserve the self-delimiting nature of a multipart message-body,
   wherein the "end" of the message-body is indicated by the
   ending multipart boundary.
</t>
<t>
   In general, HTTP treats a multipart message-body no differently than
   any other media type: strictly as payload. The one exception is the
   "multipart/byteranges" type (&multipart-byteranges;) when it appears in a 206
   (Partial Content) response. In all
   other cases, an HTTP user agent &SHOULD; follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   The MIME header fields within each body-part of a multipart message-body
   do not have any significance to HTTP beyond that defined by
   their MIME semantics.
</t>
<t>
   In general, an HTTP user agent &SHOULD; follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   If an application receives an unrecognized multipart subtype, the
   application &MUST; treat it as being equivalent to "multipart/mixed".
</t>
<t><list><t>
      <x:h>Note:</x:h> The "multipart/form-data" type has been specifically defined
      for carrying form data suitable for processing via the POST
      request method, as described in RFC 1867 <xref target="RFC1867"/>.
</t></list></t>
</section>
</section>

<section title="Quality Values" anchor="quality.values">
<t>
   HTTP content negotiation (<xref target="content.negotiation"/>) uses short "floating point"
   numbers to indicate the relative importance ("weight") of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications &MUST-NOT; generate more than three digits after the
   decimal point. User configuration of these values &SHOULD; also be
   limited in this fashion.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="qvalue"/>
    qvalue         = ( "0" [ "." 0*3DIGIT ] )
                   | ( "1" [ "." 0*3("0") ] )
</artwork></figure>
<t>
   "Quality values" is a misnomer, since these values merely represent
   relative degradation in desired quality.
</t>
</section>

<section title="Language Tags" anchor="language.tags">
<t>
   A language tag identifies a natural language spoken, written, or
   otherwise conveyed by human beings for communication of information
   to other human beings. Computer languages are explicitly excluded.
   HTTP uses language tags within the Accept-Language and Content-Language
   fields.
</t>
<t>
   The syntax and registry of HTTP language tags is the same as that
   defined by RFC 1766 <xref target="RFC1766"/>. In summary, a language tag is composed of 1
   or more parts: A primary language tag and a possibly empty series of
   subtags:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="language-tag"/><iref primary="true" item="Grammar" subitem="primary-tag"/><iref primary="true" item="Grammar" subitem="subtag"/>
     language-tag  = primary-tag *( "-" subtag )
     primary-tag   = 1*8ALPHA
     subtag        = 1*8ALPHA
</artwork></figure>
<t>
   White space is not allowed within the tag and all tags are case-insensitive.
   The name space of language tags is administered by the
   IANA. Example tags include:
</t>
<figure><artwork type="example">
    en, en-US, en-cockney, i-cherokee, x-pig-latin
</artwork></figure>
<t>
   where any two-letter primary-tag is an ISO-639 language abbreviation
   and any two-letter initial subtag is an ISO-3166 country code. (The
   last three tags above are not registered tags; all but the last are
   examples of tags which could be registered in future.)
</t>
</section>
</section>

<section title="Entity" anchor="entity">
<t>
   Request and Response messages &MAY; transfer an entity if not otherwise
   restricted by the request method or response status code. An entity
   consists of entity-header fields and an entity-body, although some
   responses will only include the entity-headers.
</t>
<t>
   In this section, both sender and recipient refer to either the client
   or the server, depending on who sends and who receives the entity.
</t>

<section title="Entity Header Fields" anchor="entity.header.fields">
<t>
   Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is &OPTIONAL;; some might be &REQUIRED; by
   portions of this specification.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="entity-header"/><iref primary="true" item="Grammar" subitem="extension-header"/>
    entity-header  = Allow                    ; &header-allow;
                   | Content-Encoding         ; <xref target="header.content-encoding"/>
                   | Content-Language         ; <xref target="header.content-language"/>
                   | Content-Length           ; &header-content-length;
                   | Content-Location         ; <xref target="header.content-location"/>
                   | Content-MD5              ; <xref target="header.content-md5"/>
                   | Content-Range            ; &header-content-range;
                   | Content-Type             ; <xref target="header.content-type"/>
                   | Expires                  ; &header-expires;
                   | Last-Modified            ; &header-last-modified;
                   | extension-header

    extension-header = message-header
</artwork></figure>
<t>
   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields &SHOULD; be ignored by the recipient and &MUST; be forwarded by
   transparent proxies.
</t>
</section>

<section title="Entity Body" anchor="entity.body">
<t>
   The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="entity-body"/>
    entity-body    = *OCTET
</artwork></figure>
<t>
   An entity-body is only present in a message when a message-body is
   present, as described in &message-body;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.
</t>

<section title="Type" anchor="type">
<t>
   When an entity-body is included with a message, the data type of that
   body is determined via the header fields Content-Type and Content-Encoding.
   These define a two-layer, ordered encoding model:
</t>
<figure><artwork type="example">
    entity-body := Content-Encoding( Content-Type( data ) )
</artwork></figure>
<t>
   Content-Type specifies the media type of the underlying data.
   Content-Encoding may be used to indicate any additional content
   codings applied to the data, usually for the purpose of data
   compression, that are a property of the requested resource. There is
   no default encoding.
</t>
<t>
   Any HTTP/1.1 message containing an entity-body &SHOULD; include a
   Content-Type header field defining the media type of that body. If
   and only if the media type is not given by a Content-Type field, the
   recipient &MAY; attempt to guess the media type via inspection of its
   content and/or the name extension(s) of the URI used to identify the
   resource. If the media type remains unknown, the recipient &SHOULD;
   treat it as type "application/octet-stream".
</t>
</section>
   
<section title="Entity Length" anchor="entity.length">
<t>
   The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &message-length; defines
   how the transfer-length of a message-body is determined.
</t>
</section>
</section>
</section>

<section title="Content Negotiation" anchor="content.negotiation">
<t>
   Most HTTP responses include an entity which contains information for
   interpretation by a human user. Naturally, it is desirable to supply
   the user with the "best available" entity corresponding to the
   request. Unfortunately for servers and caches, not all users have the
   same preferences for what is "best," and not all user agents are
   equally capable of rendering all entity types. For that reason, HTTP
   has provisions for several mechanisms for "content negotiation" --
   the process of selecting the best representation for a given response
   when there are multiple representations available.
  <list><t>
      <x:h>Note:</x:h> This is not called "format negotiation" because the
      alternate representations may be of the same media type, but use
      different capabilities of that type, be in different languages,
      etc.
  </t></list>
</t>
<t>
   Any response containing an entity-body &MAY; be subject to negotiation,
   including error responses.
</t>
<t>
   There are two kinds of content negotiation which are possible in
   HTTP: server-driven and agent-driven negotiation. These two kinds of
   negotiation are orthogonal and thus may be used separately or in
   combination. One method of combination, referred to as transparent
   negotiation, occurs when a cache uses the agent-driven negotiation
   information provided by the origin server in order to provide
   server-driven negotiation for subsequent requests.
</t>

<section title="Server-driven Negotiation" anchor="server-driven.negotiation">
<t>
   If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).
</t>
<t>
   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   "best guess" to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the "best
   guess" is good enough for the user). In order to improve the server's
   guess, the user agent &MAY; include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.
</t>
<t>
   Server-driven negotiation has disadvantages:
  <list style="numbers">
    <t>
         It is impossible for the server to accurately determine what
         might be "best" for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).
    </t>
    <t>
         Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.
    </t>
    <t>
         It complicates the implementation of an origin server and the
         algorithms for generating responses to a request.
    </t>
    <t>
         It may limit a public cache's ability to use the same response
         for multiple user's requests.
    </t>
  </list>
</t>
<t>
   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (<xref target="header.accept"/>), Accept-Charset
   (<xref target="header.accept-charset"/>), Accept-Encoding (<xref target="header.accept-encoding"/>), Accept-Language
   (<xref target="header.accept-language"/>), and User-Agent (&header-user-agent;). However, an
   origin server is not limited to these dimensions and &MAY; vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.
</t>
<t>
   The Vary header field &caching; can be used to express the parameters the
   server uses to select a representation that is subject to server-driven
   negotiation.
</t>
</section>

<section title="Agent-driven Negotiation" anchor="agent-driven.negotiation">
<t>
   With agent-driven negotiation, selection of the best representation
   for a response is performed by the user agent after receiving an
   initial response from the origin server. Selection is based on a list
   of the available representations of the response included within the
   header fields or entity-body of the initial response, with each
   representation identified by its own URI. Selection from among the
   representations may be performed automatically (if the user agent is
   capable of doing so) or manually by the user selecting from a
   generated (possibly hypertext) menu.
</t>
<t>
   Agent-driven negotiation is advantageous when the response would vary
   over commonly-used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.
</t>
<t>
   Agent-driven negotiation suffers from the disadvantage of needing a
   second request to obtain the best alternate representation. This
   second request is only efficient when caching is used. In addition,
   this specification does not define any mechanism for supporting
   automatic selection, though it also does not prevent any such
   mechanism from being developed as an extension and used within
   HTTP/1.1.
</t>
<t>
   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
   status codes for enabling agent-driven negotiation when the server is
   unwilling or unable to provide a varying response using server-driven
   negotiation.
</t>
</section>

<section title="Transparent Negotiation" anchor="transparent.negotiation">
<t>
   Transparent negotiation is a combination of both server-driven and
   agent-driven negotiation. When a cache is supplied with a form of the
   list of available representations of the response (as in agent-driven
   negotiation) and the dimensions of variance are completely understood
   by the cache, then the cache becomes capable of performing server-driven
   negotiation on behalf of the origin server for subsequent
   requests on that resource.
</t>
<t>
   Transparent negotiation has the advantage of distributing the
   negotiation work that would otherwise be required of the origin
   server and also removing the second request delay of agent-driven
   negotiation when the cache is able to correctly guess the right
   response.
</t>
<t>
   This specification does not define any mechanism for transparent
   negotiation, though it also does not prevent any such mechanism from
   being developed as an extension that could be used within HTTP/1.1.
</t>
</section>
</section>
<section title="Header Field Definitions" anchor="header.fields">
<t>
   This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.
</t>
<section title="Accept" anchor="header.accept">
  <iref primary="true" item="Accept header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept" x:for-anchor=""/>
<t>
   The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept"/><iref primary="true" item="Grammar" subitem="media-range"/><iref primary="true" item="Grammar" subitem="accept-params"/><iref primary="true" item="Grammar" subitem="accept-extension"/>
    Accept         = "Accept" ":"
                     #( media-range [ accept-params ] )

    media-range    = ( "*/*"
                     | ( type "/" "*" )
                     | ( type "/" subtype )
                     ) *( ";" parameter )
    accept-params  = ";" "q" "=" qvalue *( accept-extension )
    accept-extension = ";" token [ "=" ( token | quoted-string ) ]
</artwork></figure>
<t>
   The asterisk "*" character is used to group media types into ranges,
   with "*/*" indicating all media types and "type/*" indicating all
   subtypes of that type. The media-range &MAY; include media type
   parameters that are applicable to that range.
</t>
<t>
   Each media-range &MAY; be followed by one or more accept-params,
   beginning with the "q" parameter for indicating a relative quality
   factor. The first "q" parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (<xref target="quality.values"/>). The
   default value is q=1.
  <list><t>
      <x:h>Note:</x:h> Use of the "q" parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      "q" from being used with a media range, such an event is believed
      to be unlikely given the lack of any "q" parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named "q".
  </t></list>
</t>
<t>
   The example
</t>
<figure><artwork type="example">
    Accept: audio/*; q=0.2, audio/basic
</artwork></figure>
<t>
   &SHOULD; be interpreted as "I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality."
</t>
<t>
   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server &SHOULD;
   send a 406 (not acceptable) response.
</t>
<t>
   A more elaborate example is
</t>
<figure><artwork type="example">
    Accept: text/plain; q=0.5, text/html,
            text/x-dvi; q=0.8, text/x-c
</artwork></figure>
<t>
   Verbally, this would be interpreted as "text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity."
</t>
<t>
   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,
</t>
<figure><artwork type="example">
    Accept: text/*, text/html, text/html;level=1, */*
</artwork></figure>
<t>
   have the following precedence:
</t>
<figure><artwork type="example">
    1) text/html;level=1
    2) text/html
    3) text/*
    4) */*
</artwork></figure>
<t>
   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,
</t>
<figure><artwork type="example">
    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
            text/html;level=2;q=0.4, */*;q=0.5
</artwork></figure>
<t>
   would cause the following values to be associated:
</t>
<figure><artwork type="example">
    text/html;level=1         = 1
    text/html                 = 0.7
    text/plain                = 0.3
    image/jpeg                = 0.5
    text/html;level=2         = 0.4
    text/html;level=3         = 0.7
</artwork></figure>
<t>
      <x:h>Note:</x:h> A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.
</t>
</section>

<section title="Accept-Charset" anchor="header.accept-charset">
  <iref primary="true" item="Accept-Charset header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Charset" x:for-anchor=""/>
<t>
   The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-purpose
   character sets to signal that capability to a server which is
   capable of representing documents in those character sets.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Charset"/>
   Accept-Charset = "Accept-Charset" ":"
           1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )
</artwork></figure>
<t>
   Character set values are described in <xref target="character.sets"/>. Each charset &MAY;
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is
</t>
<figure><artwork type="example">
   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</artwork></figure>
<t>
   The special value "*", if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no "*" is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.
</t>
<t>
   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server &SHOULD; send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.
</t>
</section>

<section title="Accept-Encoding" anchor="header.accept-encoding">
  <iref primary="true" item="Accept-Encoding header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Encoding" x:for-anchor=""/>
<t>
   The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (<xref target="content.codings"/>) that are acceptable in
   the response.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Encoding"/><iref primary="true" item="Grammar" subitem="codings"/>
    Accept-Encoding  = "Accept-Encoding" ":"
                       1#( codings [ ";" "q" "=" qvalue ] )
    codings          = ( content-coding | "*" )
</artwork></figure>
<t>
   Examples of its use are:
</t>
<figure><artwork type="example">
    Accept-Encoding: compress, gzip
    Accept-Encoding:
    Accept-Encoding: *
    Accept-Encoding: compress;q=0.5, gzip;q=1.0
    Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</artwork></figure>
<t>
   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:
  <list style="numbers">
      <t>If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in <xref target="quality.values"/>, a
         qvalue of 0 means "not acceptable.")</t>

      <t>The special "*" symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.</t>

      <t>If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.</t>

      <t>The "identity" content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         "identity;q=0", or because the field includes "*;q=0" and does
         not explicitly include the "identity" content-coding. If the
         Accept-Encoding field-value is empty, then only the "identity"
         encoding is acceptable.</t>
  </list>
</t>
<t>
   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server &SHOULD; send an error response
   with the 406 (Not Acceptable) status code.
</t>
<t>
   If no Accept-Encoding field is present in a request, the server &MAY;
   assume that the client will accept any content coding. In this case,
   if "identity" is one of the available content-codings, then the
   server &SHOULD; use the "identity" content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.
  <list><t>
      <x:h>Note:</x:h> If the request does not include an Accept-Encoding field,
      and if the "identity" content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e.,
      "gzip" and "compress") are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.
    </t><t>
      <x:h>Note:</x:h> Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.
    </t></list>
</t>
</section>

<section title="Accept-Language" anchor="header.accept-language">
  <iref primary="true" item="Accept-Language header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Language" x:for-anchor=""/>
<t>
   The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in <xref target="language.tags"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Language"/><iref primary="true" item="Grammar" subitem="language-range"/>
    Accept-Language = "Accept-Language" ":"
                      1#( language-range [ ";" "q" "=" qvalue ] )
    language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
</artwork></figure>
<t>
   Each language-range &MAY; be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to "q=1". For
   example,
</t>
<figure><artwork type="example">
    Accept-Language: da, en-gb;q=0.8, en;q=0.7
</artwork></figure>
<t>
   would mean: "I prefer Danish, but will accept British English and
   other types of English." A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is "-".
   The special range "*", if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.
  <list><t>
      <x:h>Note:</x:h> This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.
  </t></list>
</t>
<t>
   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-range
   in the field that matches the language-tag. If no language-range
   in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server
   &SHOULD; assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.
</t>
<t>
   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   <xref target="privacy.issues.connected.to.accept.headers"/>.
</t>
<t>
   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field &MUST-NOT; be given in
   the request.
  <list><t>
      <x:h>Note:</x:h> When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting "en-gb", they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add "en" to get the
      best matching behavior.
  </t></list>
</t>
</section>

<section title="Content-Encoding" anchor="header.content-encoding">
  <iref primary="true" item="Content-Encoding header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Encoding" x:for-anchor=""/>
<t>
   The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Encoding"/>
    Content-Encoding  = "Content-Encoding" ":" 1#content-coding
</artwork></figure>
<t>
   Content codings are defined in <xref target="content.codings"/>. An example of its use is
</t>
<figure><artwork type="example">
    Content-Encoding: gzip
</artwork></figure>
<t>
   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy &MAY; modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   "no-transform" cache-control directive is present in the message.
</t>
<t>
   If the content-coding of an entity is not "identity", then the
   response &MUST; include a Content-Encoding entity-header (<xref target="header.content-encoding"/>)
   that lists the non-identity content-coding(s) used.
</t>
<t>
   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server &SHOULD; respond with a
   status code of 415 (Unsupported Media Type).
</t>
<t>
   If multiple encodings have been applied to an entity, the content
   codings &MUST; be listed in the order in which they were applied.
   Additional information about the encoding parameters &MAY; be provided
   by other entity-header fields not defined by this specification.
</t>
</section>

<section title="Content-Language" anchor="header.content-language">
  <iref primary="true" item="Content-Language header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Language" x:for-anchor=""/>
<t>
   The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Language"/>
    Content-Language  = "Content-Language" ":" 1#language-tag
</artwork></figure>
<t>
   Language tags are defined in <xref target="language.tags"/>. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is
</t>
<figure><artwork type="example">
    Content-Language: da
</artwork></figure>
<t>
   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.
</t>
<t>
   Multiple languages &MAY; be listed for content that is intended for
   multiple audiences. For example, a rendition of the "Treaty of
   Waitangi," presented simultaneously in the original Maori and English
   versions, would call for
</t>
<figure><artwork type="example">
    Content-Language: mi, en
</artwork></figure>
<t>
   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as "A First
   Lesson in Latin," which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include "en".
</t>
<t>
   Content-Language &MAY; be applied to any media type -- it is not
   limited to textual documents.
</t>
</section>

<section title="Content-Location" anchor="header.content-location">
  <iref primary="true" item="Content-Location header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Location" x:for-anchor=""/>
<t>
   The Content-Location entity-header field &MAY; be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server &SHOULD; provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server &SHOULD; provide a Content-Location
   for the particular variant which is returned.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Location"/>
    Content-Location = "Content-Location" ":"
                      ( absoluteURI | relativeURI )
</artwork></figure>
<t>
   The value of Content-Location also defines the base URI for the
   entity.
</t>
<t>
   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests &MAY; specify the Content-Location URI as the request-URI
   if the desire is to identify the source of that particular
   entity.
</t>
<t>
   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-Location
   can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &caching;.
</t>
<t>
   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.
</t>
<t>
   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.
</t>
</section>

<section title="Content-MD5" anchor="header.content-md5">
  <iref primary="true" item="Content-MD5 header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-MD5" x:for-anchor=""/>
<t>
   The Content-MD5 entity-header field, as defined in RFC 1864 <xref target="RFC1864"/>, is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-MD5"/><iref primary="true" item="Grammar" subitem="md5-digest"/>
     Content-MD5   = "Content-MD5" ":" md5-digest
     md5-digest   = &lt;base64 of 128 bit MD5 digest as per RFC 1864&gt;
</artwork></figure>
<t>
   The Content-MD5 header field &MAY; be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients &MAY; generate the Content-MD5 header field;
   proxies and gateways &MUST-NOT; generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-body,
   including gateways and proxies, &MAY; check that the digest value
   in this header field matches that of the entity-body as received.
</t>
<t>
   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding &MUST; be removed
   prior to checking the Content-MD5 value against the received entity.
</t>
<t>
   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.
</t>
<t>
   HTTP extends RFC 1864 to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.
</t>
<t>
   There are several consequences of this. The entity-body for composite
   types &MAY; contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-Encoding
   or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.
</t>
<t>
   Conversion of all line breaks to CRLF &MUST-NOT; be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted &MUST; be left unaltered when computing
   the digest.
  <list><t>
      <x:h>Note:</x:h> while the definition of Content-MD5 is exactly the same for
      HTTP as in RFC 1864 for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.
  </t></list>
</t>
</section>

<section title="Content-Type" anchor="header.content-type">
  <iref primary="true" item="Content-Type header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Type" x:for-anchor=""/>
<t>
   The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Type"/>
    Content-Type   = "Content-Type" ":" media-type
</artwork></figure>
<t>
   Media types are defined in <xref target="media.types"/>. An example of the field is
</t>
<figure><artwork type="example">
    Content-Type: text/html; charset=ISO-8859-4
</artwork></figure>
<t>
   Further discussion of methods for identifying the media type of an
   entity is provided in <xref target="type"/>.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="IANA.considerations">
<t>
   TBD.
</t>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.
</t>

<section title="Privacy Issues Connected to Accept Headers" anchor="privacy.issues.connected.to.accept.headers">
<t>
   Accept request-headers can reveal information about the user to all
   servers which are accessed. The Accept-Language header in particular
   can reveal information the user would consider to be of a private
   nature, because the understanding of particular languages is often
   strongly correlated to the membership of a particular ethnic group.
   User agents which offer the option to configure the contents of an
   Accept-Language header to be sent in every request are strongly
   encouraged to let the configuration process include a message which
   makes the user aware of the loss of privacy involved.
</t>
<t>
   An approach that limits the loss of privacy would be for a user agent
   to omit the sending of Accept-Language headers by default, and to ask
   the user whether or not to start sending Accept-Language headers to a
   server if it detects, by looking for any Vary response-header fields
   generated by the server, that such sending could improve the quality
   of service.
</t>
<t>
   Elaborate user-customized accept header fields sent in every request,
   in particular if these include quality values, can be used by servers
   as relatively reliable and long-lived user identifiers. Such user
   identifiers would allow content providers to do click-trail tracking,
   and would allow collaborating content providers to match cross-server
   click-trails or form submissions of individual users. Note that for
   many users not behind a proxy, the network address of the host
   running the user agent will also serve as a long-lived user
   identifier. In environments where proxies are used to enhance
   privacy, user agents ought to be conservative in offering accept
   header configuration options to end users. As an extreme privacy
   measure, proxies could filter the accept headers in relayed requests.
   General purpose user agents which provide a high degree of header
   configurability &SHOULD; warn users about the loss of privacy which can
   be involved.
</t>
</section>

<section title="Content-Disposition Issues" anchor="content-disposition.issues">
<t>
   RFC 1806 <xref target="RFC1806"/>, from which the often implemented Content-Disposition
   (see <xref target="content-disposition"/>) header in HTTP is derived, has a number of very
   serious security considerations. Content-Disposition is not part of
   the HTTP standard, but since it is widely implemented, we are
   documenting its use and risks for implementors. See RFC 2183 <xref target="RFC2183"/>
   (which updates RFC 1806) for details.
</t>
</section>

</section>

<section title="Acknowledgments" anchor="ack">
<t>
   Based on an XML translation of RFC 2616 by Julian Reschke.
</t>
</section>
</middle>
<back>
<references>

<reference anchor="Part1">
   <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization abbrev="Day Software">Day Software</organization>
         <address><email>fielding@gbiv.com</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="Jim Gettys">
         <organization>One Laptop per Child</organization>
         <address><email>jg@laptop.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
         <organization abbrev="HP">Hewlett-Packard Company</organization>
         <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="Larry Masinter">
         <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
         <address><email>LMM@acm.org</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="Paul J. Leach">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
         <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;"/>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
   <x:source href="p1-messaging.xml" basename="p1-messaging"/>
</reference>

<reference anchor="Part2">
   <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization abbrev="Day Software">Day Software</organization>
         <address><email>fielding@gbiv.com</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="Jim Gettys">
         <organization>One Laptop per Child</organization>
         <address><email>jg@laptop.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
         <organization abbrev="HP">Hewlett-Packard Company</organization>
         <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="Larry Masinter">
         <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
         <address><email>LMM@acm.org</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="Paul J. Leach">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
         <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;"/>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
   <x:source href="p2-semantics.xml" basename="p2-semantics"/>
</reference>

<reference anchor="Part4">
   <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 4: Conditional Requests</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization abbrev="Day Software">Day Software</organization>
         <address><email>fielding@gbiv.com</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="Jim Gettys">
         <organization>One Laptop per Child</organization>
         <address><email>jg@laptop.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
         <organization abbrev="HP">Hewlett-Packard Company</organization>
         <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="Larry Masinter">
         <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
         <address><email>LMM@acm.org</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="Paul J. Leach">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
         <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;"/>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"/>
   <x:source href="p4-conditional.xml" basename="p4-conditional"/>
</reference>

<reference anchor="Part5">
   <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization abbrev="Day Software">Day Software</organization>
         <address><email>fielding@gbiv.com</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="Jim Gettys">
         <organization>One Laptop per Child</organization>
         <address><email>jg@laptop.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
         <organization abbrev="HP">Hewlett-Packard Company</organization>
         <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="Larry Masinter">
         <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
         <address><email>LMM@acm.org</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="Paul J. Leach">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
         <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;"/>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
   <x:source href="p5-range.xml" basename="p5-range"/>
</reference>

<reference anchor="Part6">
   <front>
      <title abbrev="HTTP/1.1">HTTP/1.1, part 6: Caching</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization abbrev="Day Software">Day Software</organization>
         <address><email>fielding@gbiv.com</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="Jim Gettys">
         <organization>One Laptop per Child</organization>
         <address><email>jg@laptop.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
         <organization abbrev="HP">Hewlett-Packard Company</organization>
         <address><email>JeffMogul@acm.org</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>henrikn@microsoft.com</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="Larry Masinter">
         <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
         <address><email>LMM@acm.org</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="Paul J. Leach">
         <organization abbrev="Microsoft">Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
         <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="&ID-MONTH;" year="&ID-YEAR;"/>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
   <x:source href="p6-cache.xml" basename="p6-cache"/>
</reference>

<reference anchor="RFC2616">
   <front>
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
      <author initials="R." surname="Fielding" fullname="R. Fielding">
         <organization>University of California, Irvine</organization>
         <address><email>fielding@ics.uci.edu</email></address>
      </author>
      <author initials="J." surname="Gettys" fullname="J. Gettys">
         <organization>W3C</organization>
         <address><email>jg@w3.org</email></address>
      </author>
      <author initials="J." surname="Mogul" fullname="J. Mogul">
         <organization>Compaq Computer Corporation</organization>
         <address><email>mogul@wrl.dec.com</email></address>
      </author>
      <author initials="H." surname="Frystyk" fullname="H. Frystyk">
         <organization>MIT Laboratory for Computer Science</organization>
         <address><email>frystyk@w3.org</email></address>
      </author>
      <author initials="L." surname="Masinter" fullname="L. Masinter">
         <organization>Xerox Corporation</organization>
         <address><email>masinter@parc.xerox.com</email></address>
      </author>
      <author initials="P." surname="Leach" fullname="P. Leach">
         <organization>Microsoft Corporation</organization>
         <address><email>paulle@microsoft.com</email></address>
      </author>
      <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
         <organization>W3C</organization>
         <address><email>timbl@w3.org</email></address>
      </author>
      <date month="June" year="1999"/>
   </front>
   <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor="RFC1766">
<front>
<title abbrev="Language Tag">Tags for the Identification of Languages</title>
<author initials="H." surname="Alvestrand" fullname="Harald Tveit Alvestrand">
<organization>UNINETT</organization>
<address>
<postal>
<street>Pb. 6883 Elgeseter</street>
<city>Trondheim</city>
<region/>
<code>N-7002</code>
<country>NO</country></postal>
<phone>+47 73 597094</phone>
<email>Harald.T.Alvestrand@uninett.no</email></address></author>
<date month="March" year="1995"/>
</front>
<seriesInfo name="RFC" value="1766"/>
</reference>

<reference anchor="RFC2045">
<front>
<title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
<author initials="N." surname="Freed" fullname="Ned Freed">
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date month="November" year="1996"/>
</front>
<seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC822">
<front>
<title abbrev="Standard for ARPA Internet Text Messages">Standard for the format of ARPA Internet text messages</title>
<author initials="D.H." surname="Crocker" fullname="David H. Crocker">
<organization>University of Delaware, Dept. of Electrical Engineering</organization>
<address>
<postal>
<street/>
<city>Newark</city>
<region>DE</region>
<code>19711</code>
<country>US</country></postal>
<email>DCrocker@UDel-Relay</email></address></author>
<date month="August" day="13" year="1982"/></front>
<seriesInfo name="STD" value="11"/>
<seriesInfo name="RFC" value="822"/>
</reference>

<reference anchor="RFC1867">
<front>
<title>Form-based File Upload in HTML</title>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization>Xerox Palo Alto Research Center</organization>
<address>
<postal>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94304</code>
<country>US</country></postal>
<phone>+1 415 812 4365</phone>
<facsimile>+1 415 812 4333</facsimile>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="E." surname="Nebel" fullname="Ernesto Nebel">
<organization>XSoft, Xerox Corporation</organization>
<address>
<postal>
<street>10875 Rancho Bernardo Road</street>
<street>Suite 200</street>
<city>San Diego</city>
<region>CA</region>
<code>92127-2116</code>
<country>US</country></postal>
<phone>+1 619 676 7817</phone>
<facsimile>+1 619 676 7865</facsimile>
<email>nebel@xsoft.sd.xerox.com</email></address></author>
<date month="November" year="1995"/>
</front>
<seriesInfo name="RFC" value="1867"/>
</reference>

<reference anchor="RFC4288">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="N. Freed">
      <organization>Sun Microsystems</organization>
      <address>
        <email>ned.freed@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="J. Klensin">
      <organization/>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <date year="2005" month="December"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="4288"/>
</reference>

<reference anchor="RFC1864">
<front>
<title abbrev="Content-MD5 Header Field">The Content-MD5 Header Field</title>
<author initials="J." surname="Myers" fullname="John G. Myers">
<organization>Carnegie Mellon University</organization>
<address>
<phone/>
<email>jgm+@cmu.edu</email></address></author>
<author initials="M." surname="Rose" fullname="Marshall T. Rose">
<organization>Dover Beach Consulting, Inc.</organization>
<address>
<phone/>
<email>mrose@dbc.mtview.ca.us</email></address></author>
<date month="October" year="1995"/>
</front>
<seriesInfo name="RFC" value="1864"/>
</reference>


<reference anchor="RFC1952">
<front>
<title>GZIP file format specification version 4.3</title>
<author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
<organization>Aladdin Enterprises</organization>
<address>
<postal>
<street>203 Santa Margarita Ave.</street>
<city>Menlo Park</city>
<region>CA</region>
<code>94025</code>
<country>US</country></postal>
<phone>+1 415 322 0103</phone>
<facsimile>+1 415 322 1734</facsimile>
<email>ghost@aladdin.com</email></address></author>
<author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
<organization/>
<address>
<postal>
<street/>
<city/>
<region/>
<code/>
<country/></postal>
<phone/>
<email>gzip@prep.ai.mit.edu</email></address></author>
<author initials="M." surname="Adler" fullname="Mark Adler">
<organization/>
<address>
<postal>
<street/>
<city/>
<region/>
<code/>
<country/></postal>
<phone/>
<email>madler@alumni.caltech.edu</email></address></author>
<author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
<organization/>
<address>
<postal>
<street/>
<city/>
<region/>
<code/>
<country/></postal>
<phone/>
<email>ghost@aladdin.com</email></address></author>
<author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
<organization/>
<address>
<postal>
<street/>
<city/>
<region/>
<code/>
<country/></postal>
<phone/>
<email>randeg@alumni.rpi.edu</email></address></author>
<date month="May" year="1996"/>
</front>
<seriesInfo name="RFC" value="1952"/>
</reference>

<reference anchor="RFC1951">
<front>
<title>DEFLATE Compressed Data Format Specification version 1.3</title>
<author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
<organization>Aladdin Enterprises</organization>
<address>
<postal>
<street>203 Santa Margarita Ave.</street>
<city>Menlo Park</city>
<region>CA</region>
<code>94025</code>
<country>US</country></postal>
<phone>+1 415 322 0103</phone>
<facsimile>+1 415 322 1734</facsimile>
<email>ghost@aladdin.com</email></address></author>
<date month="May" year="1996"/>
<abstract>
<t>This specification defines a lossless compressed data format that compresses data using a combination of the LZ77 algorithm and Huffman coding, with efficiency comparable to the best currently available general-purpose compression methods.  The data can be produced or consumed, even for an arbitrarily long sequentially presented input data stream, using only an a priori bounded amount of intermediate storage.  The format can be implemented readily in a manner not covered by patents.</t></abstract></front>
<seriesInfo name="RFC" value="1951"/>
</reference>

<reference anchor="RFC1950">
<front>
<title>ZLIB Compressed Data Format Specification version 3.3</title>
<author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
<organization>Aladdin Enterprises</organization>
<address>
<postal>
<street>203 Santa Margarita Ave.</street>
<city>Menlo Park</city>
<region>CA</region>
<code>94025</code>
<country>US</country></postal>
<phone>+1 415 322 0103</phone>
<facsimile>+1 415 322 1734</facsimile>
<email>ghost@aladdin.com</email></address></author>
<author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
<organization/></author>
<date month="May" year="1996"/>
<abstract>
<t>This specification defines a lossless compressed data format.  The data can be produced or consumed, even for an arbitrarily long sequentially presented input data stream, using only an a priori bounded amount of intermediate storage.  The format presently uses the DEFLATE compression method but can be easily extended to use
   other compression methods.  It can be implemented readily in a manner not covered by patents.  This specification also defines the ADLER-32 checksum (an extension and improvement of the Fletcher checksum), used for detection of data corruption, and provides an algorithm for computing it.</t></abstract></front>
<seriesInfo name="RFC" value="1950"/>
</reference>

<reference anchor="RFC2068">
<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization>University of California, Irvine, Department of Information and Computer Science</organization>
<address>
<postal>
<street/>
<city>Irvine</city>
<region>CA</region>
<code>92717-3425</code>
<country>US</country></postal>
<facsimile>+1 714 824 4056</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="Jim Gettys">
<organization>MIT Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization>Digital Equipment Corporation, Western Research Laboratory</organization>
<address>
<postal>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94301</code>
<country>US</country></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
<organization>MIT Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization>MIT Laboratory for Computer Science</organization>
<address>
<postal>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>US</country></postal>
<facsimile>+1 617 258 8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date month="January" year="1997"/>
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, object-oriented protocol which can be used for many tasks, such as name servers and distributed object management systems, through extension of its request methods. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.</t>
<t>HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol referred to as "HTTP/1.1".</t></abstract></front>
<seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor="RFC1806">
<front>
<title abbrev="Content-Disposition">Communicating Presentation Information in Internet Messages: The Content-Disposition Header</title>
<author initials="R." surname="Troost" fullname="Rens Troost">
<organization>New Century Systems</organization>
<address>
<postal>
<street>324 East 41st Street #804</street>
<city>New York</city>
<region>NY</region>
<code>10017</code>
<country>US</country></postal>
<phone>+1 212 557 2050</phone>
<facsimile>+1 212 557 2049</facsimile>
<email>rens@century.com</email></address></author>
<author initials="S." surname="Dorner" fullname="Steve Dorner">
<organization>QUALCOMM Incorporated</organization>
<address>
<postal>
<street>6455 Lusk Boulevard</street>
<city>San Diego</city>
<region>CA</region>
<code>92121</code>
<country>US</country></postal>
<email>sdorner@qualcomm.com</email></address></author>
<date month="June" year="1995"/>
<abstract>
<t>This memo provides a mechanism whereby messages conforming to the("MIME") specification can convey presentational information.  It specifies a new "Content-Disposition" header, optional and valid for anyentity ("message" or "body part"). Two values for this header are described in this memo; one for the ordinary linear presentation of the body part, and another to facilitate the use of mail to transfer files. It is expected that more values will be defined in the future, and procedures are defined for extending this set of values.</t>
<t>This document is intended as an extension to. As such, the reader is assumed to be familiar with, and. The information presented herein supplements but does not replace that found in those documents.</t></abstract></front>
<seriesInfo name="RFC" value="1806"/>
</reference>

<reference anchor="RFC2076">
<front>
<title abbrev="Internet Message Headers">Common Internet Message Headers</title>
<author initials="J." surname="Palme" fullname="Jacob Palme">
<organization>Stockholm University/KTH</organization>
<address>
<postal>
<street>Electrum 230</street>
<street>S-164 40 Kista</street>
<country>SE</country></postal>
<phone>+46 8 161667</phone>
<facsimile>+46 8 7830829</facsimile>
<email>jpalme@dsv.su.se</email></address></author>
<date month="February" year="1997"/>
<abstract>
<t>This memo contains a table of commonly occurring headers in headings of e-mail messages. The document compiles information from other RFCs such as RFC 822, RFC 1036, RFC 1123, RFC 1327, RFC 1496, RFC 1521, RFC 1766, RFC 1806, RFC 1864 and RFC 1911. A few commonly occurring headers which are not defined in RFCs are also included. For each header, the memo gives a short description and a reference to the RFC in which the header is defined.</t></abstract></front>
<seriesInfo name="RFC" value="2076"/>
</reference>

<reference anchor="RFC2279">
<front>
<title abbrev="UTF-8">UTF-8, a transformation format of ISO 10646</title>
<author initials="F." surname="Yergeau" fullname="Francois Yergeau">
<organization>Alis Technologies</organization>
<address>
<postal>
<street>100, boul. Alexis-Nihon</street>
<street>Suite 600</street>
<city>Montreal</city>
<region>Quebec</region>
<code>H4M 2P2</code>
<country>CA</country></postal>
<phone>+1 514 747 2547</phone>
<facsimile>+1 514 747 2561</facsimile>
<email>fyergeau@alis.com</email></address></author>
<date month="January" year="1998"/>
<abstract>
<t>ISO/IEC 10646-1 defines a multi-octet character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems. Multi-octet characters, however, are not compatible with many current applications and protocols, and this has led to the development of a few so-called UCS transformation formats (UTF), each with different characteristics.  UTF-8, the object of this memo, has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values. This memo updates and replaces RFC 2044, in particular addressing the question of versions of the relevant standards.</t></abstract></front>
<seriesInfo name="RFC" value="2279"/>
</reference>

<reference anchor="RFC2046">
<front>
<title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
<author initials="N." surname="Freed" fullname="Ned Freed">
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date month="November" year="1996"/>
</front>
<seriesInfo name="RFC" value="2046"/>
</reference>

<reference anchor="RFC2277">
<front>
<title abbrev="Charset Policy">IETF Policy on Character Sets and Languages</title>
<author initials="H.T." surname="Alvestrand" fullname="Harald Tveit Alvestrand">
<organization>UNINETT</organization>
<address>
<postal>
<street>P.O.Box 6883 Elgeseter</street>
<street>N-7002 TRONDHEIM</street>
<country>NORWAY</country></postal>
<phone>+47 73 59 70 94</phone>
<email>Harald.T.Alvestrand@uninett.no</email></address></author>
<date month="January" year="1998"/>
<area>Applications</area>
<keyword>Internet Engineering Task Force</keyword>
<keyword>character encoding</keyword></front>
<seriesInfo name="BCP" value="18"/>
<seriesInfo name="RFC" value="2277"/>
</reference>

<reference anchor="RFC2110">
<front>
<title abbrev="MHTML">MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)</title>
<author initials="J." surname="Palme" fullname="Jacob Palme">
<organization>Stockholm University and KTH</organization>
<address>
<postal>
<street>Electrum 230</street>
<street>S-164 40 Kista</street>
<country>Sweden</country></postal>
<phone>+46-8-16 16 67</phone>
<facsimile>+46-8-783 08 29</facsimile>
<email>jpalme@dsv.su.se</email></address></author>
<author initials="A." surname="Hopmann" fullname="Alex Hopmann">
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>3590 North First Street</street>
<street>Suite 300</street>
<street>San Jose</street>
<street>CA 95134</street>
<street>Working group chairman:</street></postal>
<email>alexhop@microsoft.com</email></address></author>
<date month="March" year="1997"/>
<area>Applications</area>
<keyword>encapsulate</keyword>
<keyword>hypertext markup language</keyword>
<keyword>mail</keyword>
<keyword>multipurpose internet mail extensions</keyword>
</front>
<seriesInfo name="RFC" value="2110"/>
</reference>

<reference anchor="RFC2049">
<front>
<title abbrev="MIME Conformance">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</title>
<author initials="N." surname="Freed" fullname="Ned Freed">
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<street>West Covina</street>
<street>CA 91790</street>
<country>USA</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<street>Morristown</street>
<street>NJ 07960</street>
<country>USA</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date month="November" year="1996"/>
<area>Applications</area>
<keyword>mail</keyword>
<keyword>multipurpose internet mail extensions</keyword>
</front>
<seriesInfo name="RFC" value="2049"/>
</reference>

<reference anchor="RFC2183">
<front>
<title abbrev="Content-Disposition">Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</title>
<author initials="R." surname="Troost" fullname="Rens Troost">
<organization>New Century Systems</organization>
<address>
<postal>
<street>324 East 41st Street #804</street>
<street>New York</street>
<street>NY</street>
<street>10017</street>
<country>USA</country></postal>
<phone>+1 (212) 557-2050</phone>
<facsimile>+1 (212) 557-2049</facsimile>
<email>rens@century.com</email></address></author>
<author initials="S." surname="Dorner" fullname="Steve Dorner">
<organization>QUALCOMM Incorporated</organization>
<address>
<postal>
<street>6455 Lusk Boulevard</street>
<street>San Diego</street>
<street>CA 92121</street>
<country>USA</country></postal>
<email>sdorner@qualcomm.com</email></address></author>
<author initials="K." surname="Moore" fullname="Keith Moore">
<organization>Department of Computer Science</organization>
<address>
<postal>
<street>University of Tennessee</street>
<street>Knoxville</street>
<street>107 Ayres Hall</street>
<street>Knoxville TN  37996-1301</street>
<country>USA</country></postal>
<phone>+1 (423) 974-5067</phone>
<facsimile>+1 (423) 974-8296</facsimile>
<email>moore@cs.utk.edu</email></address></author>
<date month="August" year="1997"/>
<area>Applications</area>
<keyword>MIME</keyword>
<keyword>internet message</keyword>
<keyword>multipurpose internet mail extensions</keyword>
</front>
<seriesInfo name="RFC" value="2183"/>
</reference>

</references>

<section title="Differences Between HTTP Entities and RFC 2045 Entities" anchor="differences.between.http.entities.and.rfc.2045.entities">
<t>
   HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC
   822 <xref target="RFC822"/>) and the Multipurpose Internet Mail Extensions (MIME <xref target="RFC2045"/>) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, RFC 2045
   discusses mail, and HTTP has a few features that are different from
   those described in RFC 2045. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.
</t>
<t>
   This appendix describes specific areas where HTTP differs from RFC
   2045. Proxies and gateways to strict MIME environments &SHOULD; be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.
</t>
<section title="MIME-Version" anchor="mime-version">
<t>
   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages &MAY;
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in RFC 2045<xref target="RFC2045"/>).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="MIME-Version"/>
    MIME-Version   = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
</artwork></figure>
<t>
   MIME version "1.0" is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.
</t>
</section>

<section title="Conversion to Canonical Form" anchor="conversion.to.canonical.form">
<t>
   RFC 2045 <xref target="RFC2045"/> requires that an Internet mail entity be converted to
   canonical form prior to being transferred, as described in section <xref target="RFC2049" x:fmt="number" x:sec="4"/>
   of RFC 2049 <xref target="RFC2049"/>. <xref target="canonicalization.and.text.defaults"/> of this document describes the forms
   allowed for subtypes of the "text" media type when transmitted over
   HTTP. RFC 2046 requires that content with a type of "text" represent
   line breaks as CRLF and forbids the use of CR or LF outside of line
   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a
   line break within text content when a message is transmitted over
   HTTP.
</t>
<t>
   Where it is possible, a proxy or gateway from HTTP to a strict MIME
   environment &SHOULD; translate all line breaks within the text media
   types described in <xref target="canonicalization.and.text.defaults"/> of this document to the RFC 2049
   canonical form of CRLF. Note, however, that this might be complicated
   by the presence of a Content-Encoding and by the fact that HTTP
   allows the use of some character sets which do not use octets 13 and
   10 to represent CR and LF, as is the case for some multi-byte
   character sets.
</t>
<t>
   Implementors should note that conversion will break any cryptographic
   checksums applied to the original content unless the original content
   is already in canonical form. Therefore, the canonical form is
   recommended for any content that uses such checksums in HTTP.
</t>
</section>

<section title="Introduction of Content-Encoding" anchor="introduction.of.content-encoding">
<t>
   RFC 2045 does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field. Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols &MUST; either change the value of the Content-Type header
   field or decode the entity-body before forwarding the message. (Some
   experimental applications of Content-Type for Internet mail have used
   a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform
   a function equivalent to Content-Encoding. However, this parameter is
   not part of RFC 2045).
</t>
</section>

<section title="No Content-Transfer-Encoding" anchor="no.content-transfer-encoding">
<t>
   HTTP does not use the Content-Transfer-Encoding field of RFC
   2045. Proxies and gateways from MIME-compliant protocols to HTTP &MUST;
   remove any Content-Transfer-Encoding
   prior to delivering the response message to an HTTP client.
</t>
<t>
   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used.
   Such a proxy or gateway &SHOULD; label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.
</t>
</section>

<section title="Introduction of Transfer-Encoding" anchor="introduction.of.transfer-encoding">
<t>
   HTTP/1.1 introduces the Transfer-Encoding header field (&header-transfer-encoding;).
   Proxies/gateways &MUST; remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.
</t>
</section>

<section title="MHTML and Line Length Limitations" anchor="mhtml.line.length">
<t>
   HTTP implementations which share code with MHTML <xref target="RFC2110"/> implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see <xref target="multipart.types"/>) and
   does not interpret the content or any MIME header lines that might be
   contained therein.
</t>
</section>
</section>

<section title="Additional Features" anchor="additional.features">
<t>
   RFC 1945 and RFC 2068 document protocol elements used by some
   existing HTTP implementations, but not consistently and correctly
   across most HTTP/1.1 applications. Implementors are advised to be
   aware of these features, but cannot rely upon their presence in, or
   interoperability with, other HTTP/1.1 applications. Some of these
   describe proposed experimental features, and some describe features
   that experimental deployment found lacking that are now addressed in
   the base HTTP/1.1 specification.
</t>
<t>
   A number of other headers, such as Content-Disposition and Title,
   from SMTP and MIME are also often implemented (see RFC 2076 <xref target="RFC2076"/>).
</t>

<section title="Content-Disposition" anchor="content-disposition">
<iref item="Headers" subitem="Content-Disposition" primary="true" x:for-anchor=""/>
<iref item="Content-Disposition header" primary="true" x:for-anchor=""/>
<t>
   The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in RFC 1806 <xref target="RFC1806"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="content-disposition"/><iref primary="true" item="Grammar" subitem="disposition-type"/><iref primary="true" item="Grammar" subitem="disposition-parm"/><iref primary="true" item="Grammar" subitem="filename-parm"/><iref primary="true" item="Grammar" subitem="disp-extension-token"/><iref primary="true" item="Grammar" subitem="disp-extension-parm"/>
     content-disposition = "Content-Disposition" ":"
                           disposition-type *( ";" disposition-parm )
     disposition-type = "attachment" | disp-extension-token
     disposition-parm = filename-parm | disp-extension-parm
     filename-parm = "filename" "=" quoted-string
     disp-extension-token = token
     disp-extension-parm = token "=" ( token | quoted-string )
</artwork></figure>
<t>
   An example is
</t>
<figure><artwork type="example">
     Content-Disposition: attachment; filename="fname.ext"
</artwork></figure>
<t>
   The receiving user agent &SHOULD-NOT;  respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename &SHOULD; be treated as a terminal component only.
</t>
<t>
   If this header is used in a response with the application/octet-stream
   content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.
</t>
<t>
   See <xref target="content-disposition.issues"/> for Content-Disposition security issues.
</t>
</section>
</section>

<section title="Changes from RFC 2068" anchor="changes.from.rfc.2068">
<t>
   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (<xref target="header.accept-charset"/>)
</t>
<t>
   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML <xref target="RFC2110"/>.
</t>
<t>
   A content-coding of "identity" was introduced, to solve problems
   discovered in caching. (<xref target="content.codings"/>)
</t>
<t>
   Quality Values of zero should indicate that "I don't want something"
   to allow clients to refuse a representation. (<xref target="quality.values"/>)
</t>
<t>
   The Alternates<iref item="Alternates header" primary="true"/><iref item="Headers" subitem="Alternate" primary="true"/>, Content-Version<iref item="Content-Version header" primary="true"/><iref item="Headers" subitem="Content-Version" primary="true"/>, Derived-From<iref item="Derived-From header" primary="true"/><iref item="Headers" subitem="Derived-From" primary="true"/>, Link<iref item="Link header" primary="true"/><iref item="Headers" subitem="Link" primary="true"/>, URI<iref item="URI header" primary="true"/><iref item="Headers" subitem="URI" primary="true"/>, Public<iref item="Public header" primary="true"/><iref item="Headers" subitem="Public" primary="true"/> and
   Content-Base<iref item="Content-Base header" primary="true"/><iref item="Headers" subitem="Content-Base" primary="true"/> header fields were defined in previous versions of this
   specification, but not commonly implemented. See RFC 2068 <xref target="RFC2068"/>.
</t>
</section>
</back>
</rfc>
