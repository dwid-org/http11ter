<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "October">
  <!ENTITY ID-YEAR "2010">
  <!ENTITY notation                 "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation-abnf            "<xref target='Part1' x:rel='#notation.abnf' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules              "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching-neg-resp         "<xref target='Part6' x:rel='#caching.negotiated.responses' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-transfer-encoding "<xref target='Part1' x:rel='#header.transfer-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-length    "<xref target='Part1' x:rel='#header.content-length' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-range     "<xref target='Part5' x:rel='#header.content-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expires           "<xref target='Part6' x:rel='#header.expires' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified     "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-user-agent        "<xref target='Part2' x:rel='#header.user-agent' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-vary              "<xref target='Part6' x:rel='#header.vary' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY message-body             "<xref target='Part1' x:rel='#message.body' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY multipart-byteranges     "<xref target='Part5' x:rel='#internet.media.type.multipart.byteranges' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY full-date                "<xref target='Part1' x:rel='#date.time.formats.full.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY qvalue                   "<xref target='Part1' x:rel='#quality.values' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY uri                      "<xref target='Part1' x:rel='#uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY effective-request-uri    "<xref target='Part1' x:rel='#effective.request.uri' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY compression-codings      "<xref target='Part1' x:rel='#compression.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transfer-codings         "<xref target='Part1' x:rel='#transfer.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY compress-coding          "<xref target='Part1' x:rel='#compress.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY deflate-coding           "<xref target='Part1' x:rel='#deflate.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY gzip-coding              "<xref target='Part1' x:rel='#gzip.coding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY response-representation  "<xref target='Part2' x:rel='#identifying.response.associated.with.representation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="draft"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p3-payload-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<front>

  <title abbrev="HTTP/1.1, Part 3">HTTP/1.1, part 3: Message Payload and Content Negotiation</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <postal>
        <street>23 Corporate Plaza DR, Suite 280</street>
        <city>Newport Beach</city>
        <region>CA</region>
        <code>92660</code>
        <country>USA</country>
      </postal>
      <phone>+1-949-706-5300</phone>
      <facsimile>+1-949-706-5305</facsimile>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@freedesktop.org</email>
      <uri>http://gettys.wordpress.com/</uri>
    </address>
  </author>
  
  <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author initials="L." surname="Masinter" fullname="Larry Masinter">
    <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  
  <author initials="P." surname="Leach" fullname="Paul J. Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>
   
  <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>
      <facsimile>+49 251 2807761</facsimile>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World Wide Web global information
   initiative since 1990. This document is Part 3 of the seven-part specification
   that defines the protocol referred to as "HTTP/1.1" and, taken together,
   obsoletes RFC 2616.  Part 3 defines HTTP message content,
   metadata, and content negotiation.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org). The current issues list is
    at <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/>
    and related documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.11"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   This document defines HTTP/1.1 message payloads (a.k.a., content), the
   associated metadata header fields that define how the payload is intended
   to be interpreted by a recipient, the request header fields that
   might influence content selection, and the various selection algorithms
   that are collectively referred to as HTTP content negotiation.
</t>
<t>
   This document is currently disorganized in order to minimize the changes
   between drafts and enable reviewers to see the smaller errata changes.
   A future draft will reorganize the sections to better reflect the content.
   In particular, the sections on entities will be renamed payload and moved
   to the first half of the document, while the sections on content negotiation
   and associated request header fields will be moved to the second half.  The
   current mess reflects how widely dispersed these topics and associated
   requirements had become in <xref target="RFC2616"/>.
</t>

<section title="Terminology" anchor="terminology">
<t>
   This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.
</t>
<t>
  <iref item="content negotiation"/>
  <x:dfn>content negotiation</x:dfn>
  <list>
    <t>
      The mechanism for selecting the appropriate representation when
      servicing a request. The representation in any response
      can be negotiated (including error responses).
    </t>
  </list>
</t>
</section>

<section title="Requirements" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   An implementation is not compliant if it fails to satisfy one or more
   of the "MUST" or "REQUIRED" level requirements for the protocols it
   implements. An implementation that satisfies all the "MUST" or "REQUIRED"
   level and all the "SHOULD" level requirements for its protocols is said
   to be "unconditionally compliant"; one that satisfies all the "MUST"
   level requirements but not all the "SHOULD" level requirements for its
   protocols is said to be "conditionally compliant".
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="WSP"/>
<t>
  This specification uses the ABNF syntax defined in &notation; (which
  extends the syntax defined in <xref target="RFC5234"/> with a list rule).
  <xref target="collected.abnf"/> shows the collected ABNF, with the list
  rule expanded.
</t>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space),
  VCHAR (any visible USASCII character),
  and WSP (whitespace).
</t>

<section title="Core Rules" anchor="core.rules">
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="word"/>
  <x:anchor-alias value="OWS"/>
<t>
  The core rules below are defined in &basic-rules;:
</t>
<figure><artwork type="abnf2616">
  <x:ref>token</x:ref>          = &lt;token, defined in &basic-rules;&gt;
  <x:ref>word</x:ref>           = &lt;word, defined in &basic-rules;&gt;
  <x:ref>OWS</x:ref>            = &lt;OWS, defined in &basic-rules;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification" anchor="abnf.dependencies">
  <x:anchor-alias value="absolute-URI"/>
  <x:anchor-alias value="Allow"/>
  <x:anchor-alias value="Content-Length"/>
  <x:anchor-alias value="Content-Range"/>
  <x:anchor-alias value="Expires"/>
  <x:anchor-alias value="Last-Modified"/>
  <x:anchor-alias value="partial-URI"/>
  <x:anchor-alias value="qvalue"/>
<t>
  The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part1--><artwork type="abnf2616">
  <x:ref>absolute-URI</x:ref>   = &lt;absolute-URI, defined in &uri;&gt;
  <x:ref>Content-Length</x:ref> = &lt;Content-Length, defined in &header-content-length;&gt;
  <x:ref>partial-URI</x:ref>    = &lt;partial-URI, defined in &uri;&gt;
  <x:ref>qvalue</x:ref>         = &lt;qvalue, defined in &qvalue;&gt;
</artwork></figure>
<figure><!--Part4--><artwork type="abnf2616">
  <x:ref>Last-Modified</x:ref>  = &lt;Last-Modified, defined in &header-last-modified;&gt;
</artwork></figure>
<figure><!--Part5--><artwork type="abnf2616">
  <x:ref>Content-Range</x:ref>  = &lt;Content-Range, defined in &header-content-range;&gt;
</artwork></figure>
<figure><!--Part6--><artwork type="abnf2616">
  <x:ref>Expires</x:ref>        = &lt;Expires, defined in &header-expires;&gt;
</artwork></figure>
</section>

</section>

</section>

<section title="Protocol Parameters" anchor="protocol.parameters">

<section title="Character Sets" anchor="character.sets">
<t>
   HTTP uses the same definition of the term "character set" as that
   described for MIME:
</t>
<t>
   The term "character set" is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters might
   be available in a given character set and a character set might provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name &MUST; fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> This use of the term "character set" is more commonly
    referred to as a "character encoding". However, since HTTP and
    MIME share the same registry, it is important that the terminology
    also be shared.
  </t>
</x:note>
<t anchor="rule.charset">
  <x:anchor-alias value="charset"/>
   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   (<eref target="http://www.iana.org/assignments/character-sets"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="charset"/>
  <x:ref>charset</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry &MUST; represent the character set defined
   by that registry. Applications &SHOULD; limit their use of character
   sets to those defined by the IANA registry.
</t>
<t>
   HTTP uses charset in two contexts: within an Accept-Charset request
   header field (in which the charset value is an unquoted token) and as the
   value of a parameter in a Content-Type header field (within a request or
   response), in which case the parameter value of the charset parameter
   can be quoted.
</t>
<t>
   Implementors need to be aware of IETF character set requirements <xref target="RFC3629"/>
   <xref target="RFC2277"/>.
</t>

<section title="Missing Charset" anchor="missing.charset">
<t>
   Some HTTP/1.0 software has interpreted a Content-Type header field without
   charset parameter incorrectly to mean "recipient should guess".
   Senders wishing to defeat this behavior &MAY; include a charset
   parameter even when the charset is ISO-8859-1 (<xref target="ISO-8859-1"/>) and &SHOULD; do so when
   it is known that it will not confuse the recipient.
</t>
<t>
   Unfortunately, some older HTTP/1.0 clients did not deal properly with
   an explicit charset parameter. HTTP/1.1 recipients &MUST; respect the
   charset label provided by the sender; and those user agents that have
   a provision to "guess" a charset &MUST; use the charset from the
   content-type field if they support that charset, rather than the
   recipient's preference, when initially displaying a document. See
   <xref target="canonicalization.and.text.defaults"/>.
</t>
</section>
</section>

<section title="Content Codings" anchor="content.codings">
  <x:anchor-alias value="content-coding"/>
<t>
   Content coding values indicate an encoding transformation that has
   been or can be applied to a representation. Content codings are primarily
   used to allow a representation to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the representation is stored in
   coded form, transmitted directly, and only decoded by the recipient.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="content-coding"/>
  <x:ref>content-coding</x:ref>   = <x:ref>token</x:ref>
</artwork></figure>
<t>
   All content-coding values are case-insensitive. HTTP/1.1 uses
   content-coding values in the Accept-Encoding (<xref target="header.accept-encoding"/>) and
   Content-Encoding (<xref target="header.content-encoding"/>) header fields. Although the value
   describes the content-coding, what is more important is that it
   indicates what decoding mechanism will be required to remove the
   encoding.
</t>
<t>
   compress<iref item="compress (Coding Format)"/><iref item="Coding Format" subitem="compress"/>
  <list>
    <t>
      See &compress-coding;.
    </t>
  </list>
</t>
<t>
   deflate<iref item="deflate (Coding Format)"/><iref item="Coding Format" subitem="deflate"/>
  <list>
    <t>
      See &deflate-coding;.
    </t>
  </list>
</t>
<t>
   gzip<iref item="gzip (Coding Format)"/><iref item="Coding Format" subitem="gzip"/>
  <list>
    <t>
      See &gzip-coding;.
    </t>
  </list>
</t>
<t>
   identity<iref item="identity (Coding Format)"/><iref item="Coding Format" subitem="identity"/>
  <list><t>
        The default (identity) encoding; the use of no transformation
        whatsoever. This content-coding is used only in the Accept-Encoding
        header field, and &SHOULD-NOT;  be used in the Content-Encoding
        header field.
  </t></list>
</t>

<section title="Content Coding Registry" anchor="content.coding.registry">
<t>
   The HTTP Content Coding Registry defines the name space for the content
   coding names.
</t>
<t>
   Registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Names of content codings &MUST-NOT; overlap with names of transfer codings
   (&transfer-codings;), unless the encoding transformation is identical (as it
   is the case for the compression codings defined in
   &compression-codings;).
</t>
<t>
   Values to be added to this name space require a specification
   (see "Specification Required" in
   <xref target="RFC5226" x:fmt="of" x:sec="4.1"/>), and &MUST;
   conform to the purpose of content coding defined in this section.
</t>
<t>
   The registry itself is maintained at
   <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>
</section>

</section>

<section title="Media Types" anchor="media.types">
  <x:anchor-alias value="media-type"/>
  <x:anchor-alias value="type"/>
  <x:anchor-alias value="subtype"/>
<t>
   HTTP uses Internet Media Types <xref target="RFC2046"/> in the Content-Type (<xref target="header.content-type"/>)
   and Accept (<xref target="header.accept"/>) header fields in order to provide
   open and extensible data typing and type negotiation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="media-type"/><iref primary="true" item="Grammar" subitem="type"/><iref primary="true" item="Grammar" subitem="subtype"/>
  <x:ref>media-type</x:ref> = <x:ref>type</x:ref> "/" <x:ref>subtype</x:ref> *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>parameter</x:ref> )
  <x:ref>type</x:ref>       = <x:ref>token</x:ref>
  <x:ref>subtype</x:ref>    = <x:ref>token</x:ref>
</artwork></figure>
<t anchor="rule.parameter">
  <x:anchor-alias value="attribute"/>
  <x:anchor-alias value="parameter"/>
  <x:anchor-alias value="value"/>
   Parameters &MAY; follow the type/subtype in the form of attribute/value
   pairs.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="parameter"/><iref primary="true" item="Grammar" subitem="attribute"/><iref primary="true" item="Grammar" subitem="value"/>
  <x:ref>parameter</x:ref>      = <x:ref>attribute</x:ref> "=" <x:ref>value</x:ref>
  <x:ref>attribute</x:ref>      = <x:ref>token</x:ref>
  <x:ref>value</x:ref>          = <x:ref>word</x:ref>
</artwork></figure>
<t>
   The type, subtype, and parameter attribute names are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on the
   semantics of the parameter name.  The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry.
</t>
<t>
   A parameter value that matches the <x:ref>token</x:ref> production can be
   transmitted as either a token or within a quoted-string. The quoted and
   unquoted values are equivalent. 
</t>
<t>
   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations &SHOULD; only use media type parameters when they are
   required by that type/subtype definition.
</t>
<t>
   Media-type values are registered with the Internet Assigned Number
   Authority (IANA). The media type registration process is
   outlined in <xref target="RFC4288"/>. Use of non-registered media types is
   discouraged.
</t>

<section title="Canonicalization and Text Defaults" anchor="canonicalization.and.text.defaults">
<t>
   Internet media types are registered with a canonical form. A
   representation transferred via HTTP messages &MUST; be in the
   appropriate canonical form prior to its transmission except for
   "text" types, as defined in the next paragraph.
</t>
<t>
   When in canonical form, media subtypes of the "text" type use CRLF as
   the text line break. HTTP relaxes this requirement and allows the
   transport of text media with plain CR or LF alone representing a line
   break when it is done consistently for an entire representation. HTTP
   applications &MUST; accept CRLF, bare CR, and bare LF as indicating
   a line break in text media received via HTTP. In
   addition, if the text is in a character encoding that does not
   use octets 13 and 10 for CR and LF respectively, as is the case for
   some multi-byte character encodings, HTTP allows the use of whatever octet
   sequences are defined by that character encoding to represent the
   equivalent of CR and LF for line breaks. This flexibility regarding
   line breaks applies only to text media in the payload body; a bare CR
   or LF &MUST-NOT; be substituted for CRLF within any of the HTTP control
   structures (such as header fields and multipart boundaries).
</t>
<t>
   If a representation is encoded with a content-coding, the underlying
   data &MUST; be in a form defined above prior to being encoded.
</t>
<t>
   The "charset" parameter is used with some media types to define the
   character encoding (<xref target="character.sets"/>) of the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the "text"
   type are defined to have a default charset value of "ISO-8859-1" when
   received via HTTP. Data in character encodings other than "ISO-8859-1" or
   its subsets &MUST; be labeled with an appropriate charset value. See
   <xref target="missing.charset"/> for compatibility problems.
</t>
</section>

<section title="Multipart Types" anchor="multipart.types">
<t>
   MIME provides for a number of "multipart" types -- encapsulations of
   one or more representations within a single message-body. All multipart
   types share a common syntax, as defined in <xref target="RFC2046" x:sec="5.1.1" x:fmt="of"/>,
   and &MUST; include a boundary parameter as part of the media type
   value. The message body is itself a protocol element and &MUST;
   therefore use only CRLF to represent line breaks between body-parts.
</t>
<t>
   In general, HTTP treats a multipart message-body no differently than
   any other media type: strictly as payload.  HTTP does not use the
   multipart boundary as an indicator of message-body length.
   <!-- jre: re-insert removed text pointing to caching? -->
   In all other respects, an HTTP user agent &SHOULD; follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   The MIME header fields within each body-part of a multipart message-body
   do not have any significance to HTTP beyond that defined by
   their MIME semantics.
</t>
<t>
   If an application receives an unrecognized multipart subtype, the
   application &MUST; treat it as being equivalent to "multipart/mixed".
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> The "multipart/form-data" type has been specifically defined
    for carrying form data suitable for processing via the POST
    request method, as described in <xref target="RFC2388"/>.
  </t>
</x:note>
</section>
</section>

<section title="Language Tags" anchor="language.tags">
  <x:anchor-alias value="language-tag"/>
<t>
   A language tag, as defined in <xref target="RFC5646"/>, identifies a
   natural language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings. Computer languages are
   explicitly excluded. HTTP uses language tags within the Accept-Language and
   Content-Language fields.
</t>
<t>
   In summary, a language tag is composed of one or more parts: A primary
   language subtag followed by a possibly empty series of subtags:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="language-tag"/>
  <x:ref>language-tag</x:ref> = &lt;Language-Tag, defined in <xref target="RFC5646" x:sec="2.1"/>&gt;
</artwork></figure>
<t>
   White space is not allowed within the tag and all tags are case-insensitive.
   The name space of language subtags is administered by the IANA (see
   <eref target="http://www.iana.org/assignments/language-subtag-registry"/>).
</t>
<figure>
  <preamble>Example tags include:</preamble>
<artwork type="example">
  en, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</artwork>
</figure>
<t>
   See <xref target="RFC5646"/> for further information. 
</t>
</section>
</section>

<section title="Payload" anchor="payload">
<t>
   HTTP messages &MAY; transfer a payload if not otherwise restricted by
   the request method or response status code.  The payload consists of
   metadata, in the form of header fields, and data, in the form of the
   sequence of octets in the message-body after any transfer-coding has
   been decoded.
</t>
<iref item="payload"/>
<t>   
   A "<x:dfn>payload</x:dfn>" in HTTP is always a partial or complete
   representation of some resource.  We use separate terms for payload
   and representation because some messages contain only the associated
   representation's header fields (e.g., responses to HEAD) or only some
   part(s) of the representation (e.g., the 206 status code).
</t>
<section title="Payload Header Fields" anchor="payload.header.fields">
  <x:anchor-alias value="payload-header"/>
<t>
   HTTP header fields that specifically define the payload, rather than the
   associated representation, are referred to as "payload header fields".
   The following payload header fields are defined by HTTP/1.1:
</t>
<figure><artwork>
   <x:ref>Content-Length</x:ref>           ; &header-content-length;
   <x:ref>Content-MD5</x:ref>              ; <xref target="header.content-md5"/>
   <x:ref>Content-Range</x:ref>            ; &header-content-range;
</artwork></figure>
</section>

<section title="Payload Body" anchor="payload.body">
  <x:anchor-alias value="payload-body"/>
<t>
   A payload body is only present in a message when a message-body is
   present, as described in &message-body;. The payload body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.
</t>
</section>
</section>

<section title="Representation" anchor="representation">
<iref item="representation"/>
<t>
   A "<x:dfn>representation</x:dfn>" is information in a format that can be readily
   communicated from one party to another.  A resource representation
   is information that reflects the state of that resource, as observed
   at some point in the past (e.g., in a response to GET) or to be
   desired at some point in the future (e.g., in a PUT request).
</t>
<t>
   Most, but not all, representations transferred via HTTP are intended
   to be a representation of the target resource (the resource identified
   by the effective request URI).  The precise semantics of a representation
   are determined by the type of message (request or response), the request
   method, the response status code, and the representation metadata.
   For example, the above semantic is true for the representation in any
   200 (OK) response to GET and for the representation in any PUT request.
   A 200 response to PUT, in contrast, contains either a representation
   that describes the successful action or a representation of the target
   resource, with the latter indicated by a Content-Location header field
   with the same value as the effective request URI.  Likewise, response
   messages with an error status code usually contain a representation that
   describes the error and what next steps are suggested for resolving it.
</t>

<section title="Representation Header Fields" anchor="representation.header.fields">
  <x:anchor-alias value="representation-header"/>
<t>
   Representation header fields define metadata about the representation data
   enclosed in the message-body or, if no message-body is present, about
   the representation that would have been transferred in a 200 response
   to a simultaneous GET request with the same effective request URI.
</t>
<t>
   The following header fields are defined as representation metadata:
</t>
<figure><artwork>
   <x:ref>Content-Encoding</x:ref>         ; <xref target="header.content-encoding"/>
   <x:ref>Content-Language</x:ref>         ; <xref target="header.content-language"/>
   <x:ref>Content-Location</x:ref>         ; <xref target="header.content-location"/>
   <x:ref>Content-Type</x:ref>             ; <xref target="header.content-type"/>
   <x:ref>Expires</x:ref>                  ; &header-expires;
   <x:ref>Last-Modified</x:ref>            ; &header-last-modified;
</artwork></figure>
</section>

<section title="Representation Data" anchor="representation.data">
  <x:anchor-alias value="representation-data"/>
<t>
   The representation body associated with an HTTP message is
   either provided as the payload body of the message or
   referred to by the message semantics and the effective request
   URI.  The representation data is in a format and encoding defined by
   the representation metadata header fields.
</t>
<t>
   The data type of the representation data
   is determined via the header fields Content-Type and Content-Encoding.
   These define a two-layer, ordered encoding model:
</t>
<figure><artwork type="example">
  representation-data := Content-Encoding( Content-Type( bits ) )
</artwork></figure>
<t>
   Content-Type specifies the media type of the underlying data, which
   defines both the data format and how that data &SHOULD; be processed
   by the recipient (within the scope of the request method semantics).
   Any HTTP/1.1 message containing a payload body &SHOULD; include a
   Content-Type header field defining the media type of the associated
   representation unless that metadata is unknown to the sender.
   If the Content-Type header field is not present, it indicates that
   the sender does not know the media type of the representation;
   recipients &MAY; either assume that the media type is
   "application/octet-stream" (<xref target="RFC2046" x:fmt="," x:sec="4.5.1"/>)
   or examine the content to determine its type.
</t>
<t>
   In practice, resource owners do not always properly configure their origin
   server to provide the correct Content-Type for a given representation,
   with the result that some clients will examine a response body's content
   and override the specified type.
   Clients that do so risk drawing incorrect conclusions, which might expose
   additional security risks (e.g., "privilege escalation").  Furthermore,
   it is impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only in
   processing semantics.  Implementers are encouraged to provide a means of
   disabling such "content sniffing" when it is used.
</t>
<t>
   Content-Encoding is used to indicate any additional content
   codings applied to the data, usually for the purpose of data
   compression, that are a property of the representation.  If
   Content-Encoding is not present, then there is no additional
   encoding beyond that defined by the Content-Type.
</t>
</section>
</section>

<section title="Content Negotiation" anchor="content.negotiation">
<t>
   HTTP responses include a representation which contains information for
   interpretation, whether by a human user or for further processing.
   Often, the server has different ways of representing the
   same information; for example, in different formats, languages,
   or using different character encodings.
</t>
<t>
   HTTP clients and their users might have different or variable
   capabilities, characteristics or preferences which would influence
   which representation, among those available from the server,
   would be best for the server to deliver. For this reason, HTTP
   provides mechanisms for "content negotiation" -- a process of
   allowing selection of a representation of a given resource,
   when more than one is available.
</t>
<t>
   This specification defines two patterns of content negotiation;
   "server-driven", where the server selects the representation based
   upon the client's stated preferences, and "agent-driven" negotiation,
   where the server provides a list of representations for the client to
   choose from, based upon their metadata. In addition,  there are
   other patterns: some applications use an "active content" pattern,
   where the server returns active content which runs on the client
   and, based on client available parameters, selects additional
   resources to invoke. "Transparent Content Negotiation" (<xref target="RFC2295"/>)
   has also been proposed.
</t>
<t>
   These patterns are all widely used, and have trade-offs in applicability
   and practicality. In particular, when the number of preferences or
   capabilities to be expressed by a client are large (such as when many
   different formats are supported by a user-agent), server-driven
   negotiation becomes unwieldy, and might not be appropriate. Conversely,
   when the number of representations to choose from is very large,
   agent-driven negotiation might not be appropriate.
</t>
<t>
   Note that in all cases, the supplier of representations has the
   responsibility for determining which representations might be
   considered to be the "same information".
</t>

<section title="Server-driven Negotiation" anchor="server-driven.negotiation">
<t>
   If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g., language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).
</t>
<t>
   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   "best guess" to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the "best
   guess" is good enough for the user). In order to improve the server's
   guess, the user agent &MAY; include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.
</t>
<t>
   Server-driven negotiation has disadvantages:
  <list style="numbers">
    <t>
         It is impossible for the server to accurately determine what
         might be "best" for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).
    </t>
    <t>
         Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.
    </t>
    <t>
         It complicates the implementation of an origin server and the
         algorithms for generating responses to a request.
    </t>
    <t>
         It might limit a public cache's ability to use the same response
         for multiple user's requests.
    </t>
  </list>
</t>
<t>
   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (<xref target="header.accept"/>), Accept-Charset
   (<xref target="header.accept-charset"/>), Accept-Encoding (<xref target="header.accept-encoding"/>), Accept-Language
   (<xref target="header.accept-language"/>), and User-Agent (&header-user-agent;).
   However, an origin server is not limited to these dimensions and &MAY; vary 
   the response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> In practice, User-Agent based negotiation is fragile,
    because new clients might not be recognized. 
  </t>
</x:note>
<t>
   The Vary header field (&header-vary;) can be used to express the parameters the
   server uses to select a representation that is subject to server-driven
   negotiation.
</t>
</section>

<section title="Agent-driven Negotiation" anchor="agent-driven.negotiation">
<t>
   With agent-driven negotiation, selection of the best representation
   for a response is performed by the user agent after receiving an
   initial response from the origin server. Selection is based on a list
   of the available representations of the response included within the
   header fields or body of the initial response, with each
   representation identified by its own URI. Selection from among the
   representations can be performed automatically (if the user agent is
   capable of doing so) or manually by the user selecting from a
   generated (possibly hypertext) menu.
</t>
<t>
   Agent-driven negotiation is advantageous when the response would vary
   over commonly-used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.
</t>
<t>
   Agent-driven negotiation suffers from the disadvantage of needing a
   second request to obtain the best alternate representation. This
   second request is only efficient when caching is used. In addition,
   this specification does not define any mechanism for supporting
   automatic selection, though it also does not prevent any such
   mechanism from being developed as an extension and used within
   HTTP/1.1.
</t>
<t>
   This specification defines the 300 (Multiple Choices) and 406 (Not Acceptable)
   status codes for enabling agent-driven negotiation when the server is
   unwilling or unable to provide a varying response using server-driven
   negotiation.
</t>
</section>
</section>

<section title="Header Field Definitions" anchor="header.fields">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to the payload of messages.
</t>

<section title="Accept" anchor="header.accept">
  <iref primary="true" item="Accept header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept" x:for-anchor=""/>
  <x:anchor-alias value="Accept"/>
  <x:anchor-alias value="Accept-v"/>
  <x:anchor-alias value="accept-ext"/>
  <x:anchor-alias value="accept-params"/>
  <x:anchor-alias value="media-range"/>
<t>
   The "Accept" request-header field can be used by user agents to specify
   response media types that are acceptable. Accept header fields can be used to
   indicate that the request is specifically limited to a small set of desired
   types, as in the case of a request for an in-line image.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept"/><iref primary="true" item="Grammar" subitem="Accept-v"/><iref primary="true" item="Grammar" subitem="media-range"/><iref primary="true" item="Grammar" subitem="accept-params"/><iref primary="true" item="Grammar" subitem="accept-ext"/>
  <x:ref>Accept</x:ref>   = "Accept" ":" <x:ref>OWS</x:ref> <x:ref>Accept-v</x:ref>
  <x:ref>Accept-v</x:ref> = #( <x:ref>media-range</x:ref> [ <x:ref>accept-params</x:ref> ] )
  
  <x:ref>media-range</x:ref>    = ( "*/*"
                   / ( <x:ref>type</x:ref> "/" "*" )
                   / ( <x:ref>type</x:ref> "/" <x:ref>subtype</x:ref> )
                   ) *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>parameter</x:ref> )
  <x:ref>accept-params</x:ref>  = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref> *( <x:ref>accept-ext</x:ref> )
  <x:ref>accept-ext</x:ref>     = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>token</x:ref>
                   [ "=" <x:ref>word</x:ref> ]
</artwork></figure>
<t>
   The asterisk "*" character is used to group media types into ranges,
   with "*/*" indicating all media types and "type/*" indicating all
   subtypes of that type. The media-range &MAY; include media type
   parameters that are applicable to that range.
</t>
<t>
   Each media-range &MAY; be followed by one or more accept-params,
   beginning with the "q" parameter for indicating a relative quality
   factor. The first "q" parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&qvalue;). The
   default value is q=1.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> Use of the "q" parameter name to separate media type
    parameters from Accept extension parameters is due to historical
    practice. Although this prevents any media type parameter named
    "q" from being used with a media range, such an event is believed
    to be unlikely given the lack of any "q" parameters in the IANA
    media type registry and the rare usage of any media type
    parameters in Accept. Future media types are discouraged from
    registering any parameter named "q".
  </t>
</x:note>
<t>
   The example
</t>
<figure><artwork type="example">
  Accept: audio/*; q=0.2, audio/basic
</artwork></figure>
<t>
   &SHOULD; be interpreted as "I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality".
</t>
<t>
   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server &SHOULD;
   send a 406 (Not Acceptable) response.
</t>
<t>
   A more elaborate example is
</t>
<figure><artwork type="example">
  Accept: text/plain; q=0.5, text/html,
          text/x-dvi; q=0.8, text/x-c
</artwork></figure>
<t>
   Verbally, this would be interpreted as "text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi representation, and if that does not exist, send the text/plain
   representation".
</t>
<t>
   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,
</t>
<figure><artwork type="example">
  Accept: text/*, text/html, text/html;level=1, */*
</artwork></figure>
<t>
   have the following precedence:
   <list style="numbers">
    <t>text/html;level=1</t>
    <t>text/html</t>
    <t>text/*</t>
    <t>*/*</t>
   </list>
</t>
<t>
   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,
</t>
<figure><artwork type="example">
  Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
          text/html;level=2;q=0.4, */*;q=0.5
</artwork></figure>
<t>
   would cause the following values to be associated:
</t>
<texttable align="left">
  <ttcol>Media Type</ttcol><ttcol>Quality Value</ttcol>
  <c>text/html;level=1</c>    <c>1</c>
  <c>text/html</c>            <c>0.7</c>
  <c>text/plain</c>           <c>0.3</c>
  <c>image/jpeg</c>           <c>0.5</c>
  <c>text/html;level=2</c>    <c>0.4</c>
  <c>text/html;level=3</c>    <c>0.7</c>
</texttable>
<t>
      <x:h>Note:</x:h> A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.
</t>
</section>

<section title="Accept-Charset" anchor="header.accept-charset">
  <iref primary="true" item="Accept-Charset header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Charset" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Charset"/>
  <x:anchor-alias value="Accept-Charset-v"/>
<t>
   The "Accept-Charset" request-header field can be used by user agents to
   indicate what response character sets are acceptable. This field allows
   clients capable of understanding more comprehensive or special-purpose
   character sets to signal that capability to a server which is capable of
   representing documents in those character sets.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Charset"/><iref primary="true" item="Grammar" subitem="Accept-Charset-v"/>
  <x:ref>Accept-Charset</x:ref>   = "Accept-Charset" ":" <x:ref>OWS</x:ref>
          <x:ref>Accept-Charset-v</x:ref>
  <x:ref>Accept-Charset-v</x:ref> = 1#( ( <x:ref>charset</x:ref> / "*" )
                         [ <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref> ] )
</artwork></figure>
<t>
   Character set values are described in <xref target="character.sets"/>. Each charset &MAY;
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is
</t>
<figure><artwork type="example">
  Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</artwork></figure>
<t>
   The special value "*", if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no "*" is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.
</t>
<t>
   If no Accept-Charset header field is present, the default is that any
   character set is acceptable. If an Accept-Charset header field is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header field, then the server &SHOULD; send
   an error response with the 406 (Not Acceptable) status code, though
   the sending of an unacceptable response is also allowed.
</t>
</section>

<section title="Accept-Encoding" anchor="header.accept-encoding">
  <iref primary="true" item="Accept-Encoding header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Encoding" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Encoding"/>
  <x:anchor-alias value="Accept-Encoding-v"/>
  <x:anchor-alias value="codings"/>
<t>
   The "Accept-Encoding" request-header field can be used by user agents to
   indicate what response content-codings (<xref target="content.codings"/>)
   are acceptable in the response.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Encoding"/><iref primary="true" item="Grammar" subitem="Accept-Encoding-v"/><iref primary="true" item="Grammar" subitem="codings"/>
  <x:ref>Accept-Encoding</x:ref>    = "Accept-Encoding" ":" <x:ref>OWS</x:ref>
                     <x:ref>Accept-Encoding-v</x:ref>
  <x:ref>Accept-Encoding-v</x:ref>  = 
                     #( <x:ref>codings</x:ref> [ <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref> ] )
  <x:ref>codings</x:ref>            = ( <x:ref>content-coding</x:ref> / "*" )
</artwork></figure>
<t>
   Each codings value &MAY; be given an associated quality value which
   represents the preference for that encoding. The default value is q=1.
</t>
<t>
   Examples of its use are:
</t>
<figure><artwork type="example">
  Accept-Encoding: compress, gzip
  Accept-Encoding:
  Accept-Encoding: *
  Accept-Encoding: compress;q=0.5, gzip;q=1.0
  Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</artwork></figure>
<t>
   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:
  <list style="numbers">
      <t>If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &qvalue;, a
         qvalue of 0 means "not acceptable".)</t>

      <t>The special "*" symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.</t>

      <t>If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.</t>

      <t>The "identity" content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         "identity;q=0", or because the field includes "*;q=0" and does
         not explicitly include the "identity" content-coding. If the
         Accept-Encoding field-value is empty, then only the "identity"
         encoding is acceptable.</t>
  </list>
</t>
<t>
   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header field, then the server &SHOULD; send an error response
   with the 406 (Not Acceptable) status code.
</t>
<t>
   If no Accept-Encoding field is present in a request, the server &MAY;
   assume that the client will accept any content coding. In this case,
   if "identity" is one of the available content-codings, then the
   server &SHOULD; use the "identity" content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> If the request does not include an Accept-Encoding field,
    and if the "identity" content-coding is unavailable, then
    content-codings commonly understood by HTTP/1.0 clients (i.e.,
    "gzip" and "compress") are preferred; some older clients
    improperly display messages sent with other content-codings.  The
    server might also make this decision based on information about
    the particular user-agent or client.
  </t>
</x:note>
<x:note>
  <t>
    <x:h>Note:</x:h> Most HTTP/1.0 applications do not recognize or obey qvalues
    associated with content-codings. This means that qvalues will not
    work and are not permitted with x-gzip or x-compress.
  </t>
</x:note>
</section>

<section title="Accept-Language" anchor="header.accept-language">
  <iref primary="true" item="Accept-Language header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Accept-Language" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Language"/>
  <x:anchor-alias value="Accept-Language-v"/>
  <x:anchor-alias value="language-range"/>
<t>
   The "Accept-Language" request-header field can be used by user agents to
   indicate the set of natural languages that are preferred in the response.
   Language tags are defined in <xref target="language.tags"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Language"/><iref primary="true" item="Grammar" subitem="Accept-Language-v"/><iref primary="true" item="Grammar" subitem="language-range"/>
  <x:ref>Accept-Language</x:ref>   = "Accept-Language" ":" <x:ref>OWS</x:ref>
                    <x:ref>Accept-Language-v</x:ref>
  <x:ref>Accept-Language-v</x:ref> =
                    1#( <x:ref>language-range</x:ref> [ <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref> ] )
  <x:ref>language-range</x:ref>    = 
            &lt;language-range, defined in <xref target="RFC4647" x:fmt="," x:sec="2.1"/>&gt;
</artwork></figure>
<t>
   Each language-range can be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to "q=1". For
   example,
</t>
<figure><artwork type="example">
  Accept-Language: da, en-gb;q=0.8, en;q=0.7
</artwork></figure>
<t>
   would mean: "I prefer Danish, but will accept British English and
   other types of English".
   (see also <xref target="RFC4647" x:sec="2.3" x:fmt="of"/>)
</t>
<t>
   For matching, <xref target="RFC4647" x:sec="3" x:fmt="of"/> defines 
   several matching schemes. Implementations can offer the most appropriate
   matching scheme for their requirements. 
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> The "Basic Filtering" scheme (<xref target="RFC4647"
    x:fmt="," x:sec="3.3.1"/>) is identical to the matching scheme that was
    previously defined in <xref target="RFC2616" x:fmt="of" x:sec="14.4"/>.
  </t>
</x:note>
<t>
   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   <xref target="privacy.issues.connected.to.accept.header.fields"/>.
</t>
<t>
   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field &MUST-NOT; be given in
   the request.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> When making the choice of linguistic preference available to
    the user, we remind implementors of  the fact that users are not
    familiar with the details of language matching as described above,
    and ought to be provided appropriate guidance. As an example, users
    might assume that on selecting "en-gb", they will be served any
    kind of English document if British English is not available. A
    user agent might suggest in such a case to add "en" to get the
    best matching behavior.
  </t>
</x:note>
</section>

<section title="Content-Encoding" anchor="header.content-encoding">
  <iref primary="true" item="Content-Encoding header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Encoding" x:for-anchor=""/>
  <x:anchor-alias value="Content-Encoding"/>
  <x:anchor-alias value="Content-Encoding-v"/>
<t>
   The "Content-Encoding" header field indicates what content-codings 
   have been applied to the representation, and thus what decoding mechanisms
   must be applied in order to obtain the media-type referenced by the 
   Content-Type header field. Content-Encoding is primarily used to allow a
   representation to be compressed without losing the identity of its underlying
   media type.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Encoding"/><iref primary="true" item="Grammar" subitem="Content-Encoding-v"/>
  <x:ref>Content-Encoding</x:ref>   = "Content-Encoding" ":" <x:ref>OWS</x:ref> <x:ref>Content-Encoding-v</x:ref>
  <x:ref>Content-Encoding-v</x:ref> = 1#<x:ref>content-coding</x:ref>
</artwork></figure>
<t>
   Content codings are defined in <xref target="content.codings"/>. An example of its use is
</t>
<figure><artwork type="example">
  Content-Encoding: gzip
</artwork></figure>
<t>
   The content-coding is a characteristic of the representation.
   Typically, the representation body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy &MAY; modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   "no-transform" cache-control directive is present in the message.
</t>
<t>
   If the content-coding of a representation is not "identity", then the
   representation metadata &MUST; include a Content-Encoding header
   field (<xref target="header.content-encoding"/>)
   that lists the non-identity content-coding(s) used.
</t>
<t>
   If the content-coding of a representation in a request message is not
   acceptable to the origin server, the server &SHOULD; respond with a
   status code of 415 (Unsupported Media Type).
</t>
<t>
   If multiple encodings have been applied to a representation, the content
   codings &MUST; be listed in the order in which they were applied.
   Additional information about the encoding parameters &MAY; be provided
   by other header fields not defined by this specification.
</t>
</section>

<section title="Content-Language" anchor="header.content-language">
  <iref primary="true" item="Content-Language header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Language" x:for-anchor=""/>
  <x:anchor-alias value="Content-Language"/>
  <x:anchor-alias value="Content-Language-v"/>
<t>
   The "Content-Language" header field describes the natural
   language(s) of the intended audience for the representation. Note that this might
   not be equivalent to all the languages used within the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Language"/><iref primary="true" item="Grammar" subitem="Content-Language-v"/>
  <x:ref>Content-Language</x:ref>   = "Content-Language" ":" <x:ref>OWS</x:ref> <x:ref>Content-Language-v</x:ref>
  <x:ref>Content-Language-v</x:ref> = 1#<x:ref>language-tag</x:ref>
</artwork></figure>
<t>
   Language tags are defined in <xref target="language.tags"/>. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is
</t>
<figure><artwork type="example">
  Content-Language: da
</artwork></figure>
<t>
   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.
</t>
<t>
   Multiple languages &MAY; be listed for content that is intended for
   multiple audiences. For example, a rendition of the "Treaty of
   Waitangi", presented simultaneously in the original Maori and English
   versions, would call for
</t>
<figure><artwork type="example">
  Content-Language: mi, en
</artwork></figure>
<t>
   However, just because multiple languages are present within a representation
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as "A First
   Lesson in Latin", which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include "en".
</t>
<t>
   Content-Language &MAY; be applied to any media type -- it is not
   limited to textual documents.
</t>
</section>

<section title="Content-Location" anchor="header.content-location">
  <iref primary="true" item="Content-Location header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Location" x:for-anchor=""/>
  <x:anchor-alias value="Content-Location"/>
  <x:anchor-alias value="Content-Location-v"/>
<t>
   The "Content-Location" header field supplies a URI that can be used
   as a specific identifier for the representation in this message.
   In other words, if one were to perform a GET on this URI at the time
   of this message's generation, then a 200 response would contain the
   same representation that is enclosed as payload in this message.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Location"/><iref primary="true" item="Grammar" subitem="Content-Location-v"/>
  <x:ref>Content-Location</x:ref>   = "Content-Location" ":" <x:ref>OWS</x:ref>
                    <x:ref>Content-Location-v</x:ref>
  <x:ref>Content-Location-v</x:ref> =
                    <x:ref>absolute-URI</x:ref> / <x:ref>partial-URI</x:ref>
</artwork></figure>
<t>
   The Content-Location value is not a replacement for the effective
   Request URI (&effective-request-uri;).  It is representation metadata.
   It has the same syntax and semantics as the header field of the same name
   defined for MIME body parts in <xref target="RFC2557" x:fmt="of" x:sec="4"/>.
   However, its appearance in an HTTP message has some special implications
   for HTTP recipients.
</t>
<t>
   If Content-Location is included in a response message and its value
   is the same as the effective request URI, then the response payload
   &SHOULD; be considered the current representation of that resource.
   For a GET or HEAD request, this is the same as the default semantics
   when no Content-Location is provided by the server.  For a state-changing
   method like PUT or POST, it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it from
   representations that might only report about the action (e.g., "It worked!").
   This allows authoring applications to update their local copies without
   the need for a subsequent GET request.
</t>
<t>
   If Content-Location is included in a response message and its value
   differs from the effective request URI, then the origin server is
   informing recipients that this representation has its own, presumably
   more specific, identifier.  For a GET or HEAD request, this is an
   indication that the effective request URI identifies a resource that
   is subject to content negotiation and the representation selected for
   this response can also be found at the identified URI.  For other
   methods, such a Content-Location indicates that this representation
   contains a report on the action's status and the same report is
   available (for future access with GET) at the given URI.  For
   example, a purchase transaction made via the POST method might
   include a receipt document as the payload of the 200 response;
   the Content-Location value provides an identifier for retrieving
   a copy of that same receipt in the future.
</t>
<t>
   If Content-Location is included in a request message, then it &MAY;
   be interpreted by the origin server as an indication of where the
   user agent originally obtained the content of the enclosed
   representation (prior to any subsequent modification of the content
   by that user agent).  In other words, the user agent is providing
   the same representation metadata that it received with the original
   representation.  However, such interpretation &MUST-NOT; be used to
   alter the semantics of the method requested by the client.  For
   example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then the
   new set of values for that resource is expected to be consistent with
   the one representation supplied in that PUT; the Content-Location
   cannot be used as a form of reverse content selection that
   identifies only one of the negotiated representations to be updated.
   If the user agent had wanted the latter semantics, it would have applied
   the PUT directly to the Content-Location URI.
</t>
<t>
   A Content-Location field received in a request message is transitory
   information that &SHOULD-NOT; be saved with other representation
   metadata for use in later responses.  The Content-Location's value
   might be saved for use in other contexts, such as within source links
   or other metadata.
</t>
<t>
   A cache cannot assume that a representation with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI.
</t>
<t>
   If the Content-Location value is a partial URI, the partial URI is
   interpreted relative to the effective request URI.
</t>
</section>

<section title="Content-MD5" anchor="header.content-md5">
  <iref primary="true" item="Content-MD5 header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-MD5" x:for-anchor=""/>
  <x:anchor-alias value="Content-MD5"/>
  <x:anchor-alias value="Content-MD5-v"/>
<t>
   The "Content-MD5" header field, as defined in <xref target="RFC1864"/>, is
   an MD5 digest of the payload body that provides an end-to-end message
   integrity check (MIC) of the payload body (the message-body after any
   transfer-coding is decoded). Note that a MIC is good for
   detecting accidental modification of the payload body in transit, but is not
   proof against malicious attacks.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-MD5"/><iref primary="true" item="Grammar" subitem="Content-MD5-v"/>
  <x:ref>Content-MD5</x:ref>   = "Content-MD5" ":" <x:ref>OWS</x:ref> <x:ref>Content-MD5-v</x:ref>
  <x:ref>Content-MD5-v</x:ref> = &lt;base64 of 128 bit MD5 digest as per <xref target="RFC1864"/>&gt;
</artwork></figure>
<t>
   The Content-MD5 header field &MAY; be generated by an origin server or
   client to function as an integrity check of the payload body. Only
   origin servers or user agents &MAY; generate the Content-MD5 header field;
   proxies and gateways &MUST-NOT; generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient &MAY; check that
   the digest value in this header field matches a corresponding digest
   calculated on payload body as received.
</t>
<t>
   The MD5 digest is computed based on the content of the payload body,
   including any content-coding, but not including any transfer-coding
   applied to the message-body because such transfer-codings might be
   applied or removed anywhere along the request/response chain.
   If the message is received with a transfer-coding, that encoding &MUST;
   be decoded prior to checking the Content-MD5 value against the received
   payload.
</t>
<t>
   HTTP extends RFC 1864 to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.
</t>
<t>
   There are several consequences of this. The payload for composite
   types &MAY; contain many body-parts, each with its own MIME and HTTP
   header fields (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding header fields). If a body-part has a Content-Transfer-Encoding
   or Content-Encoding header field, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.
</t>
<t>
   Conversion of all line breaks to CRLF &MUST-NOT; be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted &MUST; be left unaltered when computing
   the digest.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> While the definition of Content-MD5 is exactly the same for
    HTTP as in RFC 1864 for MIME entity-bodies, there are several ways
    in which the application of Content-MD5 to HTTP entity-bodies
    differs from its application to MIME entity-bodies. One is that
    HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
    does use Transfer-Encoding and Content-Encoding. Another is that
    HTTP more frequently uses binary content types than MIME, so it is
    worth noting that, in such cases, the byte order used to compute
    the digest is the transmission byte order defined for the type.
    Lastly, HTTP allows transmission of text types with any of several
    line break conventions and not just the canonical form using CRLF.
  </t>
</x:note>
</section>

<section title="Content-Type" anchor="header.content-type">
  <iref primary="true" item="Content-Type header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Content-Type" x:for-anchor=""/>
  <x:anchor-alias value="Content-Type"/>
  <x:anchor-alias value="Content-Type-v"/>
<t>
   The "Content-Type" header field indicates the media type of the
   representation. In the case of responses to the HEAD method, the media type is
   that which would have been sent had the request been a GET.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Type"/><iref primary="true" item="Grammar" subitem="Content-Type-v"/>
  <x:ref>Content-Type</x:ref>   = "Content-Type" ":" <x:ref>OWS</x:ref> <x:ref>Content-Type-v</x:ref>
  <x:ref>Content-Type-v</x:ref> = <x:ref>media-type</x:ref>
</artwork></figure>
<t>
   Media types are defined in <xref target="media.types"/>. An example of the field is
</t>
<figure><artwork type="example">
  Content-Type: text/html; charset=ISO-8859-4
</artwork></figure>
<t>
   Further discussion of Content-Type is provided in <xref target="representation.data"/>.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="IANA.considerations">
<section title="Header Field Registration" anchor="header.field.registration">
<t>
   The Message Header Field Registry located at <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/> shall be updated
   with the permanent registrations below (see <xref target="RFC3864"/>):
</t>
<?BEGININC p3-payload.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Accept</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept"/>
   </c>
   <c>Accept-Charset</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-charset"/>
   </c>
   <c>Accept-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-encoding"/>
   </c>
   <c>Accept-Language</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-language"/>
   </c>
   <c>Content-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-encoding"/>
   </c>
   <c>Content-Language</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-language"/>
   </c>
   <c>Content-Location</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-location"/>
   </c>
   <c>Content-MD5</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-md5"/>
   </c>
   <c>Content-Type</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-type"/>
   </c>
   <c>MIME-Version</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="mime-version"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p3-payload.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="Content Coding Registry" anchor="content.coding.registration">
<t>
   The registration procedure for HTTP Content Codings is now defined
   by <xref target="content.coding.registry"/> of this document.
</t>
<t>
   The HTTP Content Codings Registry located at <eref target="http://www.iana.org/assignments/http-parameters"/>
   shall be updated with the registration below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.content.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>compress</c>
   <c>UNIX "compress" program method</c>
   <c>
      &compress-coding;
   </c>
   <c>deflate</c>
   <c>"deflate" compression mechanism (<xref target="RFC1951"/>) used inside
   the "zlib" data format (<xref target="RFC1950"/>)
   </c>
   <c>
      &deflate-coding;
   </c>
   <c>gzip</c>
   <c>Same as GNU zip <xref target="RFC1952"/></c>
   <c>
      &gzip-coding;
   </c>
   <c>identity</c>
   <c>No transformation</c>
   <c>
      <xref target="content.codings"/>
   </c>
</texttable>
</section>

</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.
</t>

<section title="Privacy Issues Connected to Accept Header Fields" anchor="privacy.issues.connected.to.accept.header.fields">
<t>
   Accept request-headers fields can reveal information about the user to all
   servers which are accessed. The Accept-Language header field in particular
   can reveal information the user would consider to be of a private
   nature, because the understanding of particular languages is often
   strongly correlated to the membership of a particular ethnic group.
   User agents which offer the option to configure the contents of an
   Accept-Language header field to be sent in every request are strongly
   encouraged to let the configuration process include a message which
   makes the user aware of the loss of privacy involved.
</t>
<t>
   An approach that limits the loss of privacy would be for a user agent
   to omit the sending of Accept-Language header fields by default, and to ask
   the user whether or not to start sending Accept-Language header fields to a
   server if it detects, by looking for any Vary response-header fields
   generated by the server, that such sending could improve the quality
   of service.
</t>
<t>
   Elaborate user-customized accept header fields sent in every request,
   in particular if these include quality values, can be used by servers
   as relatively reliable and long-lived user identifiers. Such user
   identifiers would allow content providers to do click-trail tracking,
   and would allow collaborating content providers to match cross-server
   click-trails or form submissions of individual users. Note that for
   many users not behind a proxy, the network address of the host
   running the user agent will also serve as a long-lived user
   identifier. In environments where proxies are used to enhance
   privacy, user agents ought to be conservative in offering accept
   header configuration options to end users. As an extreme privacy
   measure, proxies could filter the accept header fields in relayed requests.
   General purpose user agents which provide a high degree of header
   configurability &SHOULD; warn users about the loss of privacy which can
   be involved.
</t>
</section>

</section>

<section title="Acknowledgments" anchor="ack">
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="ISO-8859-1">
  <front>
    <title>
     Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1
    </title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
</reference>

<reference anchor="Part1">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
  <x:source href="p1-messaging.xml" basename="p1-messaging"/>
</reference>

<reference anchor="Part2">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="p2-semantics.xml" basename="p2-semantics"/>
</reference>

<reference anchor="Part4">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 4: Conditional Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"/>
  <x:source href="p4-conditional.xml" basename="p4-conditional"/>
</reference>

<reference anchor="Part5">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
  <x:source href="p5-range.xml" basename="p5-range"/>
</reference>

<reference anchor="Part6">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 6: Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="p6-cache.xml" basename="p6-cache"/>
</reference>

<reference anchor="RFC1864">
  <front>
    <title abbrev="Content-MD5 Header Field">The Content-MD5 Header Field</title>
    <author initials="J." surname="Myers" fullname="John G. Myers">
      <organization>Carnegie Mellon University</organization>
      <address><email>jgm+@cmu.edu</email></address>
    </author>
    <author initials="M." surname="Rose" fullname="Marshall T. Rose">
      <organization>Dover Beach Consulting, Inc.</organization>
      <address><email>mrose@dbc.mtview.ca.us</email></address>
    </author>
    <date month="October" year="1995"/>
  </front>
  <seriesInfo name="RFC" value="1864"/>
</reference>

<reference anchor="RFC1950">
  <front>
    <title>ZLIB Compressed Data Format Specification version 3.3</title>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly"/>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1950"/>
  <annotation>
    RFC 1950 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of RFC 2068 in 1997 (<xref target="RFC2068"/>),
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>
</reference>

<reference anchor="RFC1951">
  <front>
    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1951"/>
  <annotation>
    RFC 1951 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of RFC 2068 in 1997 (<xref target="RFC2068"/>),
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>
</reference>

<reference anchor="RFC1952">
  <front>
    <title>GZIP file format specification version 4.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
      <address><email>gzip@prep.ai.mit.edu</email></address>
    </author>
    <author initials="M." surname="Adler" fullname="Mark Adler">
      <address><email>madler@alumni.caltech.edu</email></address>
    </author>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
      <address><email>randeg@alumni.rpi.edu</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1952"/>
  <annotation>
    RFC 1952 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of RFC 2068 in 1997 (<xref target="RFC2068"/>),
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>
</reference>

<reference anchor="RFC2045">
  <front>
    <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC2046">
  <front>
    <title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2046"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor='RFC4647'>
  <front>
    <title>Matching of Language Tags</title>
    <author initials='A.' surname='Phillips' fullname='Addison Phillips' role="editor">
      <organization>Yahoo! Inc.</organization>
      <address><email>addison@inter-locale.com</email></address>
    </author>
    <author initials='M.' surname='Davis' fullname='Mark Davis' role="editor">
      <organization>Google</organization>
      <address><email>mark.davis@macchiato.com</email></address>
    </author>
    <date year='2006' month='September' />
  </front>
  <seriesInfo name='BCP' value='47' />
  <seriesInfo name='RFC' value='4647' />
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor='RFC5646'>
  <front>
    <title>Tags for Identifying Languages</title>
    <author initials='A.' surname='Phillips' fullname='Addison Phillips' role='editor'>
      <organization>Lab126</organization>
      <address><email>addison@inter-locale.com</email></address>
    </author>
    <author initials='M.' surname='Davis' fullname='Mark Davis' role='editor'>
      <organization>Google</organization>
      <address><email>mark.davis@google.com</email></address>
    </author>
    <date month='September' year='2009' />
  </front>
  <seriesInfo name='BCP' value='47' />
  <seriesInfo name='RFC' value='5646' />
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC1945">
  <front>
    <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT, Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1945"/>
</reference>

<reference anchor="RFC2049">
  <front>
    <title abbrev="MIME Conformance">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2049"/>
</reference>

<reference anchor="RFC2068">
  <front>
    <title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="January" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor="RFC2076">
  <front>
    <title abbrev="Internet Message Headers">Common Internet Message Headers</title>
    <author initials="J." surname="Palme" fullname="Jacob Palme">
      <organization>Stockholm University/KTH</organization>
      <address><email>jpalme@dsv.su.se</email></address>
    </author>
    <date month="February" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2076"/>
</reference>

<reference anchor="RFC2277">
  <front>
    <title abbrev="Charset Policy">IETF Policy on Character Sets and Languages</title>
    <author initials="H.T." surname="Alvestrand" fullname="Harald Tveit Alvestrand">
      <organization>UNINETT</organization>
      <address><email>Harald.T.Alvestrand@uninett.no</email></address>
    </author>
    <date month="January" year="1998"/>
  </front>
  <seriesInfo name="BCP" value="18"/>
  <seriesInfo name="RFC" value="2277"/>
</reference>

<reference anchor='RFC2295'>
  <front>
    <title abbrev='HTTP Content Negotiation'>Transparent Content Negotiation in HTTP</title>
    <author initials='K.' surname='Holtman' fullname='Koen Holtman'>
      <organization>Technische Universiteit Eindhoven</organization>
      <address>
        <email>koen@win.tue.nl</email>
      </address>
    </author>
    <author initials='A.H.' surname='Mutz' fullname='Andrew H. Mutz'>
      <organization>Hewlett-Packard Company</organization>
      <address>
        <email>mutz@hpl.hp.com</email>
      </address>
    </author>
    <date year='1998' month='March'/>
  </front>
  <seriesInfo name='RFC' value='2295'/>
</reference>

<reference anchor="RFC2388">
  <front>
    <title abbrev="multipart/form-data">Returning Values from Forms:  multipart/form-data</title>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization>Xerox Palo Alto Research Center</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <date year="1998" month="August"/>
  </front>
  <seriesInfo name="RFC" value="2388"/>
</reference>

<reference anchor="RFC2557">
  <front>
    <title abbrev="MIME Encapsulation of Aggregate Documents">MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)</title>
    <author initials="F." surname="Palme" fullname="Jacob Palme">
      <organization>Stockholm University and KTH</organization>
      <address><email>jpalme@dsv.su.se</email></address>
    </author>
    <author initials="A." surname="Hopmann" fullname="Alex Hopmann">
      <organization>Microsoft Corporation</organization>
      <address><email>alexhop@microsoft.com</email></address>
    </author>
    <author initials="N." surname="Shelness" fullname="Nick Shelness">
      <organization>Lotus Development Corporation</organization>
      <address><email>Shelness@lotus.com</email></address>
    </author>
    <author initials="E." surname="Stefferud" fullname="Einar Stefferud">
      <address><email>stef@nma.com</email></address>
    </author>
    <date year="1999" month="March"/>
  </front>
  <seriesInfo name="RFC" value="2557"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor="RFC3629">
  <front>
    <title>UTF-8, a transformation format of ISO 10646</title>
    <author initials="F." surname="Yergeau" fullname="F. Yergeau">
      <organization>Alis Technologies</organization>
      <address><email>fyergeau@alis.com</email></address>
    </author>
    <date month="November" year="2003"/>
  </front>
  <seriesInfo name="STD" value="63"/>
  <seriesInfo name="RFC" value="3629"/>
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor="RFC4288">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="N. Freed">
      <organization>Sun Microsystems</organization>
      <address>
        <email>ned.freed@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="J. Klensin">
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <date year="2005" month="December"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="4288"/>
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

<reference anchor="RFC5322">
  <front>
    <title>Internet Message Format</title>
    <author initials="P." surname="Resnick" fullname="P. Resnick">
      <organization>Qualcomm Incorporated</organization>
    </author>
    <date year="2008" month="October"/>
  </front> 
  <seriesInfo name="RFC" value="5322"/>
</reference>

<reference anchor='BCP97'>
  <front>
    <title>Handling Normative References to Standards-Track Documents</title>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <author initials='S.' surname='Hartman' fullname='S. Hartman'>
      <organization>MIT</organization>
      <address>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <date year='2007' month='June' />
  </front>
  <seriesInfo name='BCP' value='97' />
  <seriesInfo name='RFC' value='4897' />
</reference>


</references>

<section title="Differences between HTTP and MIME" anchor="differences.between.http.and.mime">
<t>
   HTTP/1.1 uses many of the constructs defined for Internet Mail (<xref target="RFC5322"/>) and the Multipurpose Internet Mail Extensions (MIME <xref target="RFC2045"/>) to
   allow a message-body to be transmitted in an open variety of
   representations and with extensible mechanisms. However, RFC 2045
   discusses mail, and HTTP has a few features that are different from
   those described in MIME. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.
</t>
<t>
   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to strict MIME environments &SHOULD; be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.
</t>

<section title="MIME-Version" anchor="mime-version">
  <iref primary="true" item="MIME-Version header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="MIME-Version" x:for-anchor=""/>
  <x:anchor-alias value="MIME-Version"/>
  <x:anchor-alias value="MIME-Version-v"/>
<t>
   HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages &MAY;
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in <xref target="RFC2045"/>).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="MIME-Version"/><iref primary="true" item="Grammar" subitem="MIME-Version-v"/>
  <x:ref>MIME-Version</x:ref>   = "MIME-Version" ":" <x:ref>OWS</x:ref> <x:ref>MIME-Version-v</x:ref>
  <x:ref>MIME-Version-v</x:ref> = 1*<x:ref>DIGIT</x:ref> "." 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   MIME version "1.0" is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.
</t>
</section>

<section title="Conversion to Canonical Form" anchor="conversion.to.canonical.form">
<t>
   MIME requires that an Internet mail body-part be converted to
   canonical form prior to being transferred, as described in <xref target="RFC2049" x:fmt="of" x:sec="4"/>.
   <xref target="canonicalization.and.text.defaults"/> of this document describes the forms
   allowed for subtypes of the "text" media type when transmitted over
   HTTP. <xref target="RFC2046"/> requires that content with a type of "text" represent
   line breaks as CRLF and forbids the use of CR or LF outside of line
   break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a
   line break within text content when a message is transmitted over
   HTTP.
</t>
<t>
   Where it is possible, a proxy or gateway from HTTP to a strict MIME
   environment &SHOULD; translate all line breaks within the text media
   types described in <xref target="canonicalization.and.text.defaults"/> of this document to the RFC 2049
   canonical form of CRLF. Note, however, that this might be complicated
   by the presence of a Content-Encoding and by the fact that HTTP
   allows the use of some character sets which do not use octets 13 and
   10 to represent CR and LF, as is the case for some multi-byte
   character sets.
</t>
<t>
   Conversion will break any cryptographic
   checksums applied to the original content unless the original content
   is already in canonical form. Therefore, the canonical form is
   recommended for any content that uses such checksums in HTTP.
</t>
</section>


<section title="Conversion of Date Formats" anchor="conversion.of.date.formats">
<t>
   HTTP/1.1 uses a restricted set of date formats (&full-date;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols &SHOULD; ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.
</t>
</section>

<section title="Introduction of Content-Encoding" anchor="introduction.of.content-encoding">
<t>
   MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field. Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols &MUST; either change the value of the Content-Type header
   field or decode the representation before forwarding the message. (Some
   experimental applications of Content-Type for Internet mail have used
   a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform
   a function equivalent to Content-Encoding. However, this parameter is
   not part of the MIME standards).
</t>
</section>

<section title="No Content-Transfer-Encoding" anchor="no.content-transfer-encoding">
<t>
   HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP &MUST;
   remove any Content-Transfer-Encoding
   prior to delivering the response message to an HTTP client.
</t>
<t>
   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used.
   Such a proxy or gateway &SHOULD; label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.
</t>
</section>

<section title="Introduction of Transfer-Encoding" anchor="introduction.of.transfer-encoding">
<t>
   HTTP/1.1 introduces the Transfer-Encoding header field (&header-transfer-encoding;).
   Proxies/gateways &MUST; remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.
</t>
</section>

<section title="MHTML and Line Length Limitations" anchor="mhtml.line.length">
<t>
   HTTP implementations which share code with MHTML <xref target="RFC2557"/> implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see <xref target="multipart.types"/>) and
   does not interpret the content or any MIME header lines that might be
   contained therein.
</t>
</section>
</section>

<section title="Additional Features" anchor="additional.features">
<t>
   <xref target="RFC1945"/> and <xref target="RFC2068"/> document protocol elements used by some
   existing HTTP implementations, but not consistently and correctly
   across most HTTP/1.1 applications. Implementors are advised to be
   aware of these features, but cannot rely upon their presence in, or
   interoperability with, other HTTP/1.1 applications. Some of these
   describe proposed experimental features, and some describe features
   that experimental deployment found lacking that are now addressed in
   the base HTTP/1.1 specification.
</t>
<t>
   A number of other header fields, such as Content-Disposition and Title,
   from SMTP and MIME are also often implemented (see <xref target="RFC2076"/>).
</t>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Clarify contexts that charset is used in.
  (<xref target="character.sets"/>)
</t>
<t>
  Remove base URI setting semantics for Content-Location due to poor
  implementation support, which was caused by too many broken servers emitting
  bogus Content-Location header fields, and also the potentially undesirable effect
  of potentially breaking relative links in content-negotiated resources.
  (<xref target="header.content-location"/>)
</t>
<t>
  Remove reference to non-existant identity transfer-coding value tokens.
  (<xref target="no.content-transfer-encoding"/>)
</t>
</section>

<?BEGININC p3-payload.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p3-payload.parsed-abnf">
<x:ref>Accept</x:ref> = "Accept:" OWS Accept-v
<x:ref>Accept-Charset</x:ref> = "Accept-Charset:" OWS Accept-Charset-v
<x:ref>Accept-Charset-v</x:ref> = *( "," OWS ) ( charset / "*" ) [ OWS ";" OWS "q="
 qvalue ] *( OWS "," [ OWS ( charset / "*" ) [ OWS ";" OWS "q="
 qvalue ] ] )
<x:ref>Accept-Encoding</x:ref> = "Accept-Encoding:" OWS Accept-Encoding-v
<x:ref>Accept-Encoding-v</x:ref> = [ ( "," / ( codings [ OWS ";" OWS "q=" qvalue ] )
 ) *( OWS "," [ OWS codings [ OWS ";" OWS "q=" qvalue ] ] ) ]
<x:ref>Accept-Language</x:ref> = "Accept-Language:" OWS Accept-Language-v
<x:ref>Accept-Language-v</x:ref> = *( "," OWS ) language-range [ OWS ";" OWS "q="
 qvalue ] *( OWS "," [ OWS language-range [ OWS ";" OWS "q=" qvalue ]
 ] )
<x:ref>Accept-v</x:ref> = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [
 OWS media-range [ accept-params ] ] ) ]

<x:ref>Content-Encoding</x:ref> = "Content-Encoding:" OWS Content-Encoding-v
<x:ref>Content-Encoding-v</x:ref> = *( "," OWS ) content-coding *( OWS "," [ OWS
 content-coding ] )
<x:ref>Content-Language</x:ref> = "Content-Language:" OWS Content-Language-v
<x:ref>Content-Language-v</x:ref> = *( "," OWS ) language-tag *( OWS "," [ OWS
 language-tag ] )
<x:ref>Content-Length</x:ref> = &lt;Content-Length, defined in [Part1], Section 9.2&gt;
<x:ref>Content-Location</x:ref> = "Content-Location:" OWS Content-Location-v
<x:ref>Content-Location-v</x:ref> = absolute-URI / partial-URI
<x:ref>Content-MD5</x:ref> = "Content-MD5:" OWS Content-MD5-v
<x:ref>Content-MD5-v</x:ref> = &lt;base64 of 128 bit MD5 digest as per [RFC1864]&gt;
<x:ref>Content-Range</x:ref> = &lt;Content-Range, defined in [Part5], Section 5.2&gt;
<x:ref>Content-Type</x:ref> = "Content-Type:" OWS Content-Type-v
<x:ref>Content-Type-v</x:ref> = media-type

<x:ref>Expires</x:ref> = &lt;Expires, defined in [Part6], Section 3.3&gt;

<x:ref>Last-Modified</x:ref> = &lt;Last-Modified, defined in [Part4], Section 6.6&gt;

<x:ref>MIME-Version</x:ref> = "MIME-Version:" OWS MIME-Version-v
<x:ref>MIME-Version-v</x:ref> = 1*DIGIT "." 1*DIGIT

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>absolute-URI</x:ref> = &lt;absolute-URI, defined in [Part1], Section 2.6&gt;
<x:ref>accept-ext</x:ref> = OWS ";" OWS token [ "=" word ]
<x:ref>accept-params</x:ref> = OWS ";" OWS "q=" qvalue *accept-ext
<x:ref>attribute</x:ref> = token

<x:ref>charset</x:ref> = token
<x:ref>codings</x:ref> = ( content-coding / "*" )
<x:ref>content-coding</x:ref> = token

<x:ref>language-range</x:ref> = &lt;language-range, defined in [RFC4647], Section 2.1&gt;
<x:ref>language-tag</x:ref> = &lt;Language-Tag, defined in [RFC5646], Section 2.1&gt;

<x:ref>media-range</x:ref> = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS
 ";" OWS parameter )
<x:ref>media-type</x:ref> = type "/" subtype *( OWS ";" OWS parameter )

<x:ref>parameter</x:ref> = attribute "=" value
<x:ref>partial-URI</x:ref> = &lt;partial-URI, defined in [Part1], Section 2.6&gt;

<x:ref>qvalue</x:ref> = &lt;qvalue, defined in [Part1], Section 6.4&gt;

<x:ref>subtype</x:ref> = token

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 1.2.2&gt;
<x:ref>type</x:ref> = token

<x:ref>value</x:ref> = word

<x:ref>word</x:ref> = &lt;word, defined in [Part1], Section 1.2.2&gt;
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; Accept defined but not used
; Accept-Charset defined but not used
; Accept-Encoding defined but not used
; Accept-Language defined but not used
; Content-Encoding defined but not used
; Content-Language defined but not used
; Content-Length defined but not used
; Content-Location defined but not used
; Content-MD5 defined but not used
; Content-Range defined but not used
; Content-Type defined but not used
; Expires defined but not used
; Last-Modified defined but not used
; MIME-Version defined but not used
</artwork></figure></section>
<?ENDINC p3-payload.abnf-appendix ?>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC 2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/8"/>:
      "Media Type Registrations"
      (<eref target="http://purl.org/NET/http-errata#media-reg"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/14"/>:
      "Clarification regarding quoting of charset values"
      (<eref target="http://purl.org/NET/http-errata#charactersets"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/16"/>:
      "Remove 'identity' token references"
      (<eref target="http://purl.org/NET/http-errata#identity"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/25"/>:
      "Accept-Encoding BNF"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/46"/>:
      "RFC1700 references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/55"/>:
      "Updating to RFC4288"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/65"/>:
      "Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/66"/>:
      "ISO-8859-1 Reference"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/68"/>:
      "Encoding References Normative"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86"/>:
      "Normative up-to-date references"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-01">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-02" anchor="changes.since.02">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/67"/>:
      "Quoting Charsets"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/105"/>:
      "Classification for Allow header"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/115"/>:
      "missing default for qvalue in description of Accept-Encoding"
    </t>
  </list>
</t>
<t>
  Ongoing work on IANA Message Header Field Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header field registrations for headers defined
      in this document.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-03" anchor="changes.since.03">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/67"/>:
      "Quoting Charsets"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/113"/>:
      "language tag matching (Accept-Language) vs RFC4647"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/121"/>:
      "RFC 1806 has been replaced by RFC2183"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/68"/>:
      "Encoding References Normative" -- rephrase the annotation and reference
      <xref target="BCP97"/>.
    </t>
  </list>
</t>
 </section>

<section title="Since draft-ietf-httpbis-p3-payload-04" anchor="changes.since.04">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/132"/>:
      "RFC 2822 is updated by RFC 5322"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header field value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-05" anchor="changes.since.05">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/118"/>:
      "Join "Differences Between HTTP Entities and RFC 2045 Entities"?"
    </t>
  </list>
</t>
<t>
  Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Move definition of quality values into Part 1.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-06" anchor="changes.since.06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/80"/>:
      "Content-Location isn't special"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/155"/>:
      "Content Sniffing"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-07" anchor="changes.since.07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/13"/>:
      "Updated reference for language tags"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/110"/>:
      "Clarify rules for determining what entities a response carries"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/154"/>:
      "Content-Location base-setting problems"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/155"/>:
      "Content Sniffing"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/188"/>:
      "pick IANA policy (RFC5226) for Transfer Coding / Content Coding"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/189"/>:
      "move definitions of gzip/deflate/compress to part 1"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/148"/>:
      "update IANA requirements wrt Transfer-Coding values" (add the
      IANA Considerations subsection)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/149"/>:
      "update IANA requirements wrt Content-Coding values" (add the
      IANA Considerations subsection)
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-08" anchor="changes.since.08">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/81"/>:
      "Content Negotiation for media types"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/181"/>:
      "Accept-Language: which RFC4647 filtering?"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-09" anchor="changes.since.09">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/122"/>:
      "MIME-Version not listed in P1, general header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/143"/>:
      "IANA registry for content/transfer encodings"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/155"/>:
      "Content Sniffing"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/200"/>:
      "use of term "word" when talking about header structure"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/196"/>:
      "Term for the requested resource's URI"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/69"/>:
      "Clarify 'Requested Variant'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/80"/>:
      "Content-Location isn't special"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/90"/>:
      "Delimiting messages with multipart/byteranges"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/136"/>:
      "confusing req. language for Content-Location"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/167"/>:
      "Content-Location on 304 responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/183"/>:
      "'requested resource' in content-encoding definition"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/178"/>:
      "Content-MD5 and partial responses"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p3-payload-11" anchor="changes.since.11">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/123"/>:
      "Factor out Content-Disposition"
    </t>
  </list>
</t>
</section>

</section>

</back>
</rfc>
