<?xml version="1.0" encoding="US-ASCII"?>

<!-- v1 -->
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC2629(bis) from documents for processing with xml2rfc.
-->
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<!DOCTYPE rfc
  PUBLIC "" "rfc2629.dtd">
<rfc submissionType="IETF" category="std" consensus="yes" number="7234" ipr="pre5378Trust200902" obsoletes="2616">


<front>

  <title abbrev="HTTP/1.1 Caching">Hypertext Transfer Protocol (HTTP/1.1): Caching</title>

  <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
    <organization>Akamai</organization>
    <address>
      <email>mnot@mnot.net</email>
      <uri>http://www.mnot.net/</uri>
    </address>
  </author>

  <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="May" year="2014"/>

  <area>Applications</area>
  <workgroup>HTTPbis Working Group</workgroup>

  <keyword>Hypertext Transfer Protocol</keyword>
  <keyword>HTTP</keyword>
  <keyword>HTTP Caching</keyword>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for
   distributed, collaborative, hypertext information systems. This document
   defines HTTP caches and the associated header fields
   that control cache behavior or indicate cacheable response messages.
</t>
</abstract>

   </front>
   <middle>

<section anchor="caching" title="Introduction">
<t>
   HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. This document
   defines aspects of HTTP/1.1 related to caching and reusing response
   messages.
</t>

<iref item="cache"/>
<t>
   An HTTP cache is a local store of response messages and the
   subsystem that controls storage, retrieval, and deletion of messages in it.
   A cache stores cacheable responses in order to reduce the response time and
   network bandwidth consumption on future, equivalent requests. Any client or
   server MAY employ a cache, though a cache cannot be used by a server that
   is acting as a tunnel.
</t>
<iref item="shared cache"/>
<iref item="private cache"/>
<t anchor="shared.and.private.caches">
   A shared cache is a cache that stores responses to be reused
   by more than one user; shared caches are usually (but not always) deployed
   as a part of an intermediary. A private cache, in contrast,
   is dedicated to a single user; often, they are deployed as a component of 
   a user agent.
</t>
<t>
   The goal of caching in HTTP/1.1 is to significantly improve performance
   by reusing a prior response message to satisfy a current request.
   A stored response is considered "fresh", as defined in
   <xref target="expiration.model"/>, if the response can be reused without
   "validation" (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it can
   be freshened by validation (<xref target="validation.model"/>) or if the
   origin is unavailable (<xref target="serving.stale.responses"/>).
</t>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in Section 2.5 of <xref target="RFC7230"/>.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/> with a list extension, defined in
   Section 7 of <xref target="RFC7230"/>, that allows for compact definition of
   comma-separated lists using a '#' operator (similar to how the '*' operator
   indicates repetition).
   <xref target="imported.abnf"/> describes rules imported from
   other documents. 
   <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>

<section title="Delta Seconds" anchor="delta-seconds">
<t>
   The delta-seconds rule specifies a non-negative integer, representing time
   in seconds.
</t>
<figure><iref item="Grammar" primary="true" subitem="delta-seconds"/><artwork type="abnf2616"><![CDATA[
  delta-seconds  = 1*DIGIT
]]></artwork></figure>
<t>
   A recipient parsing a delta-seconds value and converting it to binary form
   ought to use an arithmetic type of at least 31 bits of non-negative integer
   range.
   If a cache receives a delta-seconds value greater than the greatest integer
   it can represent, or if any of its subsequent calculations overflows,
   the cache MUST consider the value to be either 2147483648
   (2^31) or the greatest positive integer it can conveniently
   represent.
</t>
<t><list>
   <t>
       Note: The value 2147483648 is here for historical reasons, effectively
       represents infinity (over 68 years), and does not need to be stored in
       binary form; an implementation could produce it as a canned string if
       any overflow occurs, even if the calculations are performed with an
       arithmetic type incapable of directly representing that number.
       What matters here is that an overflow be detected and not treated as a
       negative value in later calculations.
   </t>
</list></t>
</section>

</section>
</section>

<section anchor="caching.overview" title="Overview of Cache Operation">
<iref item="cache entry"/>
<iref item="cache key"/>
<t>
   Proper cache operation preserves the semantics of HTTP transfers
   (<xref target="RFC7231"/>) while eliminating the transfer of information already held
   in the cache.  Although caching is an entirely OPTIONAL feature of HTTP,
   it can be assumed that reusing a cached response is desirable and that such
   reuse is the default behavior when no requirement or local
   configuration prevents it.  Therefore, HTTP cache requirements are focused
   on preventing a cache from either storing a non-reusable response or
   reusing a stored response inappropriately, rather than mandating that
   caches always store and reuse particular responses.
</t>
<t>
   Each cache entry consists of a cache key and one or more
   HTTP responses corresponding to prior requests that used the same key. The
   most common form of cache entry is a successful result of a retrieval
   request: i.e., a 200 (OK) response to a GET request, which
   contains a representation of the resource identified by the request target
   (Section 4.3.1 of <xref target="RFC7231"/>). However, it is also possible to cache permanent redirects,
   negative results (e.g., 404 (Not Found)),
   incomplete results (e.g., 206 (Partial Content)), and
   responses to methods other than GET if the method's definition allows such
   caching and defines something suitable for use as a cache key.
</t>
<iref item="cache key"/>
<t>
   The primary cache key consists of the request method and
   target URI.  However, since HTTP caches in common use today are typically
   limited to caching responses to GET, many caches simply decline
   other methods and use only the URI as the primary cache key.
</t>
<t>
   If a request target is subject to content negotiation, its cache entry
   might consist of multiple stored responses, each differentiated by a
   secondary key for the values of the original request's selecting header
   fields (<xref target="caching.negotiated.responses"/>).
</t>
</section>

<section anchor="response.cacheability" title="Storing Responses in Caches">
<t>
   A cache MUST NOT store a response to any request, unless:
   <list style="symbols">
      <t>The request method is understood by the cache and defined as being
      cacheable, and</t>
      <t>the response status code is understood by the cache, and</t>
      <t>the "no-store" cache directive (see <xref target="header.cache-control"/>) does not appear in request or response
      header fields, and</t>
      <t>the "private" response directive (see <xref target="cache-response-directive.private"/>) does not appear in the
      response, if the cache is shared, and</t>
      <t>the Authorization header field (see
      Section 4.2 of <xref target="RFC7235"/>) does not appear in the request, if the cache is
      shared, unless the response explicitly allows it (see <xref target="caching.authenticated.responses"/>), and</t>
      <t>the response either:
         <list style="symbols">
            <t>contains an <xref target="header.expires" format="none">Expires</xref> header field (see
            <xref target="header.expires"/>), or</t>
            <t>contains a max-age response directive (see <xref target="cache-response-directive.max-age"/>), or</t>
            <t>contains a s-maxage response directive (see <xref target="cache-response-directive.s-maxage"/>) and the cache is
            shared, or</t>
            <t>contains a Cache Control Extension (see <xref target="cache.control.extensions"/>) that allows it to be cached,
            or</t>
            <t>has a status code that is defined as cacheable by default
            (see <xref target="heuristic.freshness"/>), or</t>
            <t>contains a public response directive (see <xref target="cache-response-directive.public"/>).</t>
         </list>
      </t>
   </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions"/>.
</t>
<t>
   In this context, a cache has "understood" a request method or a response
   status code if it recognizes it and implements all specified
   caching-related behavior.
</t>
<t>
   Note that, in normal operation, some caches will not store a response that
   has neither a cache validator nor an explicit expiration time, as such
   responses are not usually useful to store. However, caches are not
   prohibited from storing such responses.
</t>

<section anchor="incomplete.responses" title="Storing Incomplete Responses">
<t>
   A response message is considered complete when all of the octets indicated
   by the message framing (<xref target="RFC7230"/>) are received prior to the connection
   being closed. If the request method is GET, the response status code is
   200 (OK), and the entire response header section has been received, a
   cache MAY store an incomplete response message body if the cache entry is
   recorded as incomplete. Likewise, a 206 (Partial Content)
   response MAY be stored as if it were an incomplete 200
   (OK) cache entry. However, a cache MUST NOT store incomplete or
   partial-content responses if it does not support the Range
   and Content-Range header fields or if it does not understand
   the range units used in those fields.
</t>
<t>
   A cache MAY complete a stored incomplete response by making a subsequent
   range request (<xref target="RFC7233"/>) and combining the successful response with the
   stored entry, as defined in <xref target="combining.responses"/>. A cache
   MUST NOT use an incomplete response to answer requests unless the
   response has been made complete or the request is partial and specifies a
   range that is wholly within the incomplete response. A cache MUST NOT
   send a partial response to a client without explicitly marking it as such
   using the 206 (Partial Content) status code.
</t>
</section>


<section anchor="caching.authenticated.responses" title="Storing Responses to Authenticated Requests">
<t>
   A shared cache MUST NOT use a cached response to a request with an
   Authorization header field (Section 4.2 of <xref target="RFC7235"/>) to
   satisfy any subsequent request unless a cache directive that allows such
   responses to be stored is present in the response.
</t>
<t>
   In this specification, the following <xref target="header.cache-control" format="none">Cache-Control</xref> response
   directives (<xref target="cache-response-directive"/>) have such an effect:
   must-revalidate, public, and s-maxage.
</t>
<t>
   Note that cached responses that contain the "must-revalidate" and/or
   "s-maxage" response directives are not allowed to be served stale (<xref target="serving.stale.responses"/>) by shared caches. In particular, a
   response with either "max-age=0, must-revalidate" or "s-maxage=0" cannot be
   used to satisfy a subsequent request without revalidating it on the origin
   server.
</t>
</section>

<section anchor="combining.responses" title="Combining Partial Content">
<t>
   A response might transfer only a partial representation if the
   connection closed prematurely or if the request used one or more Range
   specifiers (<xref target="RFC7233"/>).  After several such transfers, a cache might have
   received several ranges of the same representation.  A cache MAY combine
   these ranges into a single stored response, and reuse that response to
   satisfy later requests, if they all share the same strong validator and
   the cache complies with the client requirements in Section 4.3 of <xref target="RFC7233"/>.
</t>
<t>
   When combining the new response with one or more stored responses, a
   cache MUST:
   <list style="symbols">
      <t>delete any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning"/>);</t>
      <t>retain any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the new response, aside
         from Content-Range, to replace all instances of the
         corresponding header fields in the stored response.</t>
   </list>
</t>
</section>

</section>


<section anchor="constructing.responses.from.caches" title="Constructing Responses from Caches">
<t>
   When presented with a request, a cache MUST NOT reuse a stored response,
   unless:
   <list style="symbols">
      <t>The presented effective request URI (Section 5.5 of <xref target="RFC7230"/>) and
      that of the stored response match, and</t>
      <t>the request method associated with the stored response allows it to
      be used for the presented request, and</t>
      <t>selecting header fields nominated by the stored response (if any)
      match those presented (see <xref target="caching.negotiated.responses"/>), and</t>
      <t>the presented request does not contain the no-cache pragma (<xref target="header.pragma"/>), nor the no-cache cache directive (<xref target="cache-request-directive"/>), unless the stored response is
      successfully validated (<xref target="validation.model"/>), and</t>
      <t>the stored response does not contain the no-cache cache directive
      (<xref target="cache-response-directive.no-cache"/>), unless it is
      successfully validated (<xref target="validation.model"/>), and</t>
      <t>the stored response is either:
         <list style="symbols">
            <t>fresh (see <xref target="expiration.model"/>), or</t>
            <t>allowed to be served stale (see <xref target="serving.stale.responses"/>), or</t>
            <t>successfully validated (see <xref target="validation.model"/>).</t>
         </list>
      </t>
  </list>
</t>
<t>
   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see <xref target="cache.control.extensions"/>.
</t>
<t>
   When a stored response is used to satisfy a request without validation, a
   cache MUST generate an <xref target="header.age" format="none">Age</xref> header field (<xref target="header.age"/>), replacing any present in the response with a value
   equal to the stored response's current_age; see <xref target="age.calculations"/>.
</t>
<t>
   A cache MUST write through requests with methods that are unsafe
   (Section 4.2.1 of <xref target="RFC7231"/>) to the origin server; i.e., a cache is not allowed to
   generate a reply to such a request before having forwarded the request and
   having received a corresponding response.
</t>
<t>
   Also, note that unsafe requests might invalidate already-stored responses;
   see <xref target="invalidation"/>.
</t>
<t>
   When more than one suitable response is stored, a cache MUST use the 
   most recent response (as determined by the Date header
   field). It can also forward the request with "Cache-Control: max-age=0" or
   "Cache-Control: no-cache" to disambiguate which response to use.
</t>
<t>
   A cache that does not have a clock available MUST NOT use stored
   responses without revalidating them upon every use.
</t>

<section anchor="caching.negotiated.responses" title="Calculating Secondary Keys with Vary">
<t>
   When a cache receives a request that can be satisfied by a stored response
   that has a Vary header field (Section 7.1.4 of <xref target="RFC7231"/>),
   it MUST NOT use that response unless all of the selecting header fields
   nominated by the Vary header field match in both the original request
   (i.e., that associated with the stored response), and the presented
   request.
</t>
<t>
   The selecting header fields from two requests are defined to match if and
   only if those in the first request can be transformed to those in the
   second request by applying any of the following:
   <list style="symbols">
      <t>
         adding or removing whitespace, where allowed in the header field's
         syntax
      </t>
      <t>
         combining multiple header fields with the same field name
         (see Section 3.2 of <xref target="RFC7230"/>)
      </t>
      <t>
         normalizing both header field values in a way that is known to have
         identical semantics, according to the header field's specification
         (e.g., reordering field values when order is not significant;
         case-normalization, where values are defined to be case-insensitive)
      </t>
  </list>
</t>
<t>
   If (after any normalization that might take place) a header field is absent
   from a request, it can only match another request if it is also absent
   there.
</t>
<t>
   A Vary header field-value of "*" always fails to match.
</t>
<t>
   The stored response with matching selecting header fields is known as the
   selected response.
</t>
<t>
   If multiple selected responses are available (potentially including
   responses without a Vary header field), the cache will need to choose one to use.
   When a selecting header field has a known mechanism for doing so (e.g., qvalues on
   Accept and similar request header fields), that mechanism MAY be
   used to select preferred responses; of the remainder, the most recent
   response (as determined by the Date header field) is used, as
   per <xref target="constructing.responses.from.caches"/>.
</t>
<t>
   If no selected response is available, the cache cannot satisfy the 
   presented request. Typically, it is forwarded to the origin server 
   in a (possibly conditional; see <xref target="validation.model"/>) request.
</t>
</section>

<section anchor="expiration.model" title="Freshness">
<iref item="fresh"/>
<iref item="stale"/>
<t>
   A fresh response is one whose age has not yet exceeded its
   freshness lifetime. Conversely, a stale
   response is one where it has.
</t>
<iref item="freshness lifetime"/>
<iref item="explicit expiration time"/>
<iref item="heuristic expiration time"/>
<t>
   A response's freshness lifetime is the length of time
   between its generation by the origin server and its expiration time. An
   explicit expiration time is the time at which the origin
   server intends that a stored response can no longer be used by a cache
   without further validation, whereas a heuristic expiration
   time is assigned by a cache when no explicit expiration time is
   available.
</t>
<iref item="age"/>
<t>
   A response's age is the time that has passed since it was
   generated by, or successfully validated with, the origin server.  
</t>
<t>
   When a response is "fresh" in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby improving
   efficiency.
</t>
<t>
   The primary mechanism for determining freshness is for an origin server to
   provide an explicit expiration time in the future, using either the
   <xref target="header.expires" format="none">Expires</xref> header field (<xref target="header.expires"/>) or
   the max-age response directive (<xref target="cache-response-directive.max-age"/>). Generally, origin servers
   will assign future explicit expiration times to responses in the belief
   that the representation is not likely to change in a semantically
   significant way before the expiration time is reached.
</t>
<t>
   If an origin server wishes to force a cache to validate every request, it
   can assign an explicit expiration time in the past to indicate that the
   response is already stale. Compliant caches will normally validate a stale
   cached response before reusing it for subsequent requests (see <xref target="serving.stale.responses"/>).
</t>
<t>
   Since origin servers do not always provide explicit expiration times,
   caches are also allowed to use a heuristic to determine an expiration time
   under certain circumstances (see <xref target="heuristic.freshness"/>).
</t>
<figure>
<preamble>
  The calculation to determine if a response is fresh is:
</preamble>
<artwork type="code"><![CDATA[
   response_is_fresh = (freshness_lifetime > current_age)
]]></artwork>
</figure>
<t>
   freshness_lifetime is defined in <xref target="calculating.freshness.lifetime"/>; current_age is defined in
   <xref target="age.calculations"/>.
</t>
<t>
   Clients can send the max-age or min-fresh cache directives in a request to
   constrain or relax freshness calculations for the corresponding response
   (<xref target="cache-request-directive"/>). 
</t>
<t>
   When calculating freshness, to avoid common problems in date parsing:
</t>
<t>
  <list style="symbols">
     <t>Although all date formats are specified to be case-sensitive, 
        a cache recipient SHOULD match day, week, and time-zone names
        case-insensitively.</t>
             
     <t>If a cache recipient's internal implementation of time has less
        resolution than the value of an HTTP-date, the recipient MUST
        internally represent a parsed <xref target="header.expires" format="none">Expires</xref> date as the
        nearest time equal to or earlier than the received value.</t>

     <t>A cache recipient MUST NOT allow local time zones to influence the
        calculation or comparison of an age or expiration time.</t>

     <t>A cache recipient SHOULD consider a date with a zone abbreviation
        other than GMT or UTC to be invalid for calculating expiration.</t>
  </list>
</t>
<t>
   Note that freshness applies only to cache operation; it cannot be used to
   force a user agent to refresh its display or reload a resource. See <xref target="history.lists"/> for an explanation of the difference between
   caches and history mechanisms.
</t>

<section anchor="calculating.freshness.lifetime" title="Calculating Freshness Lifetime">
<t>
   A cache can calculate the freshness lifetime (denoted as
   freshness_lifetime) of a response by using the first match of the following:
   <list style="symbols">
      <t>If the cache is shared and the s-maxage response directive
      (<xref target="cache-response-directive.s-maxage"/>) is present, use its value,
      or</t>
      <t>If the max-age response directive (<xref target="cache-response-directive.max-age"/>) is present, use its value, or</t>
      <t>If the <xref target="header.expires" format="none">Expires</xref> response header field
      (<xref target="header.expires"/>) is present, use its value minus the
      value of the Date response header field, or</t>
      <t>Otherwise, no explicit expiration time is present in the response. A
      heuristic freshness lifetime might be applicable; see <xref target="heuristic.freshness"/>.</t>
   </list>
</t>
<t>
   Note that this calculation is not vulnerable to clock skew, since all of
   the information comes from the origin server.
</t>
<t>
   When there is more than one value present for a given directive (e.g., two
   <xref target="header.expires" format="none">Expires</xref> header fields, multiple Cache-Control: max-age
   directives), the directive's value is considered invalid. Caches are
   encouraged to consider responses that have invalid freshness information to
   be stale.
</t>
</section>

<section anchor="heuristic.freshness" title="Calculating Heuristic Freshness">
<t>
   Since origin servers do not always provide explicit expiration times, a
   cache MAY assign a heuristic expiration time when an explicit time is not
   specified, employing algorithms that use other header field values (such as
   the Last-Modified time) to estimate a plausible expiration
   time. This specification does not provide specific algorithms, but does
   impose worst-case constraints on their results.
</t>
<t>
   A cache MUST NOT use heuristics to determine freshness when an explicit
   expiration time is present in the stored response. Because of the
   requirements in <xref target="response.cacheability"/>, this means that,
   effectively, heuristics can only be used on responses without explicit
   freshness whose status codes are defined as cacheable by default (see
   Section 6.1 of <xref target="RFC7231"/>), and those responses without explicit freshness that have
   been marked as explicitly cacheable (e.g., with a "public" response 
   directive).
</t>
<t>
   If the response has a Last-Modified header field
   (Section 2.2 of <xref target="RFC7232"/>), caches are encouraged to use a heuristic
   expiration value that is no more than some fraction of the interval since
   that time. A typical setting of this fraction might be 10%.
</t>
<t>
   When a heuristic is used to calculate freshness lifetime, a cache SHOULD
   generate a <xref target="header.warning" format="none">Warning</xref> header field with a 113 warn-code (see
   <xref target="warn.113"/>) in the response if its current_age is more than
   24 hours and such a warning is not already present.
</t>
<t><list>
   <t>
      Note: Section 13.9 of <xref target="RFC2616"/> prohibited caches
      from calculating heuristic freshness for URIs with query components
      (i.e., those containing '?'). In practice, this has not been widely
      implemented. Therefore, origin servers are encouraged to send explicit
      directives (e.g., Cache-Control: no-cache) if they wish to preclude
      caching.
   </t>
</list></t>
</section>

<section anchor="age.calculations" title="Calculating Age">
<t>
   The <xref target="header.age" format="none">Age</xref> header field is used to convey an estimated
   age of the response message when obtained from a cache. The Age field value
   is the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server. In essence, the Age value is
   the sum of the time that the response has been resident in each of the
   caches along the path from the origin server, plus the amount of time it
   has been in transit along network paths.
</t>
<t>
   The following data is used for the age calculation:
</t>
<t>
   age_value
   <list>
      <t>
         The term "age_value" denotes the value of the <xref target="header.age" format="none">Age</xref>
         header field (<xref target="header.age"/>), in a form appropriate for
         arithmetic operation; or 0, if not available.
      </t>
   </list>
</t>
<t>
   date_value
   <list>
      <t>
         The term "date_value" denotes the value of
         the Date header field, in a form appropriate for arithmetic
         operations. See Section 7.1.1.2 of <xref target="RFC7231"/> for the definition of the Date header
         field, and for requirements regarding responses without it.
      </t>
   </list>
</t>
<t>
   now
   <list>
      <t>
         The term "now" means "the current value of the clock at the host
         performing the calculation". A host ought to use NTP (<xref target="RFC5905"/>) or some similar protocol to synchronize its
         clocks to Coordinated Universal Time.
      </t>
   </list>
</t>
<t>
   request_time
   <list>
      <t>
         The current value of the clock at the host at the time the request
         resulting in the stored response was made.
      </t>
   </list>
</t>
<t>
   response_time
   <list>
      <t>
         The current value of the clock at the host at the time the response
         was received.
      </t>
   </list>
</t>
<t>
   A response's age can be calculated in two entirely independent ways:
   <list style="numbers">
      <t>the "apparent_age": response_time minus date_value, if the local
      clock is reasonably well synchronized to the origin server's clock. If
      the result is negative, the result is replaced by zero.</t>
      <t>the "corrected_age_value", if all of the caches along the response
      path implement HTTP/1.1. A cache MUST interpret this value relative
      to the time the request was initiated, not the time that the response
      was received.</t>
   </list>
</t>
<figure>
<artwork type="code"><![CDATA[
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;  
]]></artwork>
</figure>
<figure>
<preamble>These are combined as</preamble>
<artwork type="code"><![CDATA[
  corrected_initial_age = max(apparent_age, corrected_age_value);
]]></artwork></figure>
<t>
   unless the cache is confident in the value of the <xref target="header.age" format="none">Age</xref> header
   field (e.g., because there are no HTTP/1.0 hops in the Via
   header field), in which case the corrected_age_value MAY be used as the
   corrected_initial_age.
</t>
<t>
   The current_age of a stored response can then be calculated by adding the
   amount of time (in seconds) since the stored response was last validated by
   the origin server to the corrected_initial_age.
</t>
<figure><artwork type="code"><![CDATA[
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
]]></artwork></figure>
</section>

<section anchor="serving.stale.responses" title="Serving Stale Responses">
<t>
   A "stale" response is one that either has explicit expiry information or is
   allowed to have heuristic expiry calculated, but is not fresh according to
   the calculations in <xref target="expiration.model"/>.
</t>
<t>
   A cache MUST NOT generate a stale response if it is prohibited by an
   explicit in-protocol directive (e.g., by a "no-store" or "no-cache" cache
   directive, a "must-revalidate" cache-response-directive, or an applicable
   "s-maxage" or "proxy-revalidate" cache-response-directive; see <xref target="cache-response-directive"/>).
</t>
<t>
   A cache MUST NOT send stale responses unless it is disconnected
   (i.e., it cannot contact the origin server or otherwise find a forward
   path) or doing so is explicitly allowed (e.g., by the max-stale request
   directive; see <xref target="cache-request-directive"/>).
</t>
<t>
   A cache SHOULD generate a <xref target="header.warning" format="none">Warning</xref> header field with the
   110 warn-code (see <xref target="warn.110"/>) in stale responses.
   Likewise, a cache SHOULD generate a 112 warn-code (see
   <xref target="warn.112"/>) in stale responses if the cache is disconnected.
</t>
<t>
   A cache SHOULD NOT generate a new <xref target="header.warning" format="none">Warning</xref> header field
   when forwarding a response that does not have an <xref target="header.age" format="none">Age</xref> header
   field, even if the response is already stale.  A cache need not validate
   a response that merely became stale in transit.
</t>
</section>
</section>

<section anchor="validation.model" title="Validation">
<t>
   When a cache has one or more stored responses for a requested URI, but
   cannot serve any of them (e.g., because they are not fresh, or one cannot
   be selected; see <xref target="caching.negotiated.responses"/>), it can use
   the conditional request mechanism <xref target="RFC7232"/> in the forwarded request to
   give the next inbound server an opportunity to select a valid stored
   response to use, updating the stored metadata in the process, or to replace
   the stored response(s) with a new response. This process is known as
   "validating" or "revalidating" the stored response.
</t>

<section anchor="validation.sent" title="Sending a Validation Request"><iref item="validator"/>
<t>
   When sending a conditional request for cache validation, a cache sends one
   or more precondition header fields containing validator
   metadata from its stored response(s), which is then compared by recipients
   to determine whether a stored response is equivalent to a current
   representation of the resource.
</t>
<t>
   One such validator is the timestamp given in a Last-Modified
   header field (Section 2.2 of <xref target="RFC7232"/>), which can be used in an
   If-Modified-Since header field for response validation, or
   in an If-Unmodified-Since or If-Range header
   field for representation selection (i.e., the client is referring
   specifically to a previously obtained representation with that timestamp).
</t>
<t>
   Another validator is the entity-tag given in an ETag header
   field (Section 2.3 of <xref target="RFC7232"/>). One or more entity-tags, indicating one or more
   stored responses, can be used in an If-None-Match header
   field for response validation, or in an If-Match or
   If-Range header field for representation selection (i.e.,
   the client is referring specifically to one or more previously obtained
   representations with the listed entity-tags).
</t>
</section>

<section anchor="validation.received" title="Handling a Received Validation Request">
<t>
   Each client in the request chain may have its own cache, so it is common
   for a cache at an intermediary to receive conditional requests from other
   (outbound) caches. Likewise, some user agents make use of conditional
   requests to limit data transfers to recently modified representations or to
   complete the transfer of a partially retrieved representation.
</t>
<t>
   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content)
   responses, the cache SHOULD evaluate any applicable conditional header
   field preconditions received in that request with respect to the
   corresponding validators contained within the selected response.
   A cache MUST NOT evaluate conditional header fields that are only
   applicable to an origin server, found in a request with semantics that
   cannot be satisfied with a cached response, or applied to a target resource
   for which it has no stored responses; such preconditions are likely
   intended for some other (inbound) server.
</t>
<t>
   The proper evaluation of conditional requests by a cache depends on the
   received precondition header fields and their precedence, as defined in
   Section 6 of <xref target="RFC7232"/>. The If-Match and
   If-Unmodified-Since conditional header fields are not
   applicable to a cache.
</t>
<t>
   A request containing an If-None-Match header field
   (Section 3.2 of <xref target="RFC7232"/>) indicates that the client wants to validate one
   or more of its own stored responses in comparison to whichever stored
   response is selected by the cache.
   If the field-value is "*", or if the field-value is a list of entity-tags
   and at least one of them matches the entity-tag of the selected stored
   response, a cache recipient SHOULD generate a
   304 (Not Modified) response (using the metadata of the
   selected stored response) instead of sending that stored response.
</t>
<t>
   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags,
   the cache MAY combine the received list with a list of entity-tags
   from its own stored set of responses (fresh or stale) and send the union of
   the two lists as a replacement If-None-Match header
   field value in the forwarded request.
   If a stored response contains only partial content, the
   cache MUST NOT include its entity-tag in the union unless the request is
   for a range that would be fully satisfied by that partial stored response.
   If the response to the forwarded request is
   304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response metadata
   (<xref target="freshening.responses"/>).
</t>
<t>
   If an If-None-Match header field is not present, a request
   containing an If-Modified-Since header field
   (Section 3.3 of <xref target="RFC7232"/>) indicates that the client wants to validate
   one or more of its own stored responses by modification date.
   A cache recipient SHOULD generate a 304 (Not Modified)
   response (using the metadata of the selected stored response) if one of the
   following cases is true:
   1) the selected stored response has a Last-Modified
   field-value that is earlier than or equal to the conditional timestamp;
   2) no Last-Modified field is present in the selected stored
   response, but it has a Date field-value that is earlier than
   or equal to the conditional timestamp; or,
   3) neither Last-Modified nor Date is present
   in the selected stored response, but the cache recorded it as having been
   received at a time earlier than or equal to the conditional timestamp.
</t>
<t>
   A cache that implements partial responses to range requests, as defined in
   <xref target="RFC7233"/>, also needs to evaluate a received If-Range header
   field (Section 3.2 of <xref target="RFC7233"/>) with respect to its selected stored response.
</t>
</section>

<section anchor="validation.response" title="Handling a Validation Response">
<t>
   Cache handling of a response to a conditional request is dependent upon its
   status code:
</t>
<t>
   <list style="symbols">
      <t>
         A 304 (Not Modified) response status code indicates
         that the stored response can be updated and reused; see <xref target="freshening.responses"/>.
      </t>
      <t>
         A full response (i.e., one with a payload body) indicates that none
         of the stored responses nominated in the conditional request is
         suitable. Instead, the cache MUST use the full response to
         satisfy the request and MAY replace the stored response(s).
      </t>
      <t>
         However, if a cache receives a 5xx (Server Error)
         response while attempting to validate a response, it can either
         forward this response to the requesting client, or act as if the
         server failed to respond. In the latter case, the cache MAY send a
         previously stored response (see <xref target="serving.stale.responses"/>).
      </t>
   </list>
</t>
</section>

<section anchor="freshening.responses" title="Freshening Stored Responses upon Validation">
<t>
   When a cache receives a 304 (Not Modified) response and
   already has one or more stored 200 (OK) responses for the
   same cache key, the cache needs to identify which of the stored responses
   are updated by this new response and then update the stored response(s)
   with the new information provided in the 304 response.
</t>
<iref item="strong validator"/>
<t>
   The stored response to update is identified by using the first match (if
   any) of the following:
   <list style="symbols">
    <t>
     If the new response contains a strong validator (see
     Section 2.1 of <xref target="RFC7232"/>), then that strong validator identifies the selected
     representation for update. All of the stored responses with the same
     strong validator are selected. If none of the stored responses contain the
     same strong validator, then the cache MUST NOT use the new response to
     update any stored responses.
    </t>
    <t>
     If the new response contains a weak validator and that validator
     corresponds to one of the cache's stored responses, then the most
     recent of those matching stored responses is selected for update.
    </t>
    <t>
     If the new response does not include any form of validator (such as in
     the case where a client generates an If-Modified-Since request from a
     source other than the Last-Modified response header field), and there is
     only one stored response, and that stored response also lacks a
     validator, then that stored response is selected for update.
    </t>
   </list>
</t>
<t>
   If a stored response is selected for update, the cache MUST:
   <list style="symbols">
      <t>delete any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning"/>);</t>
      <t>retain any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the 304 (Not Modified)
         response to replace all instances of the corresponding header
         fields in the stored response.</t>
   </list>
</t>
</section>

<section anchor="head.effects" title="Freshening Responses via HEAD">
<t>
   A response to the HEAD method is identical to what an equivalent request
   made with a GET would have been, except it lacks a body. This property
   of HEAD responses can be used to invalidate or update a cached GET
   response if the more efficient conditional GET request mechanism is not
   available (due to no validators being present in the stored response) or
   if transmission of the representation body is not desired even if it has
   changed.
</t>
<t>
   When a cache makes an inbound HEAD request for a given request target and
   receives a 200 (OK) response, the cache SHOULD update or
   invalidate each of its stored GET responses that could have been selected
   for that request (see <xref target="caching.negotiated.responses"/>).
</t>
<t>
   For each of the stored responses that could have been selected, if the
   stored response and HEAD response have matching values for any received
   validator fields (ETag and Last-Modified)
   and, if the HEAD response has a Content-Length header field,
   the value of Content-Length matches that of the stored
   response, the cache SHOULD update the stored response as described below;
   otherwise, the cache SHOULD consider the stored response to be stale.
</t>
<t>
   If a cache updates a stored response with the metadata provided in a HEAD
   response, the cache MUST:
   <list style="symbols">
      <t>delete any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 1xx (see <xref target="header.warning"/>);</t>
      <t>retain any <xref target="header.warning" format="none">Warning</xref> header fields in the stored response
         with warn-code 2xx; and,</t>
      <t>use other header fields provided in the HEAD response to replace all
         instances of the corresponding header fields in the stored response
         and append new header fields to the stored response's header section
         unless otherwise restricted by the <xref target="header.cache-control" format="none">Cache-Control</xref>
         header field.</t>
   </list>
</t>
</section>
</section>


<section anchor="invalidation" title="Invalidation">
<t>
   Because unsafe request methods (Section 4.2.1 of <xref target="RFC7231"/>) such as PUT, POST or DELETE
   have the potential for changing state on the origin server, intervening
   caches can use them to keep their contents up to date.
</t>
<t>
   A cache MUST invalidate the effective Request URI
   (Section 5.5 of <xref target="RFC7230"/>) as well as the URI(s) in the
   Location and Content-Location response header
   fields (if present) when a non-error status code is received in response to
   an unsafe request method.
</t>
<t>
   However, a cache MUST NOT invalidate a URI from a Location
   or Content-Location response header field if the host part of
   that URI differs from the host part in the effective request URI
   (Section 5.5 of <xref target="RFC7230"/>). This helps prevent denial-of-service attacks.
</t>
<t>
   A cache MUST invalidate the effective request URI 
   (Section 5.5 of <xref target="RFC7230"/>) when it receives a non-error response 
   to a request with a method whose safety is unknown.
</t>
<t>
   Here, a "non-error response" is one with a 2xx (Successful)
   or 3xx (Redirection) status code. "Invalidate" means that
   the cache will either remove all stored responses related to the effective
   request URI or will mark these as "invalid" and in need of a mandatory
   validation before they can be sent in response to a subsequent request.
</t>
<t>
   Note that this does not guarantee that all appropriate responses are
   invalidated. For example, a state-changing request might invalidate
   responses in the caches it travels through, but relevant responses still
   might be stored in other caches that it has not.</t>
</section>
</section>



<section anchor="header.field.definitions" title="Header Field Definitions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to caching.
</t>

<section anchor="header.age" title="Age">
   <iref item="Age header field" primary="true"/>
   
   
<t>
   The "Age" header field conveys the sender's estimate of the amount
   of time since the response was generated or successfully validated at the
   origin server. Age values are calculated as specified in <xref target="age.calculations"/>.
</t>
<figure><iref primary="true" item="Grammar" subitem="Age"/><artwork type="abnf2616"><![CDATA[
  Age = delta-seconds
]]></artwork></figure>
<t>
   The Age field-value is a non-negative integer, representing time in seconds
   (see <xref target="delta-seconds"/>).
</t>
<t>
   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request. However,
   lack of an Age header field does not imply the origin was contacted, since
   the response might have been received from an HTTP/1.0 cache that does not
   implement Age.
</t>
</section>

<section anchor="header.cache-control" title="Cache-Control">
   <iref item="Cache-Control header field" primary="true"/>
   
   
<t>
   The "Cache-Control" header field is used to specify directives for
   caches along the request/response chain. Such cache directives are
   unidirectional in that the presence of a directive in a request does not
   imply that the same directive is to be given in the response.
</t>
<t>
   A cache MUST obey the requirements of the Cache-Control
   directives defined in this section. See <xref target="cache.control.extensions"/> for information about how Cache-Control
   directives defined elsewhere are handled.
</t>
<t><list>
   <t>
       Note: Some HTTP/1.0 caches might not implement Cache-Control.
   </t>
</list></t>
<t>
   A proxy, whether or not it implements a cache, MUST pass cache directives
   through in forwarded messages, regardless of their 
   significance to that application, since the directives might be applicable 
   to all recipients along the request/response chain. It is not possible to 
   target a directive to a specific cache.
</t>
<t>
   Cache directives are identified by a token, to be compared case-insensitively,
   and have an optional argument, that can use both token and quoted-string
   syntax. For the directives defined below that define arguments, recipients
   ought to accept both forms, even if one is documented to be preferred. For
   any directive not defined by this specification, a recipient MUST accept
   both forms. 
</t>
<figure><iref primary="true" item="Grammar" subitem="Cache-Control"/><iref primary="true" item="Grammar" subitem="cache-directive"/><artwork type="abnf2616"><![CDATA[
  Cache-Control   = 1#cache-directive

  cache-directive = token [ "=" ( token / quoted-string ) ]
]]></artwork></figure>
<t>
   For the cache directives defined below, no argument is defined (nor allowed)
   unless stated otherwise.
</t>

<section title="Request Cache-Control Directives" anchor="cache-request-directive">

<section title="max-age" anchor="cache-request-directive.max-age">
   <iref item="max-age (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        <xref target="delta-seconds" format="none">delta-seconds</xref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-age" request directive indicates that the client is unwilling
   to accept a response whose age is greater than the specified number of
   seconds. Unless the max-stale request directive is also present, the client
   is not willing to accept a stale response.
</t>
<t>
   This directive uses the token form of the argument syntax:
   e.g., 'max-age=5' not 'max-age="5"'. A sender SHOULD NOT generate the
   quoted-string form.
</t>
</section>

<section title="max-stale" anchor="cache-request-directive.max-stale">
   <iref item="max-stale (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        <xref target="delta-seconds" format="none">delta-seconds</xref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-stale" request directive indicates that the client is willing
   to accept a response that has exceeded its freshness lifetime. If max-stale
   is assigned a value, then the client is willing to accept a response
   that has exceeded its freshness lifetime by no more than the specified
   number of seconds. If no value is assigned to max-stale, then the client
   is willing to accept a stale response of any age.
</t>
<t>
   This directive uses the token form of the argument syntax:
   e.g., 'max-stale=10' not 'max-stale="10"'. A sender SHOULD NOT generate
   the quoted-string form.
</t>
</section>

<section title="min-fresh" anchor="cache-request-directive.min-fresh">
   <iref item="min-fresh (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        <xref target="delta-seconds" format="none">delta-seconds</xref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "min-fresh" request directive indicates that the client is willing
   to accept a response whose freshness lifetime is no less than its
   current age plus the specified time in seconds. That is, the client
   wants a response that will still be fresh for at least the specified
   number of seconds.
</t>
<t>
   This directive uses the token form of the argument syntax:
   e.g., 'min-fresh=20' not 'min-fresh="20"'. A sender SHOULD NOT generate
   the quoted-string form.
</t>
</section>

<section title="no-cache" anchor="cache-request-directive.no-cache">
   <iref item="no-cache (cache directive)" primary="true"/>
<t>
   The "no-cache" request directive indicates that a cache MUST NOT 
   use a stored response to satisfy the request without successful 
   validation on the origin server.
</t>
</section>
 
<section title="no-store" anchor="cache-request-directive.no-store">
   <iref item="no-store (cache directive)" primary="true"/>
<t>
   The "no-store" request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it. This
   directive applies to both private and shared caches. "MUST NOT
   store" in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage as
   promptly as possible after forwarding it.
</t>
<t>
   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy. In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might be
   vulnerable to eavesdropping.
</t>
<t>
   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.
</t>
</section>

<section title="no-transform" anchor="cache-request-directive.no-transform">
   <iref item="no-transform (cache directive)" primary="true"/>
<t>
   The "no-transform" request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the payload,
   as defined in Section 5.7.2 of <xref target="RFC7230"/>.
</t>
</section>

<section title="only-if-cached" anchor="cache-request-directive.only-if-cached">
   <iref item="only-if-cached (cache directive)" primary="true"/>
<t>
   The "only-if-cached" request directive indicates that the client only wishes
   to obtain a stored response. If it receives this directive, a cache SHOULD
   either respond using a stored response that is consistent with the other
   constraints of the request, or respond with a 504 (Gateway
   Timeout) status code. If a group of caches is being operated as a
   unified system with good internal connectivity, a member cache MAY
   forward such a request within that group of caches.
</t>
</section>
</section>

<section anchor="cache-response-directive" title="Response Cache-Control Directives">
   

<section title="must-revalidate" anchor="cache-response-directive.must-revalidate">
   <iref item="must-revalidate (cache directive)" primary="true"/>
<t>
   The "must-revalidate" response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.
</t>
<t>
   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features. In all circumstances a
   cache MUST obey the must-revalidate directive; in particular,
   if a cache cannot reach the origin server for any reason, it MUST
   generate a 504 (Gateway Timeout) response.
</t>
<t>
   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result in
   incorrect operation, such as a silently unexecuted financial
   transaction.
</t>
</section>

<section title="no-cache" anchor="cache-response-directive.no-cache">
   <iref item="no-cache (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        #<xref target="imported.abnf" format="none">field-name</xref>
      </t>
   </list>
</t>
<t>
   The "no-cache" response directive indicates that the response MUST NOT
   be used to satisfy a subsequent request without successful validation on
   the origin server. This allows an origin server to prevent a cache from
   using it to satisfy a request without contacting it, even by caches that
   have been configured to send stale responses.
</t>
<t>
   If the no-cache response directive specifies one or more field-names,
   then a cache MAY use the response to satisfy a subsequent request,
   subject to any other restrictions on caching. However, any header fields
   in the response that have the field-name(s) listed MUST NOT be sent
   in the response to a subsequent request without successful revalidation
   with the origin server. This allows an origin server to prevent the
   re-use of certain header fields in a response, while still allowing
   caching of the rest of the response.
</t> 
<t>
   The field-names given are not limited to the set of header
   fields defined by this specification. Field names are case-insensitive.
</t>
<t>
   This directive uses the quoted-string form of the argument syntax.
   A sender SHOULD NOT generate the token form (even if quoting appears not
   to be needed for single-entry lists).
</t>
<t>
   Note: Although it has been back-ported to many implementations, some
   HTTP/1.0 caches will not recognize or obey this directive. Also, no-cache
   response directives with field-names are often handled by caches
   as if an unqualified no-cache directive was received; i.e., the special
   handling for the qualified form is not widely implemented.
</t>
</section>

<section title="no-store" anchor="cache-response-directive.no-store">
   <iref item="no-store (cache directive)" primary="true"/>
<t>
   The "no-store" response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response. This
   directive applies to both private and shared caches. "MUST NOT
   store" in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage as
   promptly as possible after forwarding it.
</t>
<t>
   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy. In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might be
   vulnerable to eavesdropping.
</t>
</section>

<section title="no-transform" anchor="cache-response-directive.no-transform">
   <iref item="no-transform (cache directive)" primary="true"/>
<t>
   The "no-transform" response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in Section 5.7.2 of <xref target="RFC7230"/>.
</t>
</section>

<section title="public" anchor="cache-response-directive.public">
   <iref item="public (cache directive)" primary="true"/>
<t>
   The "public" response directive indicates that any cache MAY store the
   response, even if the response would normally be non-cacheable or cacheable
   only within a private cache. (See <xref target="caching.authenticated.responses"/> for additional details related to
   the use of public in response to a request containing
   Authorization, and <xref target="response.cacheability"/> for
   details of how public affects responses that would normally not be stored,
   due to their status codes not being defined as cacheable by default; see
   <xref target="heuristic.freshness"/>.)
</t>
</section>

<section title="private" anchor="cache-response-directive.private">
   <iref item="private (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        #<xref target="imported.abnf" format="none">field-name</xref>
      </t>
   </list>
</t>
<t>
   The "private" response directive indicates that the response message is
   intended for a single user and MUST NOT be stored by a shared cache. A
   private cache MAY store the response and reuse it for later requests,
   even if the response would normally be non-cacheable.
</t>
<t>
   If the private response directive specifies one or more field-names,
   this requirement is limited to the field-values associated with the
   listed response header fields. That is, a shared cache MUST NOT store
   the specified field-names(s), whereas it MAY store the remainder of the
   response message.
</t>
<t>
   The field-names given are not limited to the set of header
   fields defined by this specification. Field names are case-insensitive.
</t>
<t>
   This directive uses the quoted-string form of the argument syntax.
   A sender SHOULD NOT generate the token form (even if quoting appears not
   to be needed for single-entry lists).
</t>
<t>
   Note: This usage of the word "private" only controls
   where the response can be stored; it cannot ensure the privacy of the
   message content. Also, private response directives with field-names are
   often handled by caches as if an unqualified private directive
   was received; i.e., the special handling for the qualified form is not
   widely implemented.
</t>
</section>

<section title="proxy-revalidate" anchor="cache-response-directive.proxy-revalidate">
   <iref item="proxy-revalidate (cache directive)" primary="true"/>
<t>
   The "proxy-revalidate" response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.
</t>
</section>

<section title="max-age" anchor="cache-response-directive.max-age">
   <iref item="max-age (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        <xref target="delta-seconds" format="none">delta-seconds</xref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "max-age" response directive indicates that the response is to be
   considered stale after its age is greater than the specified number of
   seconds.
</t>
<t>
   This directive uses the token form of the argument syntax:
   e.g., 'max-age=5' not 'max-age="5"'. A sender SHOULD NOT generate the
   quoted-string form.
</t>
</section>      

<section title="s-maxage" anchor="cache-response-directive.s-maxage">
   <iref item="s-maxage (cache directive)" primary="true"/>
<t>
   Argument syntax:
   <list>
      <t>
        <xref target="delta-seconds" format="none">delta-seconds</xref> (see <xref target="delta-seconds"/>)
      </t>
   </list>
</t>
<t>
   The "s-maxage" response directive indicates that, in shared caches, the
   maximum age specified by this directive overrides the maximum age
   specified by either the max-age directive or the <xref target="header.expires" format="none">Expires</xref>
   header field. The s-maxage directive also implies the semantics of the
   proxy-revalidate response directive.
</t>
<t>
   This directive uses the token form of the argument syntax:
   e.g., 's-maxage=10' not 's-maxage="10"'. A sender SHOULD NOT generate
   the quoted-string form.
</t>
</section>

</section>

<section anchor="cache.control.extensions" title="Cache Control Extensions">
<t>
   The Cache-Control header field can be extended through the use of one or
   more cache-extension tokens, each with an optional value.
   A cache MUST ignore unrecognized cache directives.
</t>
<t>
   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other directives.
</t>
<t>   
   Behavioral extensions are designed to work by acting as modifiers to the
   existing base of cache directives.
   Both the new directive and the old directive are supplied, such that
   applications that do not understand the new directive will default to the
   behavior specified by the old directive, and those that understand the
   new directive will recognize it as modifying the requirements associated
   with the old directive. In this way, extensions to the existing
   cache-control directives can be made without breaking deployed caches.
</t>
<t>
   For example, consider a hypothetical new response directive called
   "community" that acts as a modifier to the private directive: in addition
   to private caches, any cache that is shared only by members of the named
   community is allowed to cache the response. An origin server wishing to
   allow the UCI community to use an otherwise private response in their
   shared cache(s) could do so by including
</t>
<figure><artwork type="example"><![CDATA[
  Cache-Control: private, community="UCI"
]]></artwork></figure>
<t>
   A cache that recognizes such a community cache-extension could broaden its
   behavior in accordance with that extension.  A cache that does not
   recognize the community cache-extension would ignore it and adhere to the
   private directive.
</t>
</section>

</section>

<section anchor="header.expires" title="Expires">
   <iref item="Expires header field" primary="true"/>
   
<t>
   The "Expires" header field gives the date/time after which the
   response is considered stale. See <xref target="expiration.model"/> for
   further discussion of the freshness model.
</t>
<t>
   The presence of an Expires field does not imply that the original resource
   will change or cease to exist at, before, or after that time.
</t>
<t>
   The Expires value is an HTTP-date timestamp, as defined in Section 7.1.1.1 of <xref target="RFC7231"/>.
</t>
<figure><iref primary="true" item="Grammar" subitem="Expires"/><artwork type="abnf2616"><![CDATA[
  Expires = HTTP-date
]]></artwork></figure>
<figure>
  <preamble>For example</preamble>
<artwork type="example"><![CDATA[
  Expires: Thu, 01 Dec 1994 16:00:00 GMT
]]></artwork></figure>
<t>
   A cache recipient MUST interpret invalid date formats, especially the
   value "0", as representing a time in the past (i.e., "already expired").
</t>
<t>
   If a response includes a <xref target="header.cache-control" format="none">Cache-Control</xref> field with
   the max-age directive (<xref target="cache-response-directive.max-age"/>),
   a recipient MUST ignore the Expires field.
   Likewise, if a response includes the s-maxage directive
   (<xref target="cache-response-directive.s-maxage"/>), a shared cache
   recipient MUST ignore the Expires field. In both these cases, the value
   in Expires is only intended for recipients that have not yet implemented
   the Cache-Control field.
</t>
<t>
   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or user
   with a reliable clock.
</t>
<t>
   Historically, HTTP required the Expires field-value to be no more than a 
   year in the future. While longer freshness lifetimes are no longer 
   prohibited, extremely large values have been demonstrated to cause 
   problems (e.g., clock overflows due to use of 32-bit integers for 
   time values), and many caches will evict a response far sooner than 
   that.
</t>
</section>

<section anchor="header.pragma" title="Pragma">
   <iref item="Pragma header field" primary="true"/>
   
   
   
<t>
   The "Pragma" header field allows backwards compatibility with HTTP/1.0
   caches, so that clients can specify a "no-cache" request that they will
   understand (as <xref target="header.cache-control" format="none">Cache-Control</xref> was not defined until HTTP/1.1).
   When the Cache-Control header field is also present and understood in a
   request, Pragma is ignored.
</t>
<t>
   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients. This specification
   deprecates such extensions to improve interoperability.
</t>
<figure><iref primary="true" item="Grammar" subitem="Pragma"/><iref primary="true" item="Grammar" subitem="pragma-directive"/><iref primary="true" item="Grammar" subitem="extension-pragma"/><artwork type="abnf2616"><![CDATA[
  Pragma           = 1#pragma-directive
  pragma-directive = "no-cache" / extension-pragma
  extension-pragma = token [ "=" ( token / quoted-string ) ]
]]></artwork></figure>
<t>
   When the <xref target="header.cache-control" format="none">Cache-Control</xref> header field is not present in a
   request, caches MUST consider the no-cache request pragma-directive as
   having the same effect as if "Cache-Control: no-cache" were present (see
   <xref target="cache-request-directive"/>).
</t>
<t>
   When sending a no-cache request, a client ought to include both the pragma
   and cache-control directives, unless Cache-Control: no-cache is
   purposefully omitted to target other <xref target="header.cache-control" format="none">Cache-Control</xref> response
   directives at HTTP/1.1 caches. For example:
</t>
<figure>
<artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
  GET / HTTP/1.1
  Host: www.example.com
  Cache-Control: max-age=30
  Pragma: no-cache
  
  ]]></artwork>
</figure>
<t>
   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   <xref target="header.cache-control" format="none">Cache-Control</xref> from serving a cached response.
</t>
<t><list>
   <t>
      Note: Because the meaning of "Pragma: no-cache" in responses is not
      specified, it does not provide a reliable replacement for
      "Cache-Control: no-cache" in them.
   </t>
</list></t>
</section>

<section anchor="header.warning" title="Warning">
   <iref item="Warning header field" primary="true"/>
   
   
   
   
   
   
<t>
   The "Warning" header field is used to carry additional information
   about the status or transformation of a message that might not be reflected
   in the status code. This information is typically used to warn about possible
   incorrectness introduced by caching operations or transformations applied
   to the payload of the message.
</t>
<t>
   Warnings can be used for other purposes, both cache-related and otherwise.
   The use of a warning, rather than an error status code, distinguishes these
   responses from true failures.
</t>
<t>
   Warning header fields can in general be applied to any message, however some
   warn-codes are specific to caches and can only be applied to response
   messages.
</t>
<figure><iref primary="true" item="Grammar" subitem="Warning"/><iref primary="true" item="Grammar" subitem="warning-value"/><iref primary="true" item="Grammar" subitem="warn-code"/><iref primary="true" item="Grammar" subitem="warn-agent"/><iref primary="true" item="Grammar" subitem="warn-text"/><iref primary="true" item="Grammar" subitem="warn-date"/><artwork type="abnf2616"><![CDATA[
  Warning       = 1#warning-value
  
  warning-value = warn-code SP warn-agent SP warn-text
                                        [ SP warn-date ]
  
  warn-code  = 3DIGIT
  warn-agent = ( uri-host [ ":" port ] ) / pseudonym
                  ; the name or pseudonym of the server adding
                  ; the Warning header field, for use in debugging
                  ; a single "-" is recommended when agent unknown
  warn-text  = quoted-string
  warn-date  = DQUOTE HTTP-date DQUOTE
]]></artwork></figure>
<t>
   Multiple warnings can be generated in a response (either by the origin
   server or by a cache), including multiple warnings with the same warn-code
   number that only differ in warn-text.
</t>
<t>
   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that they
   appear in the response. Senders that generate multiple Warning header
   fields are encouraged to order them with this user agent behavior in mind.
   A sender that generates new Warning header fields MUST append them after
   any existing Warning header fields.
</t>
<t>
   Warnings are assigned three digit warn-codes. The first digit indicates
   whether the Warning is required to be deleted from a stored response after
   validation:
   <list style="symbols">
      <t>1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation. They can
      only be generated by a cache when validating a cached entry, and
      MUST NOT be generated in any other situation.</t>
      <t>2xx warn-codes describe some aspect of the representation that is not
      rectified by a validation (for example, a lossy compression of the
      representation) and they MUST NOT be deleted by a cache after validation,
      unless a full response is sent, in which case they MUST be.</t>
   </list>
</t>
<t>
   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches the
   Date header field in the message. For example:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
  HTTP/1.1 200 OK
  Date: Sat, 25 Aug 2012 23:34:45 GMT
  Warning: 112 - "network down" "Sat, 25 Aug 2012 23:34:45 GMT"
  
  ]]></artwork></figure>
<t>
  Warnings have accompanying warn-text that describes the error, e.g., for
  logging. It is advisory only, and its content does not affect interpretation
  of the warn-code.
</t>
<t>
   If a recipient that uses, evaluates, or displays Warning header fields
   receives a warn-date that is different from the Date value
   in the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the message.
   This allows recipients to exclude warning-values that were improperly
   retained after a cache validation.
   If all of the warning-values are excluded, the recipient MUST exclude
   the Warning header field as well.
</t>
<t>
   The following warn-codes are defined by this specification, each with a
   recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   <xref target="warn.code.registry.procedure"/>.
</t>

<section title="Warning: 110 - &#34;Response is Stale&#34;" anchor="warn.110">
  <iref primary="true" item="110 (warn-code)"/>
  <iref primary="true" item="Response is Stale (warn-text)"/>
<t>
   A cache SHOULD generate this whenever the sent response is stale.
</t>
</section>

<section title="Warning: 111 - &#34;Revalidation Failed&#34;" anchor="warn.111">
  <iref primary="true" item="111 (warn-code)"/>
  <iref primary="true" item="Revalidation Failed (warn-text)"/>
<t>
   A cache SHOULD generate this when sending a stale response because an
   attempt to validate the response failed, due to an inability to reach
   the server.
</t>
</section>

<section title="Warning: 112 - &#34;Disconnected Operation&#34;" anchor="warn.112">
  <iref primary="true" item="112 (warn-code)"/>
  <iref primary="true" item="Disconnected Operation (warn-text)"/>
<t>
   A cache SHOULD generate this if it is intentionally disconnected from
   the rest of the network for a period of time.
</t>
</section>

<section title="Warning: 113 - &#34;Heuristic Expiration&#34;" anchor="warn.113">
  <iref primary="true" item="113 (warn-code)"/>
  <iref primary="true" item="Heuristic Expiration (warn-text)"/>
<t>
   A cache SHOULD generate this if it heuristically chose a freshness
   lifetime greater than 24 hours and the response's age is greater than 24
   hours.
</t>
</section>

<section title="Warning: 199 - &#34;Miscellaneous Warning&#34;" anchor="warn.199">
  <iref primary="true" item="199 (warn-code)"/>
  <iref primary="true" item="Miscellaneous Warning (warn-text)"/>
<t>
   The warning text can include arbitrary information to be presented to
   a human user or logged. A system receiving this warning MUST NOT take
   any automated action, besides presenting the warning to the user.
</t>
</section>

<section title="Warning: 214 - &#34;Transformation Applied&#34;" anchor="warn.214">
  <iref primary="true" item="214 (warn-code)"/>
  <iref primary="true" item="Transformation Applied (warn-text)"/>
<t>
   This Warning code MUST be added by a proxy if it applies any transformation to the
   representation, such as changing the content-coding, media-type, or
   modifying the representation data, unless this Warning code already appears
   in the response.
</t>
</section>

<section title="Warning: 299 - &#34;Miscellaneous Persistent Warning&#34;" anchor="warn.299">
  <iref primary="true" item="299 (warn-code)"/>
  <iref primary="true" item="Miscellaneous Persistent Warning (warn-text)"/>
<t>
   The warning text can include arbitrary information to be presented to
   a human user or logged. A system receiving this warning MUST NOT take
   any automated action.
</t>
</section>
</section>
</section>

<section anchor="history.lists" title="History Lists">
<t>
   User agents often have history mechanisms, such as "Back" buttons and
   history lists, that can be used to redisplay a representation retrieved
   earlier in a session.
</t>
<t>
   The freshness model (<xref target="expiration.model"/>) does not
   necessarily apply to history mechanisms. That is, a history mechanism can
   display a previous representation even if it has expired.
</t>
<t>
   This does not prohibit the history mechanism from telling the user that a
   view might be stale or from honoring cache directives (e.g.,
   Cache-Control: no-store).
</t>
</section>


<section title="IANA Considerations" anchor="iana.considerations">

<section title="Cache Directive Registry" anchor="cache.directive.registry">
<t>
   The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry" defines the namespace for the
   cache directives. It has been created and is now maintained at
   &lt;http://www.iana.org/assignments/http-cache-directives&gt;.
</t>

<section title="Procedure" anchor="cache.directive.registry.procedure">
<t>
   A registration MUST include the following fields:
   <list style="symbols">
      <t>Cache Directive Name</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to this namespace require IETF Review (see <xref target="RFC5226"/>, Section 4.1).
</t>
</section>

<section title="Considerations for New Cache Control Directives" anchor="cache.directive.considerations">
<t>
   New extension directives ought to consider defining:
</t>
<t>
   <list style="symbols">
      <t>What it means for a directive to be specified multiple times,</t>
      <t>When the directive does not take an argument, what it means when an
      argument is present,</t>
      <t>When the directive requires an argument, what it means when it is
      missing,</t>
      <t>Whether the directive is specific to requests, responses, or able
        to be used in either.</t>
   </list>
</t>
<t>
  See also <xref target="cache.control.extensions"/>.
</t>
</section>

<section title="Registrations" anchor="cache.directive.registration">
<t>
  The registry has been populated with the registrations below:
</t>

<texttable align="left" suppress-title="true" anchor="iana.cache.directive.registration.table">
   <ttcol>Cache Directive</ttcol>
   <ttcol>Reference</ttcol>

   <c>max-age</c>
   <c>
      <xref target="cache-request-directive.max-age"/>, <xref target="cache-response-directive.max-age"/>
   </c>
   <c>max-stale</c>
   <c>
      <xref target="cache-request-directive.max-stale"/>
   </c>
   <c>min-fresh</c>
   <c>
      <xref target="cache-request-directive.min-fresh"/>
   </c>
   <c>must-revalidate</c>
   <c>
      <xref target="cache-response-directive.must-revalidate"/>
   </c>
   <c>no-cache</c>
   <c>
      <xref target="cache-request-directive.no-cache"/>, <xref target="cache-response-directive.no-cache"/>
   </c>
   <c>no-store</c>
   <c>
      <xref target="cache-request-directive.no-store"/>, <xref target="cache-response-directive.no-store"/>
   </c>
   <c>no-transform</c>
   <c>
      <xref target="cache-request-directive.no-transform"/>, <xref target="cache-response-directive.no-transform"/>
   </c>
   <c>only-if-cached</c>
   <c>
      <xref target="cache-request-directive.only-if-cached"/>
   </c>
   <c>private</c>
   <c>
      <xref target="cache-response-directive.private"/>
   </c>
   <c>proxy-revalidate</c>
   <c>
      <xref target="cache-response-directive.proxy-revalidate"/>
   </c>
   <c>public</c>
   <c>
      <xref target="cache-response-directive.public"/>
   </c>
   <c>s-maxage</c>
   <c>
      <xref target="cache-response-directive.s-maxage"/>
   </c>
   <c>stale-if-error</c>
   <c>
      <xref target="RFC5861"/>, Section 4
   </c>
   <c>stale-while-revalidate</c>
   <c>
      <xref target="RFC5861"/>, Section 3
   </c>
</texttable>
<!--(END)-->

</section>
</section>

<section title="Warn Code Registry" anchor="warn.code.registry">
<t>
   The "Hypertext Transfer Protocol (HTTP) Warn Codes" registry defines the namespace for warn codes.
   It has been created and is now maintained at
   &lt;http://www.iana.org/assignments/http-warn-codes&gt;.
</t>

<section title="Procedure" anchor="warn.code.registry.procedure">
<t>
   A registration MUST include the following fields:
   <list style="symbols">
      <t>Warn Code (3 digits)</t>
      <t>Short Description</t>
      <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Values to be added to this namespace require IETF Review (see <xref target="RFC5226"/>, Section 4.1).
</t>
</section>

<section title="Registrations" anchor="warn.code.registration">
<t>
  The registry has been populated with the registrations below:
</t>

<texttable align="left" suppress-title="true" anchor="iana.warn.code.registration.table">
   <ttcol>Warn Code</ttcol>
   <ttcol>Short Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>110</c>
   <c>Response is Stale</c>
   <c>
      <xref target="warn.110"/>
   </c>
   <c>111</c>
   <c>Revalidation Failed</c>
   <c>
      <xref target="warn.111"/>
   </c>
   <c>112</c>
   <c>Disconnected Operation</c>
   <c>
      <xref target="warn.112"/>
   </c>
   <c>113</c>
   <c>Heuristic Expiration</c>
   <c>
      <xref target="warn.113"/>
   </c>
   <c>199</c>
   <c>Miscellaneous Warning</c>
   <c>
      <xref target="warn.199"/>
   </c>
   <c>214</c>
   <c>Transformation Applied</c>
   <c>
      <xref target="warn.214"/>
   </c>
   <c>299</c>
   <c>Miscellaneous Persistent Warning</c>
   <c>
      <xref target="warn.299"/>
   </c>
</texttable>

</section>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the "Message Headers" registry
   maintained at
   &lt;http://www.iana.org/assignments/message-headers/&gt;.
</t>
<t>
   This document defines the following HTTP header fields, so the
   "Permanent Message Header Field Names" registry has been updated
   accordingly (see <xref target="BCP90"/>).
</t>

<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Age</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.age"/>
   </c>
   <c>Cache-Control</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.cache-control"/>
   </c>
   <c>Expires</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.expires"/>
   </c>
   <c>Pragma</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.pragma"/>
   </c>
   <c>Warning</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.warning"/>
   </c>
</texttable>

<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task
   Force".
</t>
</section>
</section>

<section anchor="security.considerations" title="Security Considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security concerns specific to HTTP caching.
   More general security considerations are addressed in HTTP messaging
   <xref target="RFC7230"/> and semantics <xref target="RFC7231"/>.
</t>
<t>
   Caches expose additional potential vulnerabilities, since the contents of
   the cache represent an attractive target for malicious exploitation.
   Because cache contents persist after an HTTP request is complete, an attack
   on the cache can reveal information long after a user believes that the
   information has been removed from the network. Therefore, cache contents
   need to be protected as sensitive information.
</t>
<t>
   In particular, various attacks might be amplified by being stored in a
   shared cache; such "cache poisoning" attacks use the cache to distribute a
   malicious payload to many clients, and are especially effective when an
   attacker can use implementation flaws, elevated privileges, or other
   techniques to insert such a response into a cache. One common attack vector
   for cache poisoning is to exploit differences in message parsing on proxies
   and in user agents; see Section 3.3.3 of <xref target="RFC7230"/> for the relevant requirements.
</t>
<t>
   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing it to
   unauthorized parties.
</t>
<t>
   Furthermore, the very use of a cache can bring about privacy concerns. For
   example, if two users share a cache, and the first one browses to a site,
   the second may be able to detect that the other has been to that site, 
   because the resources from it load more quickly, thanks to the cache.
</t>
<t>
   Note that the Set-Cookie response header field <xref target="RFC6265"/> does not
   inhibit caching; a cacheable response with a Set-Cookie header field can be (and
   often is) used to satisfy subsequent requests to caches. Servers who wish
   to control caching of these responses are encouraged to emit appropriate
   Cache-Control response header fields.
</t>

</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See Section 10 of <xref target="RFC7230"/>.
</t>
</section>

</middle>

<back>
<references title="Normative References">

<!-- draft-ietf-httpbis-p1-messaging-26 -->
  <reference anchor="RFC7230">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="May" year="2014"/>
    </front>
    <seriesInfo name="RFC" value="7230"/>
    
  </reference>

<!-- draft-ietf-httpbis-p2-semantics-26 -->
  <reference anchor="RFC7231">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="May" year="2014"/>
    </front>
    <seriesInfo name="RFC" value="7231"/>
    
  </reference>

<!-- draft-ietf-httpbis-p4-conditional-26 -->
  <reference anchor="RFC7232">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="May" year="2014"/>
    </front>
    <seriesInfo name="RFC" value="7232"/>
    
  </reference>

<!-- draft-ietf-httpbis-p5-range-26 -->
  <reference anchor="RFC7233">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
        <organization abbrev="W3C">World Wide Web Consortium</organization>
        <address><email>ylafon@w3.org</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="May" year="2014"/>
    </front>
    <seriesInfo name="RFC" value="7233"/>
    
  </reference>

<!-- draft-ietf-httpbis-p7-auth-26 -->
  <reference anchor="RFC7235">
    <front>
      <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
      <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
        <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
        <address><email>fielding@gbiv.com</email></address>
      </author>
      <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
        <organization abbrev="greenbytes">greenbytes GmbH</organization>
        <address><email>julian.reschke@greenbytes.de</email></address>
      </author>
      <date month="May" year="2014"/>
    </front>
    <seriesInfo name="RFC" value="7235"/>
    
  </reference>

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author fullname="Scott Bradner" initials="S." surname="Bradner">
        <organization>Harvard University</organization>
        <address><email>sob@harvard.edu</email></address>
      </author>
      <date month="March" year="1997"/>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
  </reference>

  <reference anchor="RFC5234">
    <front>
      <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
      <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
        <organization>Brandenburg InternetWorking</organization>
        <address>
          <email>dcrocker@bbiw.net</email>
        </address>  
      </author>
      <author initials="P." surname="Overell" fullname="Paul Overell">
        <organization>THUS plc.</organization>
        <address>
          <email>paul.overell@thus.net</email>
        </address>
      </author>
      <date month="January" year="2008"/>
    </front>
    <seriesInfo name="STD" value="68"/>
    <seriesInfo name="RFC" value="5234"/>
  </reference>
  
</references>

<references title="Informative References">



  <reference anchor="RFC2616">
    <front>
      <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
      <author fullname="R. Fielding" initials="R." surname="Fielding">
        <organization>University of California, Irvine</organization>
        <address><email>fielding@ics.uci.edu</email></address>
      </author>
      <author fullname="J. Gettys" initials="J." surname="Gettys">
        <organization>W3C</organization>
        <address><email>jg@w3.org</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>Compaq Computer Corporation</organization>
        <address><email>mogul@wrl.dec.com</email></address>
      </author>
      <author fullname="H. Frystyk" initials="H." surname="Frystyk">
        <organization>MIT Laboratory for Computer Science</organization>
        <address><email>frystyk@w3.org</email></address>
      </author>
      <author fullname="L. Masinter" initials="L." surname="Masinter">
        <organization>Xerox Corporation</organization>
        <address><email>masinter@parc.xerox.com</email></address>
      </author>
      <author fullname="P. Leach" initials="P." surname="Leach">
        <organization>Microsoft Corporation</organization>
        <address><email>paulle@microsoft.com</email></address>
      </author>
      <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee">
        <organization>W3C</organization>
        <address><email>timbl@w3.org</email></address>
      </author>
      <date month="June" year="1999"/>
    </front>
    <seriesInfo name="RFC" value="2616"/>
  </reference>

  <reference anchor="BCP90">
    <front>
      <title>Registration Procedures for Message Header Fields</title>
      <author fullname="G. Klyne" initials="G." surname="Klyne">
        <organization>Nine by Nine</organization>
        <address><email>GK-IETF@ninebynine.org</email></address>
      </author>
      <author fullname="M. Nottingham" initials="M." surname="Nottingham">
        <organization>BEA Systems</organization>
        <address><email>mnot@pobox.com</email></address>
      </author>
      <author fullname="J. Mogul" initials="J." surname="Mogul">
        <organization>HP Labs</organization>
        <address><email>JeffMogul@acm.org</email></address>
      </author>
      <date month="September" year="2004"/>
    </front>
    <seriesInfo name="BCP" value="90"/>
    <seriesInfo name="RFC" value="3864"/>
  </reference>

  <reference anchor="RFC5226">
    <front>
      <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
      <author initials="T." surname="Narten" fullname="T. Narten">
        <organization>IBM</organization>
        <address><email>narten@us.ibm.com</email></address>
      </author>
      <author initials="H." surname="Alvestrand" fullname="H. Alvestrand">
        <organization>Google</organization>
        <address><email>Harald@Alvestrand.no</email></address>
      </author>
      <date year="2008" month="May"/>
    </front>
    <seriesInfo name="BCP" value="26"/>
    <seriesInfo name="RFC" value="5226"/>
  </reference>

  <reference anchor="RFC5861">
    <front>
      <title abbrev="HTTP stale controls">HTTP Cache-Control Extensions for Stale Content</title>
      <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
        <organization>Yahoo! Inc.</organization>
        <address><email>mnot@yahoo-inc.com</email></address>
      </author>
      <date month="April" year="2010"/>
    </front>
    <seriesInfo name="RFC" value="5861"/>
  </reference>

  <reference anchor="RFC5905">
    <front>
      <title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
      <author initials="D." surname="Mills" fullname="David L. Mills"/>
      <author initials="J." surname="Martin" fullname="Jim Martin" role="editor"/>
      <author initials="J." surname="Burbank" fullname="Jack Burbank"/>
      <author initials="W." surname="Kasch" fullname="William Kasch"/>
      <date year="2010" month="June"/>
    </front>
    <seriesInfo name="RFC" value="5905"/>
  </reference>

  <reference anchor="RFC6265">
    <front>
      <title>HTTP State Management Mechanism</title>
      <author initials="A." surname="Barth" fullname="Adam Barth">
        <organization abbrev="U.C. Berkeley">
          University of California, Berkeley
        </organization>
        <address><email>abarth@eecs.berkeley.edu</email></address>
      </author>
      <date year="2011" month="April"/>
    </front>
    <seriesInfo name="RFC" value="6265"/>
  </reference>

</references>

<section anchor="changes.from.rfc.2616" title="Changes from RFC 2616">
<t>
  The specification has been substantially rewritten for clarity.
</t>
<t>
  The conditions under which an authenticated response can be cached have been
  clarified.
  (<xref target="caching.authenticated.responses"/>)
</t>
<t>
  New status codes can now define that caches are allowed to use heuristic
  freshness with them.
  Caches are now allowed to calculate heuristic freshness for URIs with query
  components.
  (<xref target="heuristic.freshness"/>)
</t>
<t>
  The algorithm for calculating age is now less conservative.
  Caches are now required to handle dates with time zones as if they're 
  invalid, because it's not possible to accurately guess.
  (<xref target="age.calculations"/>)
</t>
<t>
  The Content-Location response header field is no longer used
  to determine the appropriate response to use when validating.
  (<xref target="validation.model"/>)
</t>
<t>
  The algorithm for selecting a cached negotiated response to use has been
  clarified in several ways. In particular, it now explicitly allows
  header-specific canonicalization when processing selecting header fields.
  (<xref target="caching.negotiated.responses"/>)
</t>
<t>
  Requirements regarding denial-of-service attack avoidance when performing
  invalidation have been clarified.
  (<xref target="invalidation"/>)
</t>
<t>
  Cache invalidation only occurs when a successful response is received.
  (<xref target="invalidation"/>)
</t>
<t>
  Cache directives are explicitly defined to be case-insensitive.
  Handling of multiple instances of cache directives when only one is 
  expected is now defined.
  (<xref target="header.cache-control"/>)
</t>
<t>
  The "no-store" request directive doesn't apply to responses; i.e.,
  a cache can satisfy a request with no-store on it and does not invalidate
  it.
  (<xref target="cache-request-directive.no-store"/>)
</t>
<t>
  The qualified forms of the private and no-cache cache directives are noted
  to not be widely implemented; for example, "private=foo" is interpreted by many
  caches as simply "private". Additionally, the meaning of the qualified
  form of no-cache has been clarified.
  (<xref target="cache-response-directive"/>)
</t>
<t>
  The "no-cache" response directive's meaning has been clarified.
  (<xref target="cache-response-directive.no-cache"/>)
</t>
<t>
  The one-year limit on <xref target="header.expires" format="none">Expires</xref> header field values has been removed; instead,
  the reasoning for using a sensible value is given.
  (<xref target="header.expires"/>)
</t>
<t>
  The <xref target="header.pragma" format="none">Pragma</xref> header field is now only defined for backwards compatibility;
  future pragmas are deprecated.
  (<xref target="header.pragma"/>)
</t>
<t>
  Some requirements regarding production and processing of the <xref target="header.warning" format="none">Warning</xref> 
  header fields have been relaxed, as it is not widely implemented.
  Furthermore, the <xref target="header.warning" format="none">Warning</xref> header field no longer uses RFC 2047 encoding,
  nor does it allow multiple languages, as these aspects were not implemented.
  (<xref target="header.warning"/>)
</t>
<t>
  This specification introduces the Cache Directive and Warn Code Registries,
  and defines considerations for new cache directives.
  (<xref target="cache.directive.registry"/> and <xref target="warn.code.registry"/>)
</t>
</section>

<section title="Imported ABNF" anchor="imported.abnf">
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
<t>
   The following core rules are included by reference, as defined in Appendix B.1 of <xref target="RFC5234"/>: ALPHA (letters), CR (carriage
   return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit
   sequence of data), SP (space), and VCHAR (any visible US-ASCII character).
</t>
<t>
   The rules below are defined in <xref target="RFC7230"/>:
</t>
<figure><artwork type="abnf2616"><![CDATA[
  OWS           = <OWS, see [RFC7230], Section 3.2.3>
  field-name    = <field-name, see [RFC7230], Section 3.2>
  quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>
  token         = <token, see [RFC7230], Section 3.2.6>

  port          = <port, see [RFC7230], Section 2.7>
  pseudonym     = <pseudonym, see [RFC7230], Section 5.7.1> 
  uri-host      = <uri-host, see [RFC7230], Section 2.7>
]]></artwork></figure>
<t>
   The rules below are defined in other parts: 
</t>
<figure><artwork type="abnf2616"><![CDATA[
  HTTP-date     = <HTTP-date, see [RFC7231], Section 7.1.1.1>
]]></artwork></figure>
</section>


<section title="Collected ABNF" anchor="collected.abnf">
<t>
  In the collected ABNF below, list rules are expanded as per Section 1.2 of <xref target="RFC7230"/>.
</t><figure>
<artwork type="abnf" name="p6-cache.parsed-abnf"><![CDATA[
Age = delta-seconds

Cache-Control = *( "," OWS ) cache-directive *( OWS "," [ OWS
 cache-directive ] )

Expires = HTTP-date

HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>

OWS = <OWS, see [RFC7230], Section 3.2.3>

Pragma = *( "," OWS ) pragma-directive *( OWS "," [ OWS
 pragma-directive ] )

Warning = *( "," OWS ) warning-value *( OWS "," [ OWS warning-value ]
 )

cache-directive = token [ "=" ( token / quoted-string ) ]

delta-seconds = 1*DIGIT

extension-pragma = token [ "=" ( token / quoted-string ) ]

field-name = <field-name, see [RFC7230], Section 3.2>

port = <port, see [RFC7230], Section 2.7>
pragma-directive = "no-cache" / extension-pragma
pseudonym = <pseudonym, see [RFC7230], Section 5.7.1>

quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>

token = <token, see [RFC7230], Section 3.2.6>

uri-host = <uri-host, see [RFC7230], Section 2.7>

warn-agent = ( uri-host [ ":" port ] ) / pseudonym
warn-code = 3DIGIT
warn-date = DQUOTE HTTP-date DQUOTE
warn-text = quoted-string
warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
 ]
]]></artwork>
</figure>
</section>

</back>
</rfc>
