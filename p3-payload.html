<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
   <head profile="http://www.w3.org/2006/03/hcard">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>HTTP/1.1, part 3: Message Payload and Content Negotiation</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

dl.empty dd {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h2 a {
  color: black;
}
h3 {
  font-size: 10pt;
  page-break-after: avoid;
}
h3 a {
  color: black;
}
h4 {
  font-size: 10pt;
  page-break-after: avoid;
}
h4 a {
  color: black;
}
h5 {
  font-size: 10pt;
  page-break-after: avoid;
}
h5 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
td.header {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.tocline0 {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline1 {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline2 {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.indline0 {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
  margin-right: 0em;
}
li.indline1 {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
  margin-right: 0em;
}
.bcp14 {
  font-style: normal;
  text-transform: lowercase;
  font-variant: small-caps;
}
.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  a.iref {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "INTERNET DRAFT"; 
  } 
  @top-right {
       content: "December 2007"; 
  } 
  @top-center {
       content: "HTTP/1.1"; 
  } 
  @bottom-left {
       content: "Fielding, et al."; 
  } 
  @bottom-center {
       content: "Standards Track"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc">
      <link rel="Author" href="#rfc.authors">
      <link rel="Copyright" href="#rfc.copyright">
      <link rel="Index" href="#rfc.index">
      <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
      <link rel="Chapter" title="2 Protocol Parameters" href="#rfc.section.2">
      <link rel="Chapter" title="3 Entity" href="#rfc.section.3">
      <link rel="Chapter" title="4 Content Negotiation" href="#rfc.section.4">
      <link rel="Chapter" title="5 Header Field Definitions" href="#rfc.section.5">
      <link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6">
      <link rel="Chapter" title="7 Security Considerations" href="#rfc.section.7">
      <link rel="Chapter" title="8 Acknowledgments" href="#rfc.section.8">
      <link rel="Chapter" href="#rfc.section.9" title="9 References">
      <link rel="Appendix" title="A Differences Between HTTP Entities and RFC 2045 Entities" href="#rfc.section.A">
      <link rel="Appendix" title="B Additional Features" href="#rfc.section.B">
      <link rel="Appendix" title="C Changes from RFC 2068" href="#rfc.section.C">
      <meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.353, 2007/12/11 23:20:44, XSLT vendor: SAXON 8.9 from Saxonica http://www.saxonica.com/">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.Creator" content="Fielding, R.">
      <meta name="DC.Creator" content="Gettys, J.">
      <meta name="DC.Creator" content="Mogul, J.">
      <meta name="DC.Creator" content="Frystyk, H.">
      <meta name="DC.Creator" content="Masinter, L.">
      <meta name="DC.Creator" content="Leach, P.">
      <meta name="DC.Creator" content="Berners-Lee, T.">
      <meta name="DC.Creator" content="Lafon, Y.">
      <meta name="DC.Creator" content="Reschke, J. F.">
      <meta name="DC.Identifier" content="urn:ietf:id:draft-ietf-httpbis-p3-payload-latest">
      <meta name="DC.Date.Issued" scheme="ISO8601" content="2007-12">
      <meta name="DC.Relation.Replaces" content="urn:ietf:rfc:2068">
      <meta name="DC.Relation.Replaces" content="urn:ietf:rfc:2616">
      <meta name="DC.Description.Abstract" content="The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. HTTP has been in use by the World Wide Web global information initiative since 1990. This document is Part 3 of the seven-part specification that defines the protocol referred to as &#34;HTTP/1.1&#34; and, taken together, obsoletes RFC 2616. Part 3 defines HTTP message content, metadata, and content negotiation.">
   </head>
   <body>
      <table summary="header information" class="header" border="0" cellpadding="1" cellspacing="1">
         <tr>
            <td class="header left">Network Working Group</td>
            <td class="header right">R. Fielding, Editor</td>
         </tr>
         <tr>
            <td class="header left">Internet Draft</td>
            <td class="header right">Day Software</td>
         </tr>
         <tr>
            <td class="header left">
               &lt;draft-ietf-httpbis-p3-payload-latest&gt;
               
            </td>
            <td class="header right">J. Gettys</td>
         </tr>
         <tr>
            <td class="header left">Obsoletes: <a href="http://tools.ietf.org/html/rfc2068">2068</a>,
               <a href="http://tools.ietf.org/html/rfc2616">2616</a> (if approved)
            </td>
            <td class="header right">One Laptop per Child</td>
         </tr>
         <tr>
            <td class="header left">Intended status: Standards Track</td>
            <td class="header right">J. Mogul</td>
         </tr>
         <tr>
            <td class="header left">Expires: June 2008</td>
            <td class="header right">HP</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">H. Frystyk</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Microsoft</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">L. Masinter</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Adobe Systems</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">P. Leach</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Microsoft</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">T. Berners-Lee</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">W3C/MIT</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">Y. Lafon, Editor</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">W3C</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">J. F. Reschke, Editor</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">greenbytes</td>
         </tr>
         <tr>
            <td class="header left"></td>
            <td class="header right">December 2007</td>
         </tr>
      </table>
      <p class="title">HTTP/1.1, part 3: Message Payload and Content Negotiation<br><span class="filename">draft-ietf-httpbis-p3-payload-latest</span></p>
      <h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1>
      <p>By submitting this Internet-Draft, each author represents that any applicable patent or other IPR claims of which he or she
         is aware have been or will be disclosed, and any of which he or she becomes aware will be disclosed, in accordance with Section
         6 of BCP 79.
      </p>
      <p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF), its areas, and its working groups. Note
         that other groups may also distribute working documents as Internet-Drafts.
      </p>
      <p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other
         documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work
         in progress”.
      </p>
      <p>The list of current Internet-Drafts can be accessed at &lt;<a href="http://www.ietf.org/ietf/1id-abstracts.txt">http://www.ietf.org/ietf/1id-abstracts.txt</a>&gt;.
      </p>
      <p>The list of Internet-Draft Shadow Directories can be accessed at &lt;<a href="http://www.ietf.org/shadow.html">http://www.ietf.org/shadow.html</a>&gt;.
      </p>
      <p>This Internet-Draft will expire in June 2008.</p>
      <h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1>
      <p>Copyright © The IETF Trust (2007). All Rights Reserved.</p>
      <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1> 
      <p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information
         systems. HTTP has been in use by the World Wide Web global information initiative since 1990. This document is Part 3 of the
         seven-part specification that defines the protocol referred to as "HTTP/1.1" and, taken together, obsoletes RFC 2616. Part
         3 defines HTTP message content, metadata, and content negotiation.
      </p> 
      <h1 id="rfc.note.1"><a href="#rfc.note.1">Editorial Note (To be removed by RFC Editor)</a></h1> 
      <p>This version of the HTTP specification contains only minimal editorial changes from <a href="#RFC2616" id="rfc.xref.RFC2616.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a> (abstract, introductory paragraph, and authors' addresses). All other changes are due to partitioning the original into seven
         mostly independent parts. The intent is for readers of future drafts to able to use draft 00 as the basis for comparison when
         the WG makes later changes to the specification text. This draft will shortly be followed by draft 01 (containing the first
         round of changes that have already been agreed to on the mailing list). There is no point in reviewing this draft other than
         to verify that the partitioning has been done correctly. Roy T. Fielding, Yves Lafon, and Julian Reschke will be the editors
         after draft 00 is submitted.
      </p>  
      <p>Discussion of this draft should take place on the HTTPBIS working group mailing list (ietf-http-wg@w3.org). The current issues
         list is at &lt;<a href="http://www3.tools.ietf.org/wg/httpbis/trac/report/11">http://www3.tools.ietf.org/wg/httpbis/trac/report/11</a>&gt; and related documents (including fancy diffs) can be found at &lt;<a href="http://www3.tools.ietf.org/wg/httpbis/">http://www3.tools.ietf.org/wg/httpbis/</a>&gt;.
      </p> 
      <hr class="noprint">
      <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
      <ul class="toc">
         <li class="tocline0">1.&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul class="toc">
               <li class="tocline1">1.1&nbsp;&nbsp;&nbsp;<a href="#intro.requirements">Requirements</a></li>
            </ul>
         </li>
         <li class="tocline0">2.&nbsp;&nbsp;&nbsp;<a href="#protocol.parameters">Protocol Parameters</a><ul class="toc">
               <li class="tocline1">2.1&nbsp;&nbsp;&nbsp;<a href="#character.sets">Character Sets</a><ul class="toc">
                     <li class="tocline1">2.1.1&nbsp;&nbsp;&nbsp;<a href="#missing.charset">Missing Charset</a></li>
                  </ul>
               </li>
               <li class="tocline1">2.2&nbsp;&nbsp;&nbsp;<a href="#content.codings">Content Codings</a></li>
               <li class="tocline1">2.3&nbsp;&nbsp;&nbsp;<a href="#media.types">Media Types</a><ul class="toc">
                     <li class="tocline1">2.3.1&nbsp;&nbsp;&nbsp;<a href="#canonicalization.and.text.defaults">Canonicalization and Text Defaults</a></li>
                     <li class="tocline1">2.3.2&nbsp;&nbsp;&nbsp;<a href="#multipart.types">Multipart Types</a></li>
                  </ul>
               </li>
               <li class="tocline1">2.4&nbsp;&nbsp;&nbsp;<a href="#quality.values">Quality Values</a></li>
               <li class="tocline1">2.5&nbsp;&nbsp;&nbsp;<a href="#language.tags">Language Tags</a></li>
            </ul>
         </li>
         <li class="tocline0">3.&nbsp;&nbsp;&nbsp;<a href="#entity">Entity</a><ul class="toc">
               <li class="tocline1">3.1&nbsp;&nbsp;&nbsp;<a href="#entity.header.fields">Entity Header Fields</a></li>
               <li class="tocline1">3.2&nbsp;&nbsp;&nbsp;<a href="#entity.body">Entity Body</a><ul class="toc">
                     <li class="tocline1">3.2.1&nbsp;&nbsp;&nbsp;<a href="#type">Type</a></li>
                     <li class="tocline1">3.2.2&nbsp;&nbsp;&nbsp;<a href="#entity.length">Entity Length</a></li>
                  </ul>
               </li>
            </ul>
         </li>
         <li class="tocline0">4.&nbsp;&nbsp;&nbsp;<a href="#content.negotiation">Content Negotiation</a><ul class="toc">
               <li class="tocline1">4.1&nbsp;&nbsp;&nbsp;<a href="#server-driven.negotiation">Server-driven Negotiation</a></li>
               <li class="tocline1">4.2&nbsp;&nbsp;&nbsp;<a href="#agent-driven.negotiation">Agent-driven Negotiation</a></li>
               <li class="tocline1">4.3&nbsp;&nbsp;&nbsp;<a href="#transparent.negotiation">Transparent Negotiation</a></li>
            </ul>
         </li>
         <li class="tocline0">5.&nbsp;&nbsp;&nbsp;<a href="#header.fields">Header Field Definitions</a><ul class="toc">
               <li class="tocline1">5.1&nbsp;&nbsp;&nbsp;<a href="#header.accept">Accept</a></li>
               <li class="tocline1">5.2&nbsp;&nbsp;&nbsp;<a href="#header.accept-charset">Accept-Charset</a></li>
               <li class="tocline1">5.3&nbsp;&nbsp;&nbsp;<a href="#header.accept-encoding">Accept-Encoding</a></li>
               <li class="tocline1">5.4&nbsp;&nbsp;&nbsp;<a href="#header.accept-language">Accept-Language</a></li>
               <li class="tocline1">5.5&nbsp;&nbsp;&nbsp;<a href="#header.content-encoding">Content-Encoding</a></li>
               <li class="tocline1">5.6&nbsp;&nbsp;&nbsp;<a href="#header.content-language">Content-Language</a></li>
               <li class="tocline1">5.7&nbsp;&nbsp;&nbsp;<a href="#header.content-location">Content-Location</a></li>
               <li class="tocline1">5.8&nbsp;&nbsp;&nbsp;<a href="#header.content-md5">Content-MD5</a></li>
               <li class="tocline1">5.9&nbsp;&nbsp;&nbsp;<a href="#header.content-type">Content-Type</a></li>
            </ul>
         </li>
         <li class="tocline0">6.&nbsp;&nbsp;&nbsp;<a href="#IANA.considerations">IANA Considerations</a></li>
         <li class="tocline0">7.&nbsp;&nbsp;&nbsp;<a href="#security.considerations">Security Considerations</a><ul class="toc">
               <li class="tocline1">7.1&nbsp;&nbsp;&nbsp;<a href="#privacy.issues.connected.to.accept.headers">Privacy Issues Connected to Accept Headers</a></li>
               <li class="tocline1">7.2&nbsp;&nbsp;&nbsp;<a href="#content-disposition.issues">Content-Disposition Issues</a></li>
            </ul>
         </li>
         <li class="tocline0">8.&nbsp;&nbsp;&nbsp;<a href="#ack">Acknowledgments</a></li>
         <li class="tocline0">9.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a></li>
         <li class="tocline0"><a href="#rfc.authors">Authors' Addresses</a></li>
         <li class="tocline0">A.&nbsp;&nbsp;&nbsp;<a href="#differences.between.http.entities.and.rfc.2045.entities">Differences Between HTTP Entities and RFC 2045 Entities</a><ul class="toc">
               <li class="tocline1">A.1&nbsp;&nbsp;&nbsp;<a href="#mime-version">MIME-Version</a></li>
               <li class="tocline1">A.2&nbsp;&nbsp;&nbsp;<a href="#conversion.to.canonical.form">Conversion to Canonical Form</a></li>
               <li class="tocline1">A.3&nbsp;&nbsp;&nbsp;<a href="#introduction.of.content-encoding">Introduction of Content-Encoding</a></li>
               <li class="tocline1">A.4&nbsp;&nbsp;&nbsp;<a href="#no.content-transfer-encoding">No Content-Transfer-Encoding</a></li>
               <li class="tocline1">A.5&nbsp;&nbsp;&nbsp;<a href="#introduction.of.transfer-encoding">Introduction of Transfer-Encoding</a></li>
               <li class="tocline1">A.6&nbsp;&nbsp;&nbsp;<a href="#mhtml.line.length">MHTML and Line Length Limitations</a></li>
            </ul>
         </li>
         <li class="tocline0">B.&nbsp;&nbsp;&nbsp;<a href="#additional.features">Additional Features</a><ul class="toc">
               <li class="tocline1">B.1&nbsp;&nbsp;&nbsp;<a href="#content-disposition">Content-Disposition</a></li>
            </ul>
         </li>
         <li class="tocline0">C.&nbsp;&nbsp;&nbsp;<a href="#changes.from.rfc.2068">Changes from RFC 2068</a></li>
         <li class="tocline0"><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li>
         <li class="tocline0"><a href="#rfc.index">Index</a></li>
      </ul>
      <h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="introduction" href="#introduction">Introduction</a></h1>
      <p id="rfc.section.1.p.1">This document will define aspects of HTTP related to the payload of messages (message content), including metadata and media
         types, along with HTTP content negotiation. Right now it only includes the extracted relevant sections of RFC 2616 without
         edit.
      </p>
      <h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="intro.requirements" href="#intro.requirements">Requirements</a></h2>
      <p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
         in this document are to be interpreted as described in <a href="#RFC2119" id="rfc.xref.RFC2119.1"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.
      </p>
      <p id="rfc.section.1.1.p.2">An implementation is not compliant if it fails to satisfy one or more of the <em class="bcp14">MUST</em> or <em class="bcp14">REQUIRED</em> level requirements for the protocols it implements. An implementation that satisfies all the <em class="bcp14">MUST</em> or <em class="bcp14">REQUIRED</em> level and all the <em class="bcp14">SHOULD</em> level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the <em class="bcp14">MUST</em> level requirements but not all the <em class="bcp14">SHOULD</em> level requirements for its protocols is said to be "conditionally compliant."
      </p>
      <h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a id="protocol.parameters" href="#protocol.parameters">Protocol Parameters</a></h1>
      <h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="character.sets" href="#character.sets">Character Sets</a></h2>
      <p id="rfc.section.2.1.p.1">HTTP uses the same definition of the term "character set" as that described for MIME:</p>
      <p id="rfc.section.2.1.p.2">The term "character set" is used in this document to refer to a method used with one or more tables to convert a sequence
         of octets into a sequence of characters. Note that unconditional conversion in the other direction is not required, in that
         not all characters may be available in a given character set and a character set may provide more than one sequence of octets
         to represent a particular character. This definition is intended to allow various kinds of character encoding, from simple
         single-table mappings such as US-ASCII to complex table switching methods such as those that use ISO-2022's techniques. However,
         the definition associated with a MIME character set name <em class="bcp14">MUST</em> fully specify the mapping to be performed from octets to characters. In particular, use of external profiling information
         to determine the exact mapping is not permitted.
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> This use of the term "character set" is more commonly referred to as a "character encoding." However, since HTTP and MIME
            share the same registry, it is important that the terminology also be shared.
         </dd>
      </dl>
      <p id="rfc.section.2.1.p.4">HTTP character sets are identified by case-insensitive tokens. The complete set of tokens is defined by the IANA Character
         Set registry (&lt;<a href="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</a>&gt;).
      </p>
      <div id="rfc.figure.u.1"></div><pre class="inline"><span id="rfc.iref.g.1"></span>    charset = token
</pre><p id="rfc.section.2.1.p.6">Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA
         Character Set registry <em class="bcp14">MUST</em> represent the character set defined by that registry. Applications <em class="bcp14">SHOULD</em> limit their use of character sets to those defined by the IANA registry.
      </p>
      <p id="rfc.section.2.1.p.7">HTTP uses charset in two contexts: within an Accept-Charset request header (in which the charset value is an unquoted token)
         and as the value of a parameter in a Content-type header (within a request or response), in which case the parameter value
         of the charset parameter may be quoted.
      </p>
      <p id="rfc.section.2.1.p.8">Implementors should be aware of IETF character set requirements <a href="#RFC2279" id="rfc.xref.RFC2279.1"><cite title="UTF-8, a transformation format of ISO 10646">[RFC2279]</cite></a>  <a href="#RFC2277" id="rfc.xref.RFC2277.1"><cite title="IETF Policy on Character Sets and Languages">[RFC2277]</cite></a>.
      </p>
      <h3 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;<a id="missing.charset" href="#missing.charset">Missing Charset</a></h3>
      <p id="rfc.section.2.1.1.p.1">Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean "recipient should
         guess." Senders wishing to defeat this behavior <em class="bcp14">MAY</em> include a charset parameter even when the charset is ISO-8859-1 and <em class="bcp14">SHOULD</em> do so when it is known that it will not confuse the recipient.
      </p>
      <p id="rfc.section.2.1.1.p.2">Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter. HTTP/1.1 recipients <em class="bcp14">MUST</em> respect the charset label provided by the sender; and those user agents that have a provision to "guess" a charset <em class="bcp14">MUST</em> use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially
         displaying a document. See <a href="#canonicalization.and.text.defaults" title="Canonicalization and Text Defaults">Section&nbsp;2.3.1</a>.
      </p>
      <h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="content.codings" href="#content.codings">Content Codings</a></h2>
      <p id="rfc.section.2.2.p.1">Content coding values indicate an encoding transformation that has been or can be applied to an entity. Content codings are
         primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying
         media type and without loss of information. Frequently, the entity is stored in coded form, transmitted directly, and only
         decoded by the recipient.
      </p>
      <div id="rfc.figure.u.2"></div><pre class="inline"><span id="rfc.iref.g.2"></span>    content-coding   = token
</pre><p id="rfc.section.2.2.p.3">All content-coding values are case-insensitive. HTTP/1.1 uses content-coding values in the Accept-Encoding (<a href="#header.accept-encoding" id="rfc.xref.header.accept-encoding.1" title="Accept-Encoding">Section&nbsp;5.3</a>) and Content-Encoding (<a href="#header.content-encoding" id="rfc.xref.header.content-encoding.1" title="Content-Encoding">Section&nbsp;5.5</a>) header fields. Although the value describes the content-coding, what is more important is that it indicates what decoding
         mechanism will be required to remove the encoding.
      </p>
      <p id="rfc.section.2.2.p.4">The Internet Assigned Numbers Authority (IANA) acts as a registry for content-coding value tokens. Initially, the registry
         contains the following tokens:
      </p>
      <p id="rfc.section.2.2.p.5">gzip<span id="rfc.iref.g.3"></span>  
      </p>
      <dl class="empty">
         <dd>An encoding format produced by the file compression program "gzip" (GNU zip) as described in RFC 1952 <a href="#RFC1952" id="rfc.xref.RFC1952.1"><cite title="GZIP file format specification version 4.3">[RFC1952]</cite></a>. This format is a Lempel-Ziv coding (LZ77) with a 32 bit CRC.
         </dd>
      </dl>
      <p id="rfc.section.2.2.p.6">compress<span id="rfc.iref.c.1"></span>  
      </p>
      <dl class="empty">
         <dd>The encoding format produced by the common UNIX file compression program "compress". This format is an adaptive Lempel-Ziv-Welch
            coding (LZW).
         </dd>
         <dd>Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
            Their use here is representative of historical practice, not good design. For compatibility with previous implementations
            of HTTP, applications <em class="bcp14">SHOULD</em> consider "x-gzip" and "x-compress" to be equivalent to "gzip" and "compress" respectively.
         </dd>
      </dl>
      <p id="rfc.section.2.2.p.7">deflate<span id="rfc.iref.d.1"></span>  
      </p>
      <dl class="empty">
         <dd>The "zlib" format defined in RFC 1950 <a href="#RFC1950" id="rfc.xref.RFC1950.1"><cite title="ZLIB Compressed Data Format Specification version 3.3">[RFC1950]</cite></a> in combination with the "deflate" compression mechanism described in RFC 1951 <a href="#RFC1951" id="rfc.xref.RFC1951.1"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[RFC1951]</cite></a>.
         </dd>
      </dl>
      <p id="rfc.section.2.2.p.8">identity<span id="rfc.iref.i.1"></span>  
      </p>
      <dl class="empty">
         <dd>The default (identity) encoding; the use of no transformation whatsoever. This content-coding is used only in the Accept-Encoding
            header, and <em class="bcp14">SHOULD NOT</em> be used in the Content-Encoding header.
         </dd>
      </dl>
      <p id="rfc.section.2.2.p.9">New content-coding value tokens <em class="bcp14">SHOULD</em> be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed
         to implement a new value <em class="bcp14">SHOULD</em> be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in
         this section.
      </p>
      <h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="media.types" href="#media.types">Media Types</a></h2>
      <p id="rfc.section.2.3.p.1">HTTP uses Internet Media Types <a href="#RFC4288" id="rfc.xref.RFC4288.1"><cite title="Media Type Specifications and Registration Procedures">[RFC4288]</cite></a> in the Content-Type (<a href="#header.content-type" id="rfc.xref.header.content-type.1" title="Content-Type">Section&nbsp;5.9</a>) and Accept (<a href="#header.accept" id="rfc.xref.header.accept.1" title="Accept">Section&nbsp;5.1</a>) header fields in order to provide open and extensible data typing and type negotiation.
      </p>
      <div id="rfc.figure.u.3"></div><pre class="inline"><span id="rfc.iref.g.4"></span><span id="rfc.iref.g.5"></span><span id="rfc.iref.g.6"></span>    media-type     = type "/" subtype *( ";" parameter )
    type           = token
    subtype        = token
</pre><p id="rfc.section.2.3.p.3">Parameters <em class="bcp14">MAY</em> follow the type/subtype in the form of attribute/value pairs.
      </p>
      <div id="rfc.figure.u.4"></div><pre class="inline"><span id="rfc.iref.g.7"></span><span id="rfc.iref.g.8"></span><span id="rfc.iref.g.9"></span>    parameter               = attribute "=" value
    attribute               = token
    value                   = token | quoted-string
</pre><p id="rfc.section.2.3.p.5">The type, subtype, and parameter attribute names are case-insensitive. Parameter values might or might not be case-sensitive,
         depending on the semantics of the parameter name. Linear white space (LWS) <em class="bcp14">MUST NOT</em> be used between the type and subtype, nor between an attribute and its value. The presence or absence of a parameter might
         be significant to the processing of a media-type, depending on its definition within the media type registry.
      </p>
      <p id="rfc.section.2.3.p.6">Note that some older HTTP applications do not recognize media type parameters. When sending data to older HTTP applications,
         implementations <em class="bcp14">SHOULD</em> only use media type parameters when they are required by that type/subtype definition.
      </p>
      <p id="rfc.section.2.3.p.7">Media-type values are registered with the Internet Assigned Number Authority (IANA). The media type registration process is
         outlined in RFC 4288 <a href="#RFC4288" id="rfc.xref.RFC4288.2"><cite title="Media Type Specifications and Registration Procedures">[RFC4288]</cite></a>. Use of non-registered media types is discouraged.
      </p>
      <h3 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a id="canonicalization.and.text.defaults" href="#canonicalization.and.text.defaults">Canonicalization and Text Defaults</a></h3>
      <p id="rfc.section.2.3.1.p.1">Internet media types are registered with a canonical form. An entity-body transferred via HTTP messages <em class="bcp14">MUST</em> be represented in the appropriate canonical form prior to its transmission except for "text" types, as defined in the next
         paragraph.
      </p>
      <p id="rfc.section.2.3.1.p.2">When in canonical form, media subtypes of the "text" type use CRLF as the text line break. HTTP relaxes this requirement and
         allows the transport of text media with plain CR or LF alone representing a line break when it is done consistently for an
         entire entity-body. HTTP applications <em class="bcp14">MUST</em> accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP. In addition, if
         the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for
         some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent
         the equivalent of CR and LF for line breaks. This flexibility regarding line breaks applies only to text media in the entity-body;
         a bare CR or LF <em class="bcp14">MUST NOT</em> be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).
      </p>
      <p id="rfc.section.2.3.1.p.3">If an entity-body is encoded with a content-coding, the underlying data <em class="bcp14">MUST</em> be in a form defined above prior to being encoded.
      </p>
      <p id="rfc.section.2.3.1.p.4">The "charset" parameter is used with some media types to define the character set (<a href="#character.sets" title="Character Sets">Section&nbsp;2.1</a>) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the "text" type are defined
         to have a default charset value of "ISO-8859-1" when received via HTTP. Data in character sets other than "ISO-8859-1" or
         its subsets <em class="bcp14">MUST</em> be labeled with an appropriate charset value. See <a href="#missing.charset" title="Missing Charset">Section&nbsp;2.1.1</a> for compatibility problems.
      </p>
      <h3 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;<a id="multipart.types" href="#multipart.types">Multipart Types</a></h3>
      <p id="rfc.section.2.3.2.p.1">MIME provides for a number of "multipart" types -- encapsulations of one or more entities within a single message-body. All
         multipart types share a common syntax, as defined in section <a href="http://tools.ietf.org/html/rfc2046#section-5.1.1" id="rfc.xref.RFC2046.1">5.1.1</a> of RFC 2046 <a href="#RFC2046" id="rfc.xref.RFC2046.2"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a>, and <em class="bcp14">MUST</em> include a boundary parameter as part of the media type value. The message body is itself a protocol element and <em class="bcp14">MUST</em> therefore use only CRLF to represent line breaks between body-parts. Unlike in RFC 2046, the epilogue of any multipart message <em class="bcp14">MUST</em> be empty; HTTP applications <em class="bcp14">MUST NOT</em> transmit the epilogue (even if the original multipart contains an epilogue). These restrictions exist in order to preserve
         the self-delimiting nature of a multipart message-body, wherein the "end" of the message-body is indicated by the ending multipart
         boundary.
      </p>
      <p id="rfc.section.2.3.2.p.2">In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload. The one exception
         is the "multipart/byteranges" type (<a href="p5-range.html#internet.media.type.multipart.byteranges" title="Internet Media Type multipart/byteranges">Appendix A</a> of <a href="#Part5" id="rfc.xref.Part5.1"><cite title="HTTP/1.1, part 5: Range Requests and Partial Responses">[Part5]</cite></a>) when it appears in a 206 (Partial Content) response. In all other cases, an HTTP user agent <em class="bcp14">SHOULD</em> follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. The MIME header fields within
         each body-part of a multipart message-body do not have any significance to HTTP beyond that defined by their MIME semantics.
      </p>
      <p id="rfc.section.2.3.2.p.3">In general, an HTTP user agent <em class="bcp14">SHOULD</em> follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. If an application receives
         an unrecognized multipart subtype, the application <em class="bcp14">MUST</em> treat it as being equivalent to "multipart/mixed".
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> The "multipart/form-data" type has been specifically defined for carrying form data suitable for processing via the POST request
            method, as described in RFC 1867 <a href="#RFC1867" id="rfc.xref.RFC1867.1"><cite title="Form-based File Upload in HTML">[RFC1867]</cite></a>.
         </dd>
      </dl>
      <h2 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a id="quality.values" href="#quality.values">Quality Values</a></h2>
      <p id="rfc.section.2.4.p.1">HTTP content negotiation (<a href="#content.negotiation" title="Content Negotiation">Section&nbsp;4</a>) uses short "floating point" numbers to indicate the relative importance ("weight") of various negotiable parameters. A weight
         is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value. If a parameter has
         a quality value of 0, then content with this parameter is `not acceptable' for the client. HTTP/1.1 applications <em class="bcp14">MUST NOT</em> generate more than three digits after the decimal point. User configuration of these values <em class="bcp14">SHOULD</em> also be limited in this fashion.
      </p>
      <div id="rfc.figure.u.5"></div><pre class="inline"><span id="rfc.iref.g.10"></span>    qvalue         = ( "0" [ "." 0*3DIGIT ] )
                   | ( "1" [ "." 0*3("0") ] )
</pre><p id="rfc.section.2.4.p.3">"Quality values" is a misnomer, since these values merely represent relative degradation in desired quality.</p>
      <h2 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5</a>&nbsp;<a id="language.tags" href="#language.tags">Language Tags</a></h2>
      <p id="rfc.section.2.5.p.1">A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information
         to other human beings. Computer languages are explicitly excluded. HTTP uses language tags within the Accept-Language and
         Content-Language fields.
      </p>
      <p id="rfc.section.2.5.p.2">The syntax and registry of HTTP language tags is the same as that defined by RFC 1766 <a href="#RFC1766" id="rfc.xref.RFC1766.1"><cite title="Tags for the Identification of Languages">[RFC1766]</cite></a>. In summary, a language tag is composed of 1 or more parts: A primary language tag and a possibly empty series of subtags:
      </p>
      <div id="rfc.figure.u.6"></div><pre class="inline"><span id="rfc.iref.g.11"></span><span id="rfc.iref.g.12"></span><span id="rfc.iref.g.13"></span>     language-tag  = primary-tag *( "-" subtag )
     primary-tag   = 1*8ALPHA
     subtag        = 1*8ALPHA
</pre><p id="rfc.section.2.5.p.4">White space is not allowed within the tag and all tags are case-insensitive. The name space of language tags is administered
         by the IANA. Example tags include:
      </p>
      <div id="rfc.figure.u.7"></div><pre class="text">    en, en-US, en-cockney, i-cherokee, x-pig-latin
</pre><p id="rfc.section.2.5.p.6">where any two-letter primary-tag is an ISO-639 language abbreviation and any two-letter initial subtag is an ISO-3166 country
         code. (The last three tags above are not registered tags; all but the last are examples of tags which could be registered
         in future.)
      </p>
      <h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a id="entity" href="#entity">Entity</a></h1>
      <p id="rfc.section.3.p.1">Request and Response messages <em class="bcp14">MAY</em> transfer an entity if not otherwise restricted by the request method or response status code. An entity consists of entity-header
         fields and an entity-body, although some responses will only include the entity-headers.
      </p>
      <p id="rfc.section.3.p.2">In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives
         the entity.
      </p>
      <h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a id="entity.header.fields" href="#entity.header.fields">Entity Header Fields</a></h2>
      <p id="rfc.section.3.1.p.1">Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified
         by the request. Some of this metainformation is <em class="bcp14">OPTIONAL</em>; some might be <em class="bcp14">REQUIRED</em> by portions of this specification.
      </p>
      <div id="rfc.figure.u.8"></div><pre class="inline"><span id="rfc.iref.g.14"></span><span id="rfc.iref.g.15"></span>    entity-header  = Allow                    ; <a href="#Part2" id="rfc.xref.Part2.1"><cite title="HTTP/1.1, part 2: Message Semantics">[Part2]</cite></a>, <a href="p2-semantics.html#header.allow" title="Allow">Section 10.1</a>
                   | Content-Encoding         ; <a href="#header.content-encoding" id="rfc.xref.header.content-encoding.2" title="Content-Encoding">Section&nbsp;5.5</a>
                   | Content-Language         ; <a href="#header.content-language" id="rfc.xref.header.content-language.1" title="Content-Language">Section&nbsp;5.6</a>
                   | Content-Length           ; <a href="#Part1" id="rfc.xref.Part1.1"><cite title="HTTP/1.1, part 1: URIs, Connections, and Message Parsing">[Part1]</cite></a>, <a href="p1-messaging.html#header.content-length" title="Content-Length">Section 8.2</a>
                   | Content-Location         ; <a href="#header.content-location" id="rfc.xref.header.content-location.1" title="Content-Location">Section&nbsp;5.7</a>
                   | Content-MD5              ; <a href="#header.content-md5" id="rfc.xref.header.content-md5.1" title="Content-MD5">Section&nbsp;5.8</a>
                   | Content-Range            ; <a href="#Part5" id="rfc.xref.Part5.2"><cite title="HTTP/1.1, part 5: Range Requests and Partial Responses">[Part5]</cite></a>, <a href="p5-range.html#header.content-range" title="Content-Range">Section 5.2</a>
                   | Content-Type             ; <a href="#header.content-type" id="rfc.xref.header.content-type.2" title="Content-Type">Section&nbsp;5.9</a>
                   | Expires                  ; <a href="#Part6" id="rfc.xref.Part6.1"><cite title="HTTP/1.1, part 6: Caching">[Part6]</cite></a>, <a href="p6-cache.html#header.expires" title="Expires">Section 3.3</a>
                   | Last-Modified            ; <a href="#Part4" id="rfc.xref.Part4.1"><cite title="HTTP/1.1, part 4: Conditional Requests">[Part4]</cite></a>, <a href="p4-conditional.html#header.last-modified" title="Last-Modified">Section 6.6</a>
                   | extension-header

    extension-header = message-header
</pre><p id="rfc.section.3.1.p.3">The extension-header mechanism allows additional entity-header fields to be defined without changing the protocol, but these
         fields cannot be assumed to be recognizable by the recipient. Unrecognized header fields <em class="bcp14">SHOULD</em> be ignored by the recipient and <em class="bcp14">MUST</em> be forwarded by transparent proxies.
      </p>
      <h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="entity.body" href="#entity.body">Entity Body</a></h2>
      <p id="rfc.section.3.2.p.1">The entity-body (if any) sent with an HTTP request or response is in a format and encoding defined by the entity-header fields.</p>
      <div id="rfc.figure.u.9"></div><pre class="inline"><span id="rfc.iref.g.16"></span>    entity-body    = *OCTET
</pre><p id="rfc.section.3.2.p.3">An entity-body is only present in a message when a message-body is present, as described in <a href="p1-messaging.html#message.body" title="Message Body">Section 4.3</a> of <a href="#Part1" id="rfc.xref.Part1.2"><cite title="HTTP/1.1, part 1: URIs, Connections, and Message Parsing">[Part1]</cite></a>. The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure
         safe and proper transfer of the message.
      </p>
      <h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a id="type" href="#type">Type</a></h3>
      <p id="rfc.section.3.2.1.p.1">When an entity-body is included with a message, the data type of that body is determined via the header fields Content-Type
         and Content-Encoding. These define a two-layer, ordered encoding model:
      </p>
      <div id="rfc.figure.u.10"></div><pre class="text">    entity-body := Content-Encoding( Content-Type( data ) )
</pre><p id="rfc.section.3.2.1.p.3">Content-Type specifies the media type of the underlying data. Content-Encoding may be used to indicate any additional content
         codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. There
         is no default encoding.
      </p>
      <p id="rfc.section.3.2.1.p.4">Any HTTP/1.1 message containing an entity-body <em class="bcp14">SHOULD</em> include a Content-Type header field defining the media type of that body. If and only if the media type is not given by a
         Content-Type field, the recipient <em class="bcp14">MAY</em> attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the
         resource. If the media type remains unknown, the recipient <em class="bcp14">SHOULD</em> treat it as type "application/octet-stream".
      </p>
      <h3 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;<a id="entity.length" href="#entity.length">Entity Length</a></h3>
      <p id="rfc.section.3.2.2.p.1">The entity-length of a message is the length of the message-body before any transfer-codings have been applied. <a href="p1-messaging.html#message.length" title="Message Length">Section 4.4</a> of <a href="#Part1" id="rfc.xref.Part1.3"><cite title="HTTP/1.1, part 1: URIs, Connections, and Message Parsing">[Part1]</cite></a> defines how the transfer-length of a message-body is determined.
      </p>
      <h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a id="content.negotiation" href="#content.negotiation">Content Negotiation</a></h1>
      <p id="rfc.section.4.p.1">Most HTTP responses include an entity which contains information for interpretation by a human user. Naturally, it is desirable
         to supply the user with the "best available" entity corresponding to the request. Unfortunately for servers and caches, not
         all users have the same preferences for what is "best," and not all user agents are equally capable of rendering all entity
         types. For that reason, HTTP has provisions for several mechanisms for "content negotiation" -- the process of selecting the
         best representation for a given response when there are multiple representations available. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> This is not called "format negotiation" because the alternate representations may be of the same media type, but use different
            capabilities of that type, be in different languages, etc.
         </dd>
      </dl>
      <p id="rfc.section.4.p.2">Any response containing an entity-body <em class="bcp14">MAY</em> be subject to negotiation, including error responses.
      </p>
      <p id="rfc.section.4.p.3">There are two kinds of content negotiation which are possible in HTTP: server-driven and agent-driven negotiation. These two
         kinds of negotiation are orthogonal and thus may be used separately or in combination. One method of combination, referred
         to as transparent negotiation, occurs when a cache uses the agent-driven negotiation information provided by the origin server
         in order to provide server-driven negotiation for subsequent requests.
      </p>
      <h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a id="server-driven.negotiation" href="#server-driven.negotiation">Server-driven Negotiation</a></h2>
      <p id="rfc.section.4.1.p.1">If the selection of the best representation for a response is made by an algorithm located at the server, it is called server-driven
         negotiation. Selection is based on the available representations of the response (the dimensions over which it can vary; e.g.
         language, content-coding, etc.) and the contents of particular header fields in the request message or on other information
         pertaining to the request (such as the network address of the client).
      </p>
      <p id="rfc.section.4.1.p.2">Server-driven negotiation is advantageous when the algorithm for selecting from among the available representations is difficult
         to describe to the user agent, or when the server desires to send its "best guess" to the client along with the first response
         (hoping to avoid the round-trip delay of a subsequent request if the "best guess" is good enough for the user). In order to
         improve the server's guess, the user agent <em class="bcp14">MAY</em> include request header fields (Accept, Accept-Language, Accept-Encoding, etc.) which describe its preferences for such a response.
      </p>
      <p id="rfc.section.4.1.p.3">Server-driven negotiation has disadvantages: </p>
      <ol>
         <li>It is impossible for the server to accurately determine what might be "best" for any given user, since that would require
            complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want
            to view it on screen or print it on paper?).
         </li>
         <li>Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage
            of responses have multiple representations) and a potential violation of the user's privacy.
         </li>
         <li>It complicates the implementation of an origin server and the algorithms for generating responses to a request.</li>
         <li>It may limit a public cache's ability to use the same response for multiple user's requests.</li>
      </ol>
      <p id="rfc.section.4.1.p.4">HTTP/1.1 includes the following request-header fields for enabling server-driven negotiation through description of user agent
         capabilities and user preferences: Accept (<a href="#header.accept" id="rfc.xref.header.accept.2" title="Accept">Section&nbsp;5.1</a>), Accept-Charset (<a href="#header.accept-charset" id="rfc.xref.header.accept-charset.1" title="Accept-Charset">Section&nbsp;5.2</a>), Accept-Encoding (<a href="#header.accept-encoding" id="rfc.xref.header.accept-encoding.2" title="Accept-Encoding">Section&nbsp;5.3</a>), Accept-Language (<a href="#header.accept-language" id="rfc.xref.header.accept-language.1" title="Accept-Language">Section&nbsp;5.4</a>), and User-Agent (<a href="p2-semantics.html#header.user-agent" title="User-Agent">Section 10.9</a> of <a href="#Part2" id="rfc.xref.Part2.2"><cite title="HTTP/1.1, part 2: Message Semantics">[Part2]</cite></a>). However, an origin server is not limited to these dimensions and <em class="bcp14">MAY</em> vary the response based on any aspect of the request, including information outside the request-header fields or within extension
         header fields not defined by this specification.
      </p>
      <p id="rfc.section.4.1.p.5">The Vary header field <a href="#Part6" id="rfc.xref.Part6.2"><cite title="HTTP/1.1, part 6: Caching">[Part6]</cite></a> can be used to express the parameters the server uses to select a representation that is subject to server-driven negotiation.
      </p>
      <h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a id="agent-driven.negotiation" href="#agent-driven.negotiation">Agent-driven Negotiation</a></h2>
      <p id="rfc.section.4.2.p.1">With agent-driven negotiation, selection of the best representation for a response is performed by the user agent after receiving
         an initial response from the origin server. Selection is based on a list of the available representations of the response
         included within the header fields or entity-body of the initial response, with each representation identified by its own URI.
         Selection from among the representations may be performed automatically (if the user agent is capable of doing so) or manually
         by the user selecting from a generated (possibly hypertext) menu.
      </p>
      <p id="rfc.section.4.2.p.2">Agent-driven negotiation is advantageous when the response would vary over commonly-used dimensions (such as type, language,
         or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally
         when public caches are used to distribute server load and reduce network usage.
      </p>
      <p id="rfc.section.4.2.p.3">Agent-driven negotiation suffers from the disadvantage of needing a second request to obtain the best alternate representation.
         This second request is only efficient when caching is used. In addition, this specification does not define any mechanism
         for supporting automatic selection, though it also does not prevent any such mechanism from being developed as an extension
         and used within HTTP/1.1.
      </p>
      <p id="rfc.section.4.2.p.4">HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable) status codes for enabling agent-driven negotiation when
         the server is unwilling or unable to provide a varying response using server-driven negotiation.
      </p>
      <h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a id="transparent.negotiation" href="#transparent.negotiation">Transparent Negotiation</a></h2>
      <p id="rfc.section.4.3.p.1">Transparent negotiation is a combination of both server-driven and agent-driven negotiation. When a cache is supplied with
         a form of the list of available representations of the response (as in agent-driven negotiation) and the dimensions of variance
         are completely understood by the cache, then the cache becomes capable of performing server-driven negotiation on behalf of
         the origin server for subsequent requests on that resource.
      </p>
      <p id="rfc.section.4.3.p.2">Transparent negotiation has the advantage of distributing the negotiation work that would otherwise be required of the origin
         server and also removing the second request delay of agent-driven negotiation when the cache is able to correctly guess the
         right response.
      </p>
      <p id="rfc.section.4.3.p.3">This specification does not define any mechanism for transparent negotiation, though it also does not prevent any such mechanism
         from being developed as an extension that could be used within HTTP/1.1.
      </p>
      <h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a id="header.fields" href="#header.fields">Header Field Definitions</a></h1>
      <p id="rfc.section.5.p.1">This section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-header fields, both sender
         and recipient refer to either the client or the server, depending on who sends and who receives the entity.
      </p>
      <div id="rfc.iref.a.1"></div>
      <div id="rfc.iref.h.1"></div>
      <h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a id="header.accept" href="#header.accept">Accept</a></h2>
      <p id="rfc.section.5.1.p.1">The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers
         can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request
         for an in-line image.
      </p>
      <div id="rfc.figure.u.11"></div><pre class="inline"><span id="rfc.iref.g.17"></span><span id="rfc.iref.g.18"></span><span id="rfc.iref.g.19"></span><span id="rfc.iref.g.20"></span>    Accept         = "Accept" ":"
                     #( media-range [ accept-params ] )

    media-range    = ( "*/*"
                     | ( type "/" "*" )
                     | ( type "/" subtype )
                     ) *( ";" parameter )
    accept-params  = ";" "q" "=" qvalue *( accept-extension )
    accept-extension = ";" token [ "=" ( token | quoted-string ) ]
</pre><p id="rfc.section.5.1.p.3">The asterisk "*" character is used to group media types into ranges, with "*/*" indicating all media types and "type/*" indicating
         all subtypes of that type. The media-range <em class="bcp14">MAY</em> include media type parameters that are applicable to that range.
      </p>
      <p id="rfc.section.5.1.p.4">Each media-range <em class="bcp14">MAY</em> be followed by one or more accept-params, beginning with the "q" parameter for indicating a relative quality factor. The first
         "q" parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user
         agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (<a href="#quality.values" title="Quality Values">Section&nbsp;2.4</a>). The default value is q=1. 
      </p>
      <dl class="empty">
         <dd> <b>Note:</b> Use of the "q" parameter name to separate media type parameters from Accept extension parameters is due to historical practice.
            Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to
            be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters
            in Accept. Future media types are discouraged from registering any parameter named "q".
         </dd>
      </dl>
      <p id="rfc.section.5.1.p.5">The example</p>
      <div id="rfc.figure.u.12"></div><pre class="text">    Accept: audio/*; q=0.2, audio/basic
</pre><p id="rfc.section.5.1.p.7"> <em class="bcp14">SHOULD</em> be interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in
         quality."
      </p>
      <p id="rfc.section.5.1.p.8">If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field
         is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then
         the server <em class="bcp14">SHOULD</em> send a 406 (not acceptable) response.
      </p>
      <p id="rfc.section.5.1.p.9">A more elaborate example is</p>
      <div id="rfc.figure.u.13"></div><pre class="text">    Accept: text/plain; q=0.5, text/html,
            text/x-dvi; q=0.8, text/x-c
</pre><p id="rfc.section.5.1.p.11">Verbally, this would be interpreted as "text/html and text/x-c are the preferred media types, but if they do not exist, then
         send the text/x-dvi entity, and if that does not exist, send the text/plain entity."
      </p>
      <p id="rfc.section.5.1.p.12">Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies
         to a given type, the most specific reference has precedence. For example,
      </p>
      <div id="rfc.figure.u.14"></div><pre class="text">    Accept: text/*, text/html, text/html;level=1, */*
</pre><p id="rfc.section.5.1.p.14">have the following precedence:</p>
      <div id="rfc.figure.u.15"></div><pre class="text">    1) text/html;level=1
    2) text/html
    3) text/*
    4) */*
</pre><p id="rfc.section.5.1.p.16">The media type quality factor associated with a given type is determined by finding the media range with the highest precedence
         which matches that type. For example,
      </p>
      <div id="rfc.figure.u.16"></div><pre class="text">    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
            text/html;level=2;q=0.4, */*;q=0.5
</pre><p id="rfc.section.5.1.p.18">would cause the following values to be associated:</p>
      <div id="rfc.figure.u.17"></div><pre class="text">    text/html;level=1         = 1
    text/html                 = 0.7
    text/plain                = 0.3
    image/jpeg                = 0.5
    text/html;level=2         = 0.4
    text/html;level=3         = 0.7
</pre><p id="rfc.section.5.1.p.20"> <b>Note:</b> A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent
         is a closed system which cannot interact with other rendering agents, this default set ought to be configurable by the user.
      </p>
      <div id="rfc.iref.a.2"></div>
      <div id="rfc.iref.h.2"></div>
      <h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a id="header.accept-charset" href="#header.accept-charset">Accept-Charset</a></h2>
      <p id="rfc.section.5.2.p.1">The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This
         field allows clients capable of understanding more comprehensive or special-purpose character sets to signal that capability
         to a server which is capable of representing documents in those character sets.
      </p>
      <div id="rfc.figure.u.18"></div><pre class="inline"><span id="rfc.iref.g.21"></span>   Accept-Charset = "Accept-Charset" ":"
           1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )
</pre><p id="rfc.section.5.2.p.3">Character set values are described in <a href="#character.sets" title="Character Sets">Section&nbsp;2.1</a>. Each charset <em class="bcp14">MAY</em> be given an associated quality value which represents the user's preference for that charset. The default value is q=1. An
         example is
      </p>
      <div id="rfc.figure.u.19"></div><pre class="text">   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre><p id="rfc.section.5.2.p.5">The special value "*", if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is
         not mentioned elsewhere in the Accept-Charset field. If no "*" is present in an Accept-Charset field, then all character sets
         not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly
         mentioned.
      </p>
      <p id="rfc.section.5.2.p.6">If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is
         present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server <em class="bcp14">SHOULD</em> send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.
      </p>
      <div id="rfc.iref.a.3"></div>
      <div id="rfc.iref.h.3"></div>
      <h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a id="header.accept-encoding" href="#header.accept-encoding">Accept-Encoding</a></h2>
      <p id="rfc.section.5.3.p.1">The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (<a href="#content.codings" title="Content Codings">Section&nbsp;2.2</a>) that are acceptable in the response.
      </p>
      <div id="rfc.figure.u.20"></div><pre class="inline"><span id="rfc.iref.g.22"></span><span id="rfc.iref.g.23"></span>    Accept-Encoding  = "Accept-Encoding" ":"
           