<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "July">
  <!ENTITY ID-YEAR "2012">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY architecture               "<xref target='Part1' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY abnf-extension             "<xref target='Part1' x:rel='#abnf.extension' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='Part1' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY whitespace                 "<xref target='Part1' x:rel='#whitespace' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-components           "<xref target='Part1' x:rel='#field.components' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                  "<xref target='Part2' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY entity-tags                "<xref target='Part4' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY weak-and-strong-validators "<xref target='Part4' x:rel='#weak.and.strong.validators' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY lastmod-comparison         "<xref target='Part4' x:rel='#lastmod.comparison' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY p6-heuristic               "<xref target='Part6' x:rel='#heuristic.freshness' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p5-range-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="prev" basename="p4-conditional"/>
<x:link rel="next" basename="p6-cache"/>
<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
<front>

  <title abbrev="HTTP/1.1, Part 5">HTTP/1.1, part 5: Range Requests and Partial Responses</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. HTTP has been in
   use by the World Wide Web global information initiative since 1990. This
   document is Part 5 of the seven-part specification that defines the protocol
   referred to as "HTTP/1.1" and, taken together, obsoletes RFC 2616.
</t>
<t>
   Part 5 defines range requests and the rules for constructing and
   combining responses to those requests.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft takes place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.19"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   HTTP clients often encounter interrupted data transfers as a result
   of canceled requests or dropped connections.  When a client has stored
   a partial representation, it is desirable to request the remainder
   of that representation in a subsequent request rather than transfer
   the entire representation.
   There are also a number of Web applications that benefit from being
   able to request only a subset of a larger representation, such as a
   single page of a very large document or only part of an image to be
   rendered by a device with limited local storage.
</t>
<t>
   This document defines HTTP/1.1 range requests,
   partial responses, and the multipart/byteranges media type.
   The protocol for range requests is an &OPTIONAL; feature of HTTP,
   designed so resources or recipients that do not implement this feature
   can respond as if it is a normal GET request without impacting
   interoperability.  Partial responses are indicated by a distinct status
   code to not be mistaken for full responses by intermediate caches
   that might not implement the feature.
</t>
<t>
   Although the HTTP range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.
</t>

<section title="Conformance and Error Handling" anchor="intro.conformance.and.error.handling">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, HTTP requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement. See &architecture; for definitions
   of these terms.
</t>
<t>
   The verb "generate" is used instead of "send" where a requirement
   differentiates between creating a protocol element and merely forwarding a
   received element downstream.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP. Note that
   SHOULD-level requirements are relevant here, unless one of the documented
   exceptions is applicable.
</t>
<t>
   This document also uses ABNF to define valid protocol elements
   (<xref target="notation"/>).
   In addition to the prose requirements placed upon them, senders &MUST-NOT;
   generate protocol elements that do not match the grammar defined by the
   ABNF rules for those protocol elements that are applicable to the sender's
   role. If a received protocol element is processed, the recipient &MUST; be
   able to parse any value that would match the ABNF rules for that protocol
   element, excluding only those rules not applicable to the recipient's role.
</t>
<t>
   Unless noted otherwise, a recipient &MAY; attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the
   <x:ref>Location</x:ref> header field doesn't parse according to the ABNF,
   whereas a systems control client might consider any form of error recovery
   to be dangerous.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CHAR"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation
   of <xref target="RFC5234"/> with the list rule extension defined in
   &notation;.  <xref target="collected.abnf"/> shows the collected ABNF
   with the list rule expanded.
</t>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>

<t>
  Note that all rules derived from <x:ref>token</x:ref> are to
  be compared case-insensitively, like <x:ref>range-unit</x:ref> and
  <x:ref>acceptable-ranges</x:ref>.
</t>

<section title="Core Rules" anchor="core.rules">
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="HTTP-date"/>
<t>
  The core rules below are defined in <xref target="Part1"/> and
  <xref target="Part2"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>        = &lt;OWS, defined in &whitespace;&gt;
  <x:ref>token</x:ref>      = &lt;token, defined in &field-components;&gt;
  <x:ref>HTTP-date</x:ref>  = &lt;HTTP-date, defined in &http-date;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification" anchor="abnf.dependencies">
  <x:anchor-alias value="entity-tag"/>
<t>
  The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part4--><artwork type="abnf2616">
  <x:ref>entity-tag</x:ref> = &lt;entity-tag, defined in &entity-tags;&gt;
</artwork></figure>
</section>

</section>

</section>


<section title="Range Units" anchor="range.units">
  <x:anchor-alias value="bytes-unit"/>
  <x:anchor-alias value="other-range-unit"/>
  <x:anchor-alias value="range-unit"/>
<t>
   HTTP/1.1 allows a client to request that only part (a range) of the
   representation be included within the response. HTTP/1.1 uses range
   units in the <x:ref>Range</x:ref> (<xref target="header.range"/>) and
   <x:ref>Content-Range</x:ref> (<xref target="header.content-range"/>)
   header fields. A representation can be broken down into subranges according
   to various structural units.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="range-unit"/><iref primary="true" item="Grammar" subitem="bytes-unit"/><iref primary="true" item="Grammar" subitem="other-range-unit"/>
  <x:ref>range-unit</x:ref>       = <x:ref>bytes-unit</x:ref> / <x:ref>other-range-unit</x:ref>
  <x:ref>bytes-unit</x:ref>       = "bytes"
  <x:ref>other-range-unit</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
  HTTP/1.1 has been designed to allow implementations of applications
  that do not depend on knowledge of ranges. The only range unit defined
  by HTTP/1.1 is "bytes". Additional specifiers can be defined as described
  in <xref target="range.specifier.registry"/>.
</t>
<t>
  If a range unit is not understood in a request, a server &MUST; ignore
  the whole <x:ref>Range</x:ref> header field (<xref target="header.range"/>).
  If a range unit is not understood in a response, an intermediary 
  &SHOULD; pass the response to the client; a client &MUST; fail.
</t>

<section title="Range Specifier Registry" anchor="range.specifier.registry">
<t>
   The HTTP Range Specifier Registry defines the name space for the range
   specifier names.
</t>
<t>
   Registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
  Values to be added to this name space require IETF Review
  (see <xref target="RFC5226" x:fmt="," x:sec="4.1"/>).
</t>
<t>
   The registry itself is maintained at
   <eref target="http://www.iana.org/assignments/http-range-specifiers"/>.
</t>
</section>

</section>

<section title="Status Code Definitions" anchor="status.code.definitions">
<section title="206 Partial Content" anchor="status.206">
  <iref primary="true" item="206 Partial Content (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="206 Partial Content" x:for-anchor=""/>
  <x:anchor-alias value="206"/>
  <x:anchor-alias value="206 (Partial Content)"/>
<t>
   The server has fulfilled the partial GET request for the resource.
   The request &MUST; have included a <x:ref>Range</x:ref> header field
   (<xref target="header.range"/>) indicating the desired range, and &MAY; have
   included an <x:ref>If-Range</x:ref> header field
   (<xref target="header.if-range"/>) to make the request conditional.
</t>
<t>
   The response &MUST; include the following header fields:
  <list style="symbols">
    <t>
        Either a <x:ref>Content-Range</x:ref> header field
        (<xref target="header.content-range"/>) indicating
        the range included with this response, or a multipart/byteranges
        <x:ref>Content-Type</x:ref> including Content-Range fields for each
        part. If a <x:ref>Content-Length</x:ref> header field is present in the
        response, its value &MUST; match the actual number of octets
        transmitted in the message body.
    </t>
    <t>
        Date
    </t>
    <t>
        <x:ref>Cache-Control</x:ref>, <x:ref>ETag</x:ref>,
        <x:ref>Expires</x:ref>, <x:ref>Content-Location</x:ref> and/or
        <x:ref>Vary</x:ref>, if the header field would have been sent in a
        <x:ref>200 (OK)</x:ref> response to the same request
    </t>
  </list>
</t>
<t>
   If a 206 is sent in response to a request with an <x:ref>If-Range</x:ref>
   header field, it &SHOULD-NOT; include other representation header fields.
   Otherwise, the response &MUST; include all of the representation header
   fields that would have been returned with a <x:ref>200 (OK)</x:ref> response
   to the same request.
</t>
<t>
   Caches &MAY; use a heuristic (see &p6-heuristic;) to determine 
   freshness for 206 responses.
</t>
</section>

<section title="416 Requested Range Not Satisfiable" anchor="status.416">
  <iref primary="true" item="416 Requested Range Not Satisfiable (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="416 Requested Range Not Satisfiable" x:for-anchor=""/>
  <x:anchor-alias value="416 (Requested Range Not Satisfiable)"/>
<t>
   A server &SHOULD; return a response with this status code if a request
   included a <x:ref>Range</x:ref> header field (<xref target="header.range"/>),
   and none of the ranges-specifier values in this field overlap the current
   extent of the selected resource, and the request did not include an
   <x:ref>If-Range</x:ref> header field (<xref target="header.if-range"/>).
   (For byte-ranges, this means that the first-byte-pos of all of the
   byte-range-spec values were greater than the current length of the selected
   resource.)
</t>
<t>
   When this status code is returned for a byte-range request, the
   response &SHOULD; include a <x:ref>Content-Range</x:ref> header field
   specifying the current length of the representation (see <xref target="header.content-range"/>).
   This response &MUST-NOT; use the multipart/byteranges content-type. For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 416 Requested Range Not Satisfiable
Date: Mon, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
Content-Type: image/gif
</artwork></figure>
<x:note>
  <t>
    &Note; Clients cannot depend on servers to send a <x:ref>416 (Requested
    Range Not Satisfiable)</x:ref> response instead of a <x:ref>200 (OK)</x:ref>
    response for an unsatisfiable <x:ref>Range</x:ref> header field, since not
    all servers implement this header field.
  </t>
</x:note>
</section>
</section>

<section title="Responses to a Range Request">
<section title="Response to a Single and Multiple Ranges Request">
<t>
   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a <x:ref>Content-Range</x:ref> header field, and a
   <x:ref>Content-Length</x:ref> header field showing the number of bytes
   actually transferred. For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif
</artwork></figure>
<t>
   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is "multipart/byteranges" as defined
   in <xref target="internet.media.type.multipart.byteranges"/>.
</t>
<t>
   A server &MAY; combine requested ranges when those ranges are overlapping
   (see <xref target="overlapping.ranges"/>).
</t>
<t>
   A response to a request for a single range &MUST-NOT; be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, &MAY; be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message &MUST-NOT; ask for multiple
   ranges in a single request.
</t>
<t>
   When a client asks for multiple ranges in one request, the
   server &SHOULD; return them in the order that they appeared in the
   request.
</t>
</section>

<section title="Combining Ranges" anchor="combining.byte.ranges">
<t>
   A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more Range
   specifications.  After several such transfers, a client might have
   received several ranges of the same representation.  These ranges can only
   be safely combined if they all have in common the same strong validator,
   where "strong validator" is defined to be either an entity-tag that is
   not marked as weak (&entity-tags;) or, if no entity-tag is provided, a
   <x:ref>Last-Modified</x:ref> value that is strong in the sense defined by
   &lastmod-comparison;.
</t>
<t>
   When a client receives an incomplete <x:ref>200 (OK)</x:ref> or <x:ref>206 (Partial Content)</x:ref>
   response and already has one or more stored responses for the same method
   and effective request URI, all of the stored responses with the same
   strong validator &MAY; be combined with the partial content in this new
   response.  If none of the stored responses contain the same strong
   validator, then this new response corresponds to a new representation
   and &MUST-NOT; be combined with the existing stored responses.
</t>
<t>
   If the new response is an incomplete <x:ref>200 (OK)</x:ref> response, then the header
   fields of that new response are used for any combined response and replace
   those of the matching stored responses.
</t>
<t>
   If the new response is a <x:ref>206 (Partial Content)</x:ref> response and at least one
   of the matching stored responses is a <x:ref>200 (OK)</x:ref>, then the combined response
   header fields consist of the most recent 200 response's header fields.
   If all of the matching stored responses are 206 responses, then the
   stored response with the most header fields is used as the source of
   header fields for the combined response, except that the client &MUST;
   use other header fields provided in the new response, aside from
   <x:ref>Content-Range</x:ref>, to replace all instances of the corresponding
   header fields in the stored response.
</t>
<t>
   The combined response message body consists of the union of partial
   content ranges in the new response and each of the selected responses.
   If the union consists of the entire range of the representation, then the
   combined response &MUST; be recorded as a complete <x:ref>200 (OK)</x:ref>
   response with a <x:ref>Content-Length</x:ref> header field that reflects the
   complete length. Otherwise, the combined response(s) &MUST; include a
   <x:ref>Content-Range</x:ref> header field describing the included range(s)
   and be recorded as incomplete.  If the union consists of a discontinuous
   range of the representation, then the client &MAY; store it as either a
   multipart range response or as multiple <x:ref>206</x:ref> responses with
   one continuous range each.
</t>
</section>
</section>

<section title="Header Field Definitions" anchor="header.field.definitions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to range requests and partial responses.
</t>

<section title="Accept-Ranges" anchor="header.accept-ranges">
  <iref primary="true" item="Accept-Ranges header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Accept-Ranges" x:for-anchor=""/>
  <x:anchor-alias value="Accept-Ranges"/>
  <x:anchor-alias value="acceptable-ranges"/>
<t>
   The "Accept-Ranges" header field allows a resource to indicate
   its acceptance of range requests.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Accept-Ranges"/><iref primary="true" item="Grammar" subitem="acceptable-ranges"/>
  <x:ref>Accept-Ranges</x:ref>     = <x:ref>acceptable-ranges</x:ref>
  <x:ref>acceptable-ranges</x:ref> = 1#<x:ref>range-unit</x:ref> / "none"
</artwork></figure>
<t>
   Origin servers that accept byte-range requests &MAY; send
</t>
<figure><artwork type="example">
  Accept-Ranges: bytes
</artwork></figure>
<t>
   but are not required to do so. Clients &MAY; generate range
   requests without having received this header field for the resource
   involved. Range units are defined in <xref target="range.units"/>.
</t>
<t>
   Servers that do not accept any kind of range request for a
   resource &MAY; send
</t>
<figure><artwork type="example">
  Accept-Ranges: none
</artwork></figure>
<t>
   to advise the client not to attempt a range request.
</t>
</section>

<section title="Content-Range" anchor="header.content-range">
  <iref primary="true" item="Content-Range header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Content-Range" x:for-anchor=""/>
  <x:anchor-alias value="byte-content-range-spec"/>
  <x:anchor-alias value="byte-range-resp-spec"/>
  <x:anchor-alias value="Content-Range"/>
  <x:anchor-alias value="instance-length"/>
  <x:anchor-alias value="other-content-range-spec"/>
  <x:anchor-alias value="other-range-resp-spec"/>
<t>
   The "Content-Range" header field is sent with a partial representation to
   specify where in the full representation the payload body is intended to be
   applied.
</t>
<t>   
   Range units are defined in <xref target="range.units"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Range"/><iref primary="true" item="Grammar" subitem="byte-content-range-spec"/><iref primary="true" item="Grammar" subitem="byte-range-resp-spec"/><iref primary="true" item="Grammar" subitem="instance-length"/>
  <x:ref>Content-Range</x:ref>           = <x:ref>byte-content-range-spec</x:ref>
                          / <x:ref>other-content-range-spec</x:ref>
                          
  <x:ref>byte-content-range-spec</x:ref> = <x:ref>bytes-unit</x:ref> <x:ref>SP</x:ref>
                            <x:ref>byte-range-resp-spec</x:ref> "/"
                            ( <x:ref>instance-length</x:ref> / "*" )
  
  <x:ref>byte-range-resp-spec</x:ref>    = (<x:ref>first-byte-pos</x:ref> "-" <x:ref>last-byte-pos</x:ref>)
                          / "*"
                          
  <x:ref>instance-length</x:ref>         = 1*<x:ref>DIGIT</x:ref>
  
  <x:ref>other-content-range-spec</x:ref> = <x:ref>other-range-unit</x:ref> <x:ref>SP</x:ref>
                             <x:ref>other-range-resp-spec</x:ref>
  <x:ref>other-range-resp-spec</x:ref>    = *<x:ref>CHAR</x:ref>
</artwork></figure>
<t>
   The header field &SHOULD; indicate the total length of the full representation,
   unless this length is unknown or difficult to determine. The asterisk
   "*" character means that the instance-length is unknown at the time
   when the response was generated.
</t>
<t>
   Unlike byte-ranges-specifier values (see <xref target="byte.ranges"/>), a byte-range-resp-spec
   &MUST; only specify one range, and &MUST; contain
   absolute byte positions for both the first and last byte of the
   range.
</t>
<t>
   A byte-content-range-spec with a byte-range-resp-spec whose last-byte-pos
   value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-spec
   &MUST; ignore it and any content transferred along with it.
</t>
<t>
   In the case of a byte range request:
   A server sending a response with status code <x:ref>416 (Requested Range Not
   Satisfiable)</x:ref> &SHOULD; include a Content-Range field with a byte-range-resp-spec
   of "*". The instance-length specifies the current length of
   the selected resource. A response with status code <x:ref>206 (Partial Content)</x:ref>
   &MUST-NOT; include a Content-Range field with a byte-range-resp-spec of "*".
</t>
<t>
  The "Content-Range" header field has no meaning for status codes that do not 
  explicitly describe its semantic. Currently, only status codes
  <x:ref>206 (Partial Content)</x:ref> and <x:ref>416 (Requested Range Not Satisfiable)</x:ref> describe
  the meaning of this header field.
</t>
<t>
   Examples of byte-content-range-spec values, assuming that the representation
   contains a total of 1234 bytes:
   <list style="symbols">
      <t>
        The first 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  bytes 0-499/1234
</artwork></figure>
      </t>    
      <t>
        The second 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  bytes 500-999/1234
</artwork></figure>
      </t>    
      <t>
        All except for the first 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  bytes 500-1233/1234
</artwork></figure>
      </t>    
      <t>
        The last 500 bytes:
<figure><artwork type="example" x:indent-with="   ">
  bytes 734-1233/1234
</artwork></figure>
      </t>    
   </list>
</t>
<t>
   If the server ignores a byte-range-spec (for example if it is
   syntactically invalid, or if it might be seen as a denial-of-service
   attack), the server &SHOULD; treat the request as if the invalid <x:ref>Range</x:ref>
   header field did not exist. (Normally, this means return a <x:ref>200 (OK)</x:ref>
   response containing the full representation).
</t>
</section>

<section title="If-Range" anchor="header.if-range">
  <iref primary="true" item="If-Range header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="If-Range" x:for-anchor=""/>
  <x:anchor-alias value="If-Range"/>
<t>
   If a client has a partial copy of a representation and wishes
   to have an up-to-date copy of the entire representation, it could use the
   <x:ref>Range</x:ref> header field with a conditional GET (using
   either or both of <x:ref>If-Unmodified-Since</x:ref> and
   <x:ref>If-Match</x:ref>.) However, if the condition fails because the
   representation has been modified, the client would then have to make a
   second request to obtain the entire current representation.
</t>
<t>
   The "If-Range" header field allows a client to "short-circuit" the second
   request. Informally, its meaning is "if the representation is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   representation".
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Range"/>
  <x:ref>If-Range</x:ref> = <x:ref>entity-tag</x:ref> / <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   Clients &MUST-NOT; use an entity-tag marked as weak in an If-Range
   field value and &MUST-NOT; use a <x:ref>Last-Modified</x:ref> date in an
   If-Range field value unless it has no entity-tag for the representation and
   the Last-Modified date it does have for the representation is strong
   in the sense defined by &lastmod-comparison;.
</t>
<t>
   A server that evaluates a conditional range request that is applicable
   to one of its representations &MUST; evaluate the condition as false if
   the entity-tag used as a validator is marked as weak or, when an HTTP-date
   is used as the validator, if the date value is not strong in the sense
   defined by &lastmod-comparison;. (A server can distinguish between a
   valid HTTP-date and any form of entity-tag by examining the first
   two characters.)
</t>
<t>
   The If-Range header field &SHOULD; only be sent by clients together with
   a Range header field.  The If-Range header field &MUST; be ignored if it
   is received in a request that does not include a Range header field.
   The If-Range header field &MUST; be ignored by a server that does not
   support the sub-range operation.
</t>
<t>
   If the validator given in the If-Range header field matches the current
   validator for the selected representation of the target resource, then
   the server &SHOULD; send the specified sub-range of the representation
   using a <x:ref>206 (Partial Content)</x:ref> response. If the validator does not match,
   then the server &SHOULD; send the entire representation using a <x:ref>200 (OK)</x:ref>
   response.
</t>
</section>

<section title="Range" anchor="header.range">
  <iref primary="true" item="Range header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Range" x:for-anchor=""/>

<section title="Byte Ranges" anchor="byte.ranges">
<t>
   Since all HTTP representations are transferred as sequences
   of bytes, the concept of a byte range is meaningful for any HTTP
   representation. (However, not all clients and servers need to support byte-range
   operations.)
</t>
<t>
   Byte range specifications in HTTP apply to the sequence of bytes in
   the representation body (not necessarily the same as the message body).
</t>
<t anchor="rule.ranges-specifier">
  <x:anchor-alias value="byte-range-set"/>
  <x:anchor-alias value="byte-range-spec"/>
  <x:anchor-alias value="byte-ranges-specifier"/>
  <x:anchor-alias value="first-byte-pos"/>
  <x:anchor-alias value="last-byte-pos"/>
  <x:anchor-alias value="ranges-specifier"/>
  <x:anchor-alias value="suffix-byte-range-spec"/>
  <x:anchor-alias value="suffix-length"/>
   A byte range operation &MAY; specify a single range of bytes, or a set
   of ranges within a single representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="ranges-specifier"/><iref primary="true" item="Grammar" subitem="byte-ranges-specifier"/><iref primary="true" item="Grammar" subitem="byte-range-set"/><iref primary="true" item="Grammar" subitem="byte-range-spec"/><iref primary="true" item="Grammar" subitem="first-byte-pos"/><iref primary="true" item="Grammar" subitem="last-byte-pos"/>
  <x:ref>byte-ranges-specifier</x:ref> = <x:ref>bytes-unit</x:ref> "=" <x:ref>byte-range-set</x:ref>
  <x:ref>byte-range-set</x:ref>  = 1#( <x:ref>byte-range-spec</x:ref> / <x:ref>suffix-byte-range-spec</x:ref> )
  <x:ref>byte-range-spec</x:ref> = <x:ref>first-byte-pos</x:ref> "-" [ <x:ref>last-byte-pos</x:ref> ]
  <x:ref>first-byte-pos</x:ref>  = 1*<x:ref>DIGIT</x:ref>
  <x:ref>last-byte-pos</x:ref>   = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range. The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive. Byte offsets start at zero.
</t>
<t>
   If the last-byte-pos value is present, it &MUST; be greater than or
   equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec
   is syntactically invalid. The recipient of a byte-range-set
   that includes one or more syntactically invalid byte-range-spec
   values &MUST; ignore the header field that includes that byte-range-set.
</t>
<t>
   If the last-byte-pos value is absent, or if the value is greater than
   or equal to the current length of the representation body, last-byte-pos is
   taken to be equal to one less than the current length of the representation
   in bytes.
</t>
<t>
   By its choice of last-byte-pos, a client can limit the number of
   bytes retrieved without knowing the size of the representation.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="suffix-byte-range-spec"/><iref primary="true" item="Grammar" subitem="suffix-length"/>
  <x:ref>suffix-byte-range-spec</x:ref> = "-" <x:ref>suffix-length</x:ref>
  <x:ref>suffix-length</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   A suffix-byte-range-spec is used to specify the suffix of the
   representation body, of a length given by the suffix-length value. (That is,
   this form specifies the last N bytes of a representation.) If the
   representation is shorter than the specified suffix-length, the entire
   representation is used.
</t>
<t>
   If a syntactically valid byte-range-set includes at least one byte-range-spec
   whose first-byte-pos is less than the current length of
   the representation, or at least one suffix-byte-range-spec with a non-zero
   suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set
   is unsatisfiable, the server &SHOULD; return a response with a 
   <x:ref>416 (Requested Range Not Satisfiable)</x:ref> status code. Otherwise, the server
   &SHOULD; return a response with a <x:ref>206 (Partial Content)</x:ref> status code
   containing the satisfiable ranges of the representation.
</t>
<t>
   In the byte range syntax, <x:ref>first-byte-pos</x:ref>,
   <x:ref>last-byte-pos</x:ref>, and <x:ref>suffix-length</x:ref> are
   expressed as decimal number of octets.  Since there is no predefined limit
   to the length of an HTTP payload, recipients &SHOULD; anticipate
   potentially large decimal numerals and prevent parsing errors due to integer
   conversion overflows.
</t>
<t>
   Examples of byte-ranges-specifier values (assuming a representation of
   length 10000):
  <list style="symbols">
     <t>The first 500 bytes (byte offsets 0-499, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=0-499
</artwork></figure>
    </t>
     <t>The second 500 bytes (byte offsets 500-999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=500-999
</artwork></figure>
    </t>
     <t>The final 500 bytes (byte offsets 9500-9999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=-500
</artwork></figure>
    Or:
<figure><artwork type="example" x:indent-with="   ">
  bytes=9500-
</artwork></figure>
    </t>
     <t>The first and last bytes only (bytes 0 and 9999):
<figure><artwork type="example" x:indent-with="   ">
  bytes=0-0,-1
</artwork></figure>
     </t>
     <t>Several legal but not canonical specifications of the second 500
        bytes (byte offsets 500-999, inclusive):
<figure><artwork type="example" x:indent-with="   ">
  bytes=500-600,601-999
  bytes=500-700,601-999
</artwork></figure>
     </t>
  </list>
</t>
</section>

<section title="Range Retrieval Requests" anchor="range.retrieval.requests">
  <x:anchor-alias value="Range"/>
  <x:anchor-alias value="other-ranges-specifier"/>
  <x:anchor-alias value="other-range-set"/>
<t>
   The "Range" header field defines the GET method (conditional or
   not) to request one or more sub-ranges of the response representation body, instead
   of the entire representation body.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Range"/>
  <x:ref>Range</x:ref> = <x:ref>byte-ranges-specifier</x:ref> / <x:ref>other-ranges-specifier</x:ref>
  <x:ref>other-ranges-specifier</x:ref> = <x:ref>other-range-unit</x:ref> "=" <x:ref>other-range-set</x:ref>
  <x:ref>other-range-set</x:ref> = 1*<x:ref>CHAR</x:ref>
</artwork></figure>
<t>
   A server &MAY; ignore the Range header field. However, origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   representations.
</t>
<t>
   If the server supports the Range header field and the specified range or
   ranges are appropriate for the representation:
  <list style="symbols">
     <t>The presence of a Range header field in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of <x:ref>206 (Partial Content)</x:ref>
        instead of <x:ref>200 (OK)</x:ref>.</t>

     <t>The presence of a Range header field in a conditional GET (a request
        using one or both of <x:ref>If-Modified-Since</x:ref> and
        <x:ref>If-None-Match</x:ref>, or one or both of
        <x:ref>If-Unmodified-Since</x:ref> and <x:ref>If-Match</x:ref>) modifies
        what is returned if the GET is otherwise successful and the
        condition is true. It does not affect the <x:ref>304 (Not Modified)</x:ref>
        response returned if the conditional is false.</t>
  </list>
</t>
<t>
   In some cases, it might be more appropriate to use the If-Range
   header field (see <xref target="header.if-range"/>) in addition to the Range
   header field.
</t>
<t>
   If a proxy that supports ranges receives a Range request, forwards 
   the request to an inbound server, and receives an entire representation in
   reply, it &MAY; only return the requested range to its client. 
</t>
</section>
</section>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Status Code Registration" anchor="status.code.registration">
<t>
   The HTTP Status Code Registry located at <eref target="http://www.iana.org/assignments/http-status-codes"/>
   shall be updated with the registrations below:
</t>
<?BEGININC p5-range.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>206</c>
   <c>Partial Content</c>
   <c>
      <xref target="status.206"/>
   </c>
   <c>416</c>
   <c>Requested Range Not Satisfiable</c>
   <c>
      <xref target="status.416"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p5-range.iana-status-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   The Message Header Field Registry located at <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/> shall be updated
   with the permanent registrations below (see <xref target="RFC3864"/>):
</t>
<?BEGININC p5-range.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Accept-Ranges</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.accept-ranges"/>
   </c>
   <c>Content-Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-range"/>
   </c>
   <c>If-Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-range"/>
   </c>
   <c>Range</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.range"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p5-range.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="Range Specifier Registration" anchor="range.specifier.registration">
<t>
  The registration procedure for HTTP Range Specifiers is defined by 
  <xref target="range.specifier.registry"/> of this document.
</t>
<t>
   The HTTP Range Specifier Registry shall be created at <eref target="http://www.iana.org/assignments/http-range-specifiers"/>
   and be populated with the registrations below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.range.specifiers.table">
   <ttcol>Range Specifier Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>

   <c>bytes</c>
   <c>a range of octets</c>
   <c><xref target="range.units"/></c>

   <c>none</c>
   <c>reserved as keyword, indicating no ranges are supported</c>
   <c><xref target="header.accept-ranges"/></c>
</texttable>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.
</t>
<section title="Overlapping Ranges" anchor="overlapping.ranges">
<t>
   Range requests containing overlapping ranges can lead to the situation
   where a server is sending far more data than the size of the complete
   resource representation.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="Part1">
  <front>
    <title>HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
  <x:source href="p1-messaging.xml" basename="p1-messaging">
    <x:defines>Content-Length</x:defines>
  </x:source>
</reference>

<reference anchor="Part2">
  <front>
    <title>HTTP/1.1, part 2: Message Semantics, Payload and Content Negotiation</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="p2-semantics.xml" basename="p2-semantics">
    <x:defines>200 (OK)</x:defines>
    <x:defines>410 (Gone)</x:defines>
    <x:defines>Content-Location</x:defines>
    <x:defines>Content-Type</x:defines>
    <x:defines>Location</x:defines>
  </x:source>
</reference>

<reference anchor="Part4">
  <front>
    <title>HTTP/1.1, part 4: Conditional Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"/>
  <x:source href="p4-conditional.xml" basename="p4-conditional">
    <x:defines>304 (Not Modified)</x:defines>
    <x:defines>ETag</x:defines>
    <x:defines>If-Match</x:defines>
    <x:defines>If-Modified-Since</x:defines>
    <x:defines>If-None-Match</x:defines>
    <x:defines>If-Unmodified-Since</x:defines>
    <x:defines>Last-Modified</x:defines>
  </x:source>
</reference>

<reference anchor="Part6">
  <front>
    <title>HTTP/1.1, part 6: Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Rackspace</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="p6-cache.xml" basename="p6-cache">
    <x:defines>Cache-Control</x:defines>
    <x:defines>Expires</x:defines>
    <x:defines>Vary</x:defines>
  </x:source>
</reference>

<reference anchor="RFC2046">
  <front>
    <title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2046"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor="RFC4288">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="N. Freed">
      <organization>Sun Microsystems</organization>
      <address>
        <email>ned.freed@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="J. Klensin">
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <date year="2005" month="December"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="4288"/>
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

</references>

<section title="Internet Media Type multipart/byteranges" anchor="internet.media.type.multipart.byteranges">
<iref item="Media Type" subitem="multipart/byteranges" primary="true"/>
<iref item="multipart/byteranges Media Type" primary="true"/>
<t>
   When an HTTP <x:ref>206 (Partial Content)</x:ref> response message includes the
   content of multiple ranges (a response to a request for multiple
   non-overlapping ranges), these are transmitted as a multipart
   message body (<xref target="RFC2046" x:fmt="," x:sec="5.1"/>). The media type for this purpose is called
   "multipart/byteranges".  The following is to be registered with IANA <xref target="RFC4288"/>.
</t>
<t>
   The multipart/byteranges media type includes one or more parts, each
   with its own <x:ref>Content-Type</x:ref> and <x:ref>Content-Range</x:ref>
   fields. The required boundary parameter specifies the boundary string used
   to separate each body-part.
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      multipart
    </t>
    <t hangText="Subtype name:">
      byteranges
    </t>
    <t hangText="Required parameters:">
      boundary
    </t>
    <t hangText="Optional parameters:">
      none
    </t>
    <t hangText="Encoding considerations:">
      only "7bit", "8bit", or "binary" are permitted
    </t>
    <t hangText="Security considerations:">
      none
    </t>
    <t hangText="Interoperability considerations:">
      none
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.multipart.byteranges"/>).
    </t>
    <t hangText="Applications that use this media type:">
      HTTP components supporting multiple ranges in a single request.
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">none</t>
        <t hangText="File extension(s):">none</t>
        <t hangText="Macintosh file type code(s):">none</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors Section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      none
    </t>
    <t hangText="Author/Change controller:">
      IESG
    </t>
  </list>
</t>
<x:note>
  <t>
    &Note; Despite the name "multipart/byteranges" is not limited to the byte ranges only.
  </t>
</x:note>
<figure><preamble>
   For example:
</preamble><artwork type="example">
  HTTP/1.1 206 Partial Content
  Date: Wed, 15 Nov 1995 06:25:24 GMT
  Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
  Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES
  
  --THIS_STRING_SEPARATES
  Content-type: application/pdf
  Content-range: bytes 500-999/8000
  
  ...the first range...
  --THIS_STRING_SEPARATES
  Content-type: application/pdf
  Content-range: bytes 7000-7999/8000
  
  ...the second range
  --THIS_STRING_SEPARATES--
</artwork></figure>
<figure><preamble>
   Another example, using the "exampleunit" range unit:
</preamble>
<artwork type="example">
  HTTP/1.1 206 Partial Content
  Date: Tue, 14 Nov 1995 06:25:24 GMT
  Last-Modified: Tue, 14 July 04:58:08 GMT
  Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES
  
  --THIS_STRING_SEPARATES
  Content-type: video/example
  Content-range: exampleunit 1.2-4.3/25
  
  ...the first range...
  --THIS_STRING_SEPARATES
  Content-type: video/example
  Content-range: exampleunit 11.2-14.3/25
  
  ...the second range
  --THIS_STRING_SEPARATES--
</artwork>
</figure>
<t>
  Notes:
  <list style="numbers">
      <t>Additional CRLFs &MAY; precede the first boundary string in the body.</t>

      <t>Although <xref target="RFC2046"/> permits the boundary string to be
         quoted, some existing implementations handle a quoted boundary
         string incorrectly.</t>

      <t>A number of clients and servers were coded to an early draft
         of the byteranges specification to use a media type of
         multipart/x-byteranges<iref item="multipart/x-byteranges Media Type"/><iref item="Media Type" subitem="multipart/x-byteranges"/>, which is almost, but not quite
         compatible with the version documented in HTTP/1.1.</t>
  </list>
</t>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Introduce Range Specifier Registry.
  (<xref target="range.specifier.registry"/>)
</t>
<t>
  Clarify that it is not ok to use a weak validator in a <x:ref>206</x:ref> response.
  (<xref target="status.206"/>)
</t>
<t>
  Change ABNF productions for header fields to only define the field value.
  (<xref target="header.field.definitions"/>)
</t>
<t>
  Clarify that multipart/byteranges can consist of a single part.
  (<xref target="internet.media.type.multipart.byteranges"/>)
</t>
</section>

<?BEGININC p5-range.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p5-range.parsed-abnf">
<x:ref>Accept-Ranges</x:ref> = acceptable-ranges

<x:ref>Content-Range</x:ref> = byte-content-range-spec / other-content-range-spec

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part2], Section 5.1&gt;

<x:ref>If-Range</x:ref> = entity-tag / HTTP-date

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 3.2.1&gt;

<x:ref>Range</x:ref> = byte-ranges-specifier / other-ranges-specifier

<x:ref>acceptable-ranges</x:ref> = ( *( "," OWS ) range-unit *( OWS "," [ OWS
 range-unit ] ) ) / "none"

<x:ref>byte-content-range-spec</x:ref> = bytes-unit SP byte-range-resp-spec "/" (
 instance-length / "*" )
<x:ref>byte-range-resp-spec</x:ref> = ( first-byte-pos "-" last-byte-pos ) / "*"
<x:ref>byte-range-set</x:ref> = *( "," OWS ) ( byte-range-spec /
 suffix-byte-range-spec ) *( OWS "," [ OWS ( byte-range-spec /
 suffix-byte-range-spec ) ] )
<x:ref>byte-range-spec</x:ref> = first-byte-pos "-" [ last-byte-pos ]
<x:ref>byte-ranges-specifier</x:ref> = bytes-unit "=" byte-range-set
<x:ref>bytes-unit</x:ref> = "bytes"

<x:ref>entity-tag</x:ref> = &lt;entity-tag, defined in [Part4], Section 2.3&gt;

<x:ref>first-byte-pos</x:ref> = 1*DIGIT

<x:ref>instance-length</x:ref> = 1*DIGIT

<x:ref>last-byte-pos</x:ref> = 1*DIGIT

<x:ref>other-content-range-spec</x:ref> = other-range-unit SP other-range-resp-spec
<x:ref>other-range-resp-spec</x:ref> = *CHAR
<x:ref>other-range-set</x:ref> = 1*CHAR
<x:ref>other-range-unit</x:ref> = token
<x:ref>other-ranges-specifier</x:ref> = other-range-unit "=" other-range-set

<x:ref>range-unit</x:ref> = bytes-unit / other-range-unit

<x:ref>suffix-byte-range-spec</x:ref> = "-" suffix-length
<x:ref>suffix-length</x:ref> = 1*DIGIT

<x:ref>token</x:ref> = &lt;token, defined in [Part1], Section 3.2.4&gt;
</artwork>
</figure>
</section>
<?ENDINC p5-range.abnf-appendix ?>


<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC 2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/18"/>:
      "Cache validators in 206 responses"
      (<eref target="http://purl.org/NET/http-errata#ifrange206"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86"/>:
      "Normative up-to-date references"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-01">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/55"/>:
      "Updating to RFC4288"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-02" anchor="changes.since.02">
<t>
  Ongoing work on IANA Message Header Field Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header field registrations for headers defined
      in this document.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-03" anchor="changes.since.03">
<t>
  None.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-04" anchor="changes.since.04">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/133"/>:
      "multipart/byteranges minimum number of parts"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header field value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-05" anchor="changes.since.05">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/142"/>:
      "State base for *-byte-pos and suffix-length"
    </t>
  </list>
</t>
<t>
  Ongoing work on Custom Ranges (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/85"/>):
  <list style="symbols"> 
    <t>
      Remove bias in favor of byte ranges; allow custom ranges in ABNF.
    </t>
  </list>
</t>
<t>
  Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-06" anchor="changes.since.06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/161"/>:
      "base for numeric protocol elements"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-07" anchor="changes.since.07">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      Fixed discrepancy in the If-Range definition about allowed validators.
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/150" />: "multipart/byteranges for custom range units"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/151" />: "range unit missing from other-ranges-specifier in Range header"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/198"/>:
      "move IANA registrations for optional status codes"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-08" anchor="changes.since.08">
<t>
  No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-09" anchor="changes.since.09">
<t>
 No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/69"/>:
      "Clarify 'Requested Variant'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
  </list>
</t>
<t>
  Ongoing work on Custom Ranges (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/85"/>):
  <list style="symbols"> 
    <t>
      Add IANA registry.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-11" anchor="changes.since.11">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/217"/>:
      "Caches can't be required to serve ranges"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-12" anchor="changes.since.12">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/224"/>:
      "Header Classification"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-13" anchor="changes.since.13">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/276"/>:
      "untangle ABNFs for header fields"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-14" anchor="changes.since.14">
<t>
  None.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-15" anchor="changes.since.15">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://trac.tools.ietf.org/wg/httpbis/trac/ticket/175"/>:
      "Security consideration: range flooding"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-16" anchor="changes.since.16">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/186"/>:
      "Document HTTP's error-handling philosophy"
    </t>
    <t>
      <eref target="http://trac.tools.ietf.org/wg/httpbis/trac/ticket/301"/>:
      "Content-Range on responses other than 206"
    </t>
    <t>
      <eref target="http://trac.tools.ietf.org/wg/httpbis/trac/ticket/319"/>:
      "case sensitivity of ranges in p5"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-17" anchor="changes.since.17">
<t>
  None.
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-18" anchor="changes.since.18">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/311"/>:
      "Add limitations to Range to reduce its use as a denial-of-service tool"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p5-range-19" anchor="changes.since.19">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/358"/>:
      "ABNF list expansion code problem"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/361"/>:
      "ABNF requirements for recipients"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/367"/>:
      "reserve 'none' as byte range unit"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/368"/>:
      "note introduction of new IANA registries as normative changes"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/369"/>:
      "range units vs leading zeroes vs size"
    </t>
  </list>
</t>
</section>

</section>

</back>
</rfc>
