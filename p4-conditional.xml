<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "July">
  <!ENTITY ID-YEAR "2010">
  <!ENTITY notation                   "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation-abnf              "<xref target='Part1' x:rel='#notation.abnf' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules                "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                "<xref target='Part1' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching                    "<xref target='Part6' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-encoding     "<xref target='Part3' x:rel='#header.accept-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-range            "<xref target='Part5' x:rel='#header.if-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-range               "<xref target='Part5' x:rel='#header.range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-vary                "<xref target='Part6' x:rel='#header.vary' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY clockless                  "<xref target='Part1' x:rel='#clockless.origin.server.operation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY full-date                  "<xref target='Part1' x:rel='#date.time.formats.full.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transfer-codings           "<xref target='Part1' x:rel='#transfer.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-negotiation        "<xref target='Part3' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="draft"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<front>

  <title abbrev="HTTP/1.1, Part 4">HTTP/1.1, part 4: Conditional Requests</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <postal>
        <street>23 Corporate Plaza DR, Suite 280</street>
        <city>Newport Beach</city>
        <region>CA</region>
        <code>92660</code>
        <country>USA</country>
      </postal>
      <phone>+1-949-706-5300</phone>
      <facsimile>+1-949-706-5305</facsimile>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@freedesktop.org</email>
      <uri>http://gettys.wordpress.com/</uri>
    </address>
  </author>
  
  <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author initials="L." surname="Masinter" fullname="Larry Masinter">
    <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  
  <author initials="P." surname="Leach" fullname="Paul J. Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>
   
  <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>
      <facsimile>+49 251 2807761</facsimile>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World Wide Web global information
   initiative since 1990. This document is Part 4 of the seven-part specification
   that defines the protocol referred to as "HTTP/1.1" and, taken together,
   obsoletes RFC 2616.  Part 4 defines request header fields for
   indicating conditional requests and the rules for constructing responses
   to those requests.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org). The current issues list is
    at <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/>
    and related documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.10"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   This document defines HTTP/1.1 response metadata for indicating potential
   changes to payload content, including modification time stamps and opaque
   entity-tags, and the HTTP conditional request mechanisms that allow
   preconditions to be placed on a request method.  Conditional GET requests
   allow for efficient cache updates.  Other conditional request methods are
   used to protect against overwriting or misunderstanding the state of a
   resource that has been changed unbeknownst to the requesting client.
</t>
<t>
   This document is currently disorganized in order to minimize the changes
   between drafts and enable reviewers to see the smaller errata changes.
   The next draft will reorganize the sections to better reflect the content.
   In particular, the sections on resource metadata will be discussed first
   and then followed by each conditional request-header, concluding with a
   definition of precedence and the expectation of ordering strong validator
   checks before weak validator checks.  It is likely that more content from
   &caching; will migrate to this part, where appropriate.
   The current mess reflects how widely dispersed these topics and associated
   requirements had become in <xref target="RFC2616"/>.
</t>

<section title="Requirements" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   An implementation is not compliant if it fails to satisfy one or more
   of the "MUST" or "REQUIRED" level requirements for the protocols it
   implements. An implementation that satisfies all the "MUST" or "REQUIRED"
   level and all the "SHOULD" level requirements for its protocols is said
   to be "unconditionally compliant"; one that satisfies all the "MUST"
   level requirements but not all the "SHOULD" level requirements for its
   protocols is said to be "conditionally compliant".
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="WSP"/>
<t>
  This specification uses the ABNF syntax defined in &notation; (which
  extends the syntax defined in <xref target="RFC5234"/> with a list rule).
  <xref target="collected.abnf"/> shows the collected ABNF, with the list
  rule expanded.
</t>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space),
  VCHAR (any visible USASCII character),
  and WSP (whitespace).
</t>

<section title="Core Rules" anchor="core.rules">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="OWS"/>
<t>
  The core rules below are defined in &basic-rules;:
</t>
<figure><artwork type="abnf2616">
  <x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in &basic-rules;&gt;
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &basic-rules;&gt;
</artwork></figure>
</section>

<section title="ABNF Rules defined in other Parts of the Specification" anchor="abnf.dependencies">
  <x:anchor-alias value="HTTP-date"/>
<t>
  The ABNF rules below are defined in other parts: 
</t>
<figure><!--Part1--><artwork type="abnf2616">
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &full-date;&gt;
</artwork></figure>
</section>

</section>

</section>

<section title="Entity-Tags" anchor="entity.tags">
  <x:anchor-alias value="entity-tag"/>
  <x:anchor-alias value="opaque-tag"/>
  <x:anchor-alias value="weak"/>
<t>
   Entity-tags are used for comparing two or more representations from the same
   requested resource. HTTP/1.1 uses entity-tags in the ETag (<xref target="header.etag"/>),
   If-Match (<xref target="header.if-match"/>), If-None-Match (<xref target="header.if-none-match"/>), and
   If-Range (&header-if-range;) header fields. The definition of how they
   are used and compared as cache validators is in <xref target="weak.and.strong.validators"/>. An
   entity-tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="entity-tag"/><iref primary="true" item="Grammar" subitem="weak"/><iref primary="true" item="Grammar" subitem="opaque-tag"/>
  <x:ref>entity-tag</x:ref> = [ <x:ref>weak</x:ref> ] <x:ref>opaque-tag</x:ref>
  <x:ref>weak</x:ref>       = <x:abnf-char-sequence>"W/"</x:abnf-char-sequence> ; "W/", case-sensitive
  <x:ref>opaque-tag</x:ref> = <x:ref>quoted-string</x:ref>
</artwork></figure>
<t>
   A "strong entity-tag" &MAY; be shared by two representations of a resource
   only if they are equivalent by octet equality.
</t>
<t>
   A "weak entity-tag", indicated by the "W/" prefix, &MAY; be shared by
   two representations of a resource only if the representations are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity-tag can only be used for weak comparison.
</t>
<t>
   An entity-tag &MUST; be unique across all versions of all representations
   associated with a particular resource. A given entity-tag value &MAY;
   be used for representations obtained by requests on different URIs. The use
   of the same entity-tag value in conjunction with representations obtained by
   requests on different URIs does not imply the equivalence of those
   representations.
</t>

<section title="Example: Entity-tags varying on Content-Negotiated Resources" anchor="example.entity.tag.vs.conneg">
<t>
   Consider a resource that is subject to content negotiation (&content-negotiation;),
   and where the representations returned upon a GET request vary based on
   the Accept-Encoding request header field (&header-accept-encoding;):
</t>
<figure><preamble>>> Request:</preamble><artwork type="message/http; msgtype=&#34;request&#34;"  x:indent-with="  ">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

</artwork></figure>
<t>
   In this case, the response might or might not use the gzip content coding.
   If it does not, the response might look like:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Thu, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</x:span></artwork></figure>
<t>
   An alternative representation that does use gzip content coding would be:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Thu, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

<spanx>...binary data...</spanx></artwork></figure>
<x:note>
  <t>
    <x:h>Note:</x:h> Content codings are a property of the representation,
    so therefore an entity-tag of an encoded representation must be distinct
    from an unencoded representation to prevent conflicts during cache updates
    and range requests.  In contrast, transfer codings (&transfer-codings;)
    apply only during message transfer and do not require distinct entity-tags.
  </t>
</x:note>
</section>
</section>

<section title="Status Code Definitions" anchor="status.code.definitions">
<section title="304 Not Modified" anchor="status.304">
  <iref primary="true" item="304 Not Modified (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="304 Not Modified" x:for-anchor=""/>
<t>
   If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server &SHOULD;
   respond with this status code. The 304 response &MUST-NOT; contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.
</t>
<t>
   A 304 response &MUST; include a Date header field (&header-date;)
   unless its omission is required by &clockless;.  If a 200 response
   to the same request would have included any of the header fields
   Cache-Control, Content-Location, ETag, Expires, Last-Modified, or
   Vary, then those same header fields &MUST; be sent in a 304 response.
</t>
<t>
   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations,
   the response &SHOULD-NOT; include representation metadata other
   than the above listed fields unless said metadata exists for the
   purpose of guiding cache updates (e.g., future HTTP extensions).
</t>
<t>
   If a 304 response includes an entity-tag that indicates a
   representation not currently cached, then the recipient &MUST-NOT;
   use the 304 to update its own cache.  If that conditional request originated
   with an outbound client, such as a user agent with its own cache sending a
   conditional GET to a shared proxy, then the 304 response &MUST; be
   forwarded to the outbound client.  Otherwise, disregard the response
   and repeat the request without the conditional.
</t>
<t>
   If a cache uses a received 304 response to update a cache entry, the
   cache &MUST; update the entry to reflect any new field values given in
   the response.
</t>
</section>

<section title="412 Precondition Failed" anchor="status.412">
  <iref primary="true" item="412 Precondition Failed (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="412 Precondition Failed" x:for-anchor=""/>
<t>
   The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metadata (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.
</t>
</section>
</section>

<section title="Weak and Strong Validators" anchor="weak.and.strong.validators">
<t>
   Since both origin servers and caches will compare two validators to
   decide if they represent the same or different representations, one normally
   would expect that if the representation (including both representation
   header fields and representation body) changes in any way, then the
   associated validator would change as well. If this is true, then we
   call this validator a "strong validator".
</t>
<t>
   However, there might be cases when a server prefers to change the
   validator only on semantically significant changes, and not when
   insignificant aspects of the representation change. A validator that does not
   always change when the representation changes is a "weak validator".
</t>
<t>
   An entity-tag is normally a strong validator, but the protocol
   provides a mechanism to tag an entity-tag as "weak". One can think of
   a strong validator as one that changes whenever the sequence of bits
   in a representation changes, while a weak value changes whenever the
   meaning of a representation changes. Alternatively, one can think of
   a strong validator as part of an identifier for a specific representation,
   whereas a weak validator is part of an identifier for a set of semantically
   equivalent representations.
  <list><t>
      <x:h>Note:</x:h> One example of a strong validator is an integer that is
      incremented in stable storage every time a representation is changed.
    </t><t>
      A representation's modification time, if defined with only one-second
      resolution, could be a weak validator, since it is possible that
      the representation might be modified twice during a single second.
    </t><t>
      Support for weak validators is optional. However, weak validators
      allow for more efficient caching of equivalent objects; for
      example, a hit counter on a site is probably good enough if it is
      updated every few days or weeks, and any value during that period
      is likely "good enough" to be equivalent.
    </t></list>
</t>
<t>
   A "use" of a validator is either when a client generates a request
   and includes the validator in a validating header field, or when a
   server compares two validators.
</t>
<t>
   Strong validators are usable in any context. Weak validators are only
   usable in contexts that do not depend on exact equality of a representation.
   For example, either kind is usable for a normal conditional GET.
   However, only a strong validator is usable for a sub-range
   retrieval, since otherwise the client might end up with an internally
   inconsistent representation.
</t>
<t>
   Clients &MUST-NOT; use weak validators in range requests (<xref target="Part5"/>). 
</t>
<t>
   The only function that HTTP/1.1 defines on validators is
   comparison. There are two validator comparison functions, depending
   on whether the comparison context allows the use of weak validators
   or not:
  <list style="symbols">
     <t>The strong comparison function: in order to be considered equal,
        both opaque-tags &MUST; be identical character-by-character, and both
        &MUST-NOT; be weak.</t>
     <t>The weak comparison function: in order to be considered equal, both
        opaque-tags &MUST; be identical character-by-character, but
        either or both of them &MAY; be tagged as "weak" without affecting
        the result.</t>
  </list>
</t>
<t>
   The example below shows the results for a set of entity-tag pairs,
   and both the weak and strong comparison function results:
</t>
<texttable align="left">
  <ttcol>ETag 1</ttcol>
  <ttcol>ETag 2</ttcol>
  <ttcol>Strong Comparison</ttcol>
  <ttcol>Weak Comparison</ttcol>

  <c>W/"1"</c>
  <c>W/"1"</c>
  <c>no match</c>
  <c>match</c>
  
  <c>W/"1"</c>
  <c>W/"2"</c>
  <c>no match</c>
  <c>no match</c>

  <c>W/"1"</c>
  <c>"1"</c>
  <c>no match</c>
  <c>match</c>

  <c>"1"</c>
  <c>"1"</c>
  <c>match</c>
  <c>match</c>
</texttable>
<t>
   An entity-tag is strong unless it is explicitly tagged as weak.
   <xref target="entity.tags"/> gives the syntax for entity-tags.
</t>
<t>
   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:
  <list style="symbols">
     <t>The validator is being compared by an origin server to the
        actual current validator for the representation and,</t>
     <t>That origin server reliably knows that the associated representation did
        not change twice during the second covered by the presented
        validator.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is about to be used by a client in an If-Modified-Since
        or If-Unmodified-Since header, because the client
        has a cache entry for the associated representation, and</t>
     <t>That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the representation, and</t>
     <t>That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time. The arbitrary 60-second
   limit guards against the possibility that the Date and Last-Modified
   values are generated from different clocks, or at somewhat
   different times during the preparation of the response. An
   implementation &MAY; use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.
</t>
<t>
   If a client wishes to perform a sub-range retrieval on a value for
   which it has only a Last-Modified time and no opaque validator, it
   &MAY; do this only if the Last-Modified time is strong in the sense
   described here.
</t>
<t>
   A cache or origin server receiving a conditional range request
   (<xref target="Part5"/>) &MUST; use the strong comparison function to
   evaluate the condition.
</t>
<t>
   These rules allow HTTP/1.1 caches and clients to safely perform sub-range
   retrievals on values that have been obtained from HTTP/1.0
   servers.
</t>
</section>

<section title="Rules for When to Use Entity-tags and Last-Modified Dates" anchor="rules.for.when.to.use.entity.tags.and.last-modified.dates">
<t>
   We adopt a set of rules and recommendations for origin servers,
   clients, and caches regarding when various validator types ought to
   be used, and for what purposes.
</t>
<t>
   HTTP/1.1 origin servers:
  <list style="symbols">
     <t>&SHOULD; send an entity-tag validator unless it is not feasible to
        generate one.</t>

     <t>&MAY; send a weak entity-tag instead of a strong entity-tag, if
        performance considerations support the use of weak entity-tags,
        or if it is unfeasible to send a strong entity-tag.</t>

     <t>&SHOULD; send a Last-Modified value if it is feasible to send one,
        unless the risk of a breakdown in semantic transparency that
        could result from using this date in an If-Modified-Since header
        would lead to serious problems.</t>
  </list>
</t>
<t>
   In other words, the preferred behavior for an HTTP/1.1 origin server
   is to send both a strong entity-tag and a Last-Modified value.
</t>
<t>
   In order to be legal, a strong entity-tag &MUST; change whenever the
   associated representation changes in any way. A weak entity-tag &SHOULD;
   change whenever the associated representation changes in a semantically
   significant way.
</t>
<x:note>
  <t>
    <x:h>Note:</x:h> In order to provide semantically transparent caching, an
    origin server must avoid reusing a specific strong entity-tag
    value for two different representations, or reusing a specific weak
    entity-tag value for two semantically different representations. Cache
    entries might persist for arbitrarily long periods, regardless of
    expiration times, so it might be inappropriate to expect that a
    cache will never again attempt to validate an entry using a
    validator that it obtained at some point in the past.
  </t>
</x:note>
<t>
   HTTP/1.1 clients:
  <list style="symbols">
     <t>&MUST; use that entity-tag in any cache-conditional request (using
        If-Match or If-None-Match) if an entity-tag has been provided by the
        origin server.</t>

     <t>&SHOULD; use the Last-Modified value in non-subrange cache-conditional
        requests (using If-Modified-Since) if only a Last-Modified value has
        been provided by the origin server. </t>

     <t>&MAY; use the Last-Modified value in subrange cache-conditional
        requests (using If-Unmodified-Since) if only a Last-Modified value has
        been provided by an HTTP/1.0 origin server. The user agent &SHOULD;
        provide a way to disable this, in case of difficulty.</t>

     <t>&SHOULD; use both validators in cache-conditional requests if both an
        entity-tag and a Last-Modified value have been provided by the origin
        server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond
        appropriately.</t>
  </list>
</t>
<t>
   An HTTP/1.1 origin server, upon receiving a conditional request that
   includes both a Last-Modified date (e.g., in an If-Modified-Since or
   If-Unmodified-Since header field) and one or more entity-tags (e.g.,
   in an If-Match, If-None-Match, or If-Range header field) as cache
   validators, &MUST-NOT; return a response status code of 304 (Not Modified)
   unless doing so is consistent with all of the conditional header
   fields in the request.
</t>
<t>
   An HTTP/1.1 caching proxy, upon receiving a conditional request that
   includes both a Last-Modified date and one or more entity-tags as
   cache validators, &MUST-NOT; return a locally cached response to the
   client unless that cached response is consistent with all of the
   conditional header fields in the request.
  <list><t>
      <x:h>Note:</x:h> The general principle behind these rules is that HTTP/1.1
      servers and clients should transmit as much non-redundant
      information as is available in their responses and requests.
      HTTP/1.1 systems receiving this information will make the most
      conservative assumptions about the validators they receive.
  </t><t>
      HTTP/1.0 clients and caches will ignore entity-tags. Generally,
      last-modified values received or used by these systems will
      support transparent and efficient caching, and so HTTP/1.1 origin
      servers should provide Last-Modified values. In those rare cases
      where the use of a Last-Modified value as a validator by an
      HTTP/1.0 system could result in a serious problem, then HTTP/1.1
      origin servers should not provide one.
  </t></list>
</t>
</section>

<section title="Header Field Definitions" anchor="header.fields">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   related to conditional requests.
</t>
<t>
   For entity-header fields, both sender and recipient refer to either the
   client or the server, depending on who sends and who receives the message.
</t>

<section title="ETag" anchor="header.etag">
  <iref primary="true" item="ETag header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="ETag" x:for-anchor=""/>
  <x:anchor-alias value="ETag"/>
  <x:anchor-alias value="ETag-v"/>
<t>
   The "ETag" response-header field provides the current value of the
   entity-tag (see <xref target="entity.tags"/>) for one representation of
   the resource identified by the Effective Request URI.  An entity-tag
   is intended for use as a resource-local identifier for differentiating
   between representations of the same resource that vary over time or via
   content negotiation (see <xref target="weak.and.strong.validators"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="ETag"/><iref primary="true" item="Grammar" subitem="ETag-v"/>
  <x:ref>ETag</x:ref>   = "ETag" ":" <x:ref>OWS</x:ref> <x:ref>ETag-v</x:ref>
  <x:ref>ETag-v</x:ref> = <x:ref>entity-tag</x:ref>
</artwork></figure>
<figure><preamble>
  Examples:
</preamble>
<artwork type="example">
  ETag: "xyzzy"
  ETag: W/"xyzzy"
  ETag: ""
</artwork></figure>
<t>
   An entity-tag provides an "opaque" cache validator that allows for
   more reliable validation than modification dates in situations where
   it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.
</t>
<t>
   The principle behind entity-tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.
</t>
</section>

<section title="If-Match" anchor="header.if-match">
  <iref primary="true" item="If-Match header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="If-Match" x:for-anchor=""/>
  <x:anchor-alias value="If-Match"/>
  <x:anchor-alias value="If-Match-v"/>
<t>
   The "If-Match" request-header field is used to make a request method
   conditional. A client that has one or more representations previously
   obtained from the resource can verify that one of those representations is
   current by including a list of their associated entity-tags in the
   If-Match header field.
</t>
<t>
   This allows efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used when updating resources, to prevent
   inadvertent modification of the wrong version of a resource. As a special
   case, the value "*" matches any current representation of the resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Match"/><iref primary="true" item="Grammar" subitem="If-Match-v"/>
  <x:ref>If-Match</x:ref>   = "If-Match" ":" <x:ref>OWS</x:ref> <x:ref>If-Match-v</x:ref>
  <x:ref>If-Match-v</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   If any of the entity-tags match the entity-tag of the representation that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if "*" is given
   and any current representation exists for that resource, then the server &MAY;
   perform the requested method as if the If-Match header field did not
   exist.
</t>
<t>
   If none of the entity-tags match, or if "*" is given and no current
   representation exists, the server &MUST-NOT; perform the requested method, and
   &MUST; return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.
</t>
<t>
   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status code, then the If-Match header
   &MUST; be ignored.
</t>
<t>
   The meaning of "If-Match: *" is that the method &SHOULD; be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &header-vary;) exists, and
   &MUST-NOT; be performed if the representation does not exist.
</t>
<t>
   A request intended to update a resource (e.g., a PUT) &MAY; include an
   If-Match header field to signal that the request method &MUST-NOT; be
   applied if the representation corresponding to the If-Match value (a single
   entity-tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:
</t>
<figure><artwork type="example">
  If-Match: "xyzzy"
  If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-Match: *
</artwork></figure>
<t>
   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.
</t>
</section>

<section title="If-Modified-Since" anchor="header.if-modified-since">
  <iref primary="true" item="If-Modified-Since header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="If-Modified-Since" x:for-anchor=""/>
  <x:anchor-alias value="If-Modified-Since"/>
  <x:anchor-alias value="If-Modified-Since-v"/>
<t>
   The "If-Modified-Since" request-header field is used to make a request 
   method conditional by date: if the representation that would have been
   transferred in a 200 response to a GET request has not been modified since
   the time specified in this field, then do not perform the method;
   instead, respond as detailed below.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Modified-Since"/><iref primary="true" item="Grammar" subitem="If-Modified-Since-v"/>
  <x:ref>If-Modified-Since</x:ref>   = "If-Modified-Since" ":" <x:ref>OWS</x:ref>
                        <x:ref>If-Modified-Since-v</x:ref>
  <x:ref>If-Modified-Since-v</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   A GET method with an If-Modified-Since header and no Range header
   requests that the representation be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:
  <list style="numbers">
      <t>If the request would normally result in anything other than a
         200 (OK) status code, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.</t>

      <t>If the representation has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.</t>

      <t>If the representation has not been modified since a valid
         If-Modified-Since date, the server &SHOULD; return a
         304 (Not Modified) response.</t>
  </list>
</t>
<t>
   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.
  <list><t>
      <x:h>Note:</x:h> The Range request-header field modifies the meaning of If-Modified-Since;
      see &header-range; for full details.
    </t><t>
      <x:h>Note:</x:h> If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.
    </t><t>
      <x:h>Note:</x:h> When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-Modified-Since
      header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-Modified
      header field whenever possible.
    </t><t>
      <x:h>Note:</x:h> If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the
      possibility of clock-skew-related problems if the If-Modified-Since
      date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.
    </t>
  </list>
</t>
<t>
   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.
</t>
</section>

<section title="If-None-Match" anchor="header.if-none-match">
  <iref primary="true" item="If-None-Match header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="If-None-Match" x:for-anchor=""/>
  <x:anchor-alias value="If-None-Match"/>
  <x:anchor-alias value="If-None-Match-v"/>
<t>
   The "If-None-Match" request-header field is used to make a request method
   conditional. A client that has one or more representations previously
   obtained from the resource can verify that none of those representations is
   current by including a list of their associated entity-tags in the
   If-None-Match header field.
</t>
<t>
   This allows efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g., PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.
</t>
<t>
   As a special case, the value "*" matches any current representation of the
   resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-None-Match"/><iref primary="true" item="Grammar" subitem="If-None-Match-v"/>
  <x:ref>If-None-Match</x:ref>   = "If-None-Match" ":" <x:ref>OWS</x:ref> <x:ref>If-None-Match-v</x:ref>
  <x:ref>If-None-Match-v</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   If any of the entity-tags match the entity-tag of the representation that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if "*" is
   given and any current representation exists for that resource, then the
   server &MUST-NOT; perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server &SHOULD;
   respond with a 304 (Not Modified) response, including the cache-related
   header fields (particularly ETag) of one of the representations that
   matched. For all other request methods, the server &MUST; respond with
   a 412 (Precondition Failed) status code.
</t>
<t>
   If none of the entity-tags match, then the server &MAY; perform the
   requested method as if the If-None-Match header field did not exist,
   but &MUST; also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity-tags match, then the server &MUST-NOT;
   return a 304 (Not Modified) response.
</t>
<t>
   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status code, then the If-None-Match
   header &MUST; be ignored. (See <xref target="rules.for.when.to.use.entity.tags.and.last-modified.dates"/> for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)
</t>
<t>
   The meaning of "If-None-Match: *" is that the method &MUST-NOT; be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &header-vary;)
   exists, and &SHOULD; be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.
</t>
<t>
   Examples:
</t>
<figure><artwork type="example">
  If-None-Match: "xyzzy"
  If-None-Match: W/"xyzzy"
  If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
  If-None-Match: *
</artwork></figure>
<t>
   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.
</t>
</section>

<section title="If-Unmodified-Since" anchor="header.if-unmodified-since">
  <iref primary="true" item="If-Unmodified-Since header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="If-Unmodified-Since" x:for-anchor=""/>
  <x:anchor-alias value="If-Unmodified-Since"/>
  <x:anchor-alias value="If-Unmodified-Since-v"/>
<t>
   The "If-Unmodified-Since" request-header field is used to make a request
   method conditional.  If the representation that would have been transferred
   in a 200 response to a GET request on the same resource has not been modified
   since the time specified in this field, the server &SHOULD; perform the
   requested operation as if the If-Unmodified-Since header were not
   present.
</t>
<t>
   If the representation has been modified since the specified time,
   the server &MUST-NOT; perform the requested operation, and &MUST; return
   a 412 (Precondition Failed).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Unmodified-Since"/><iref primary="true" item="Grammar" subitem="If-Unmodified-Since-v"/>
  <x:ref>If-Unmodified-Since</x:ref>   = "If-Unmodified-Since" ":" <x:ref>OWS</x:ref>
                          <x:ref>If-Unmodified-Since-v</x:ref>
  <x:ref>If-Unmodified-Since-v</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status code,
   the If-Unmodified-Since header &SHOULD; be ignored.
</t>
<t>
   If the specified date is invalid, the header is ignored.
</t>
<t>
   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.
</t>
</section>

<section title="Last-Modified" anchor="header.last-modified">
  <iref primary="true" item="Last-Modified header" x:for-anchor=""/>
  <iref primary="true" item="Headers" subitem="Last-Modified" x:for-anchor=""/>
  <x:anchor-alias value="Last-Modified"/>
  <x:anchor-alias value="Last-Modified-v"/>
<t>
   The "Last-Modified" entity-header field indicates the date and time at
   which the origin server believes the representation was last modified.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Last-Modified"/><iref primary="true" item="Grammar" subitem="Last-Modified-v"/>
  <x:ref>Last-Modified</x:ref>   = "Last-Modified" ":" <x:ref>OWS</x:ref> <x:ref>Last-Modified-v</x:ref>
  <x:ref>Last-Modified-v</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of its use is
</t>
<figure><artwork type="example">
  Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</artwork></figure>
<t>
   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it might be just the file system last-modified time. For
   representations with dynamically included parts, it might be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it might be the last-update time stamp of the record. For
   virtual objects, it might be the last time the internal state changed.
</t>
<t>
   An origin server &MUST-NOT; send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server &MUST; replace that date with the message
   origination date.
</t>
<t>
   An origin server &SHOULD; obtain the Last-Modified value of the representation
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the representation's modification time, especially if the representation changes
   near the time that the response is generated.
</t>
<t>
   HTTP/1.1 servers &SHOULD; send Last-Modified whenever feasible.
</t>
<t>
   The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the representation has not been modified since the Last-Modified value.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Status Code Registration" anchor="status.code.registration">
<t>
   The HTTP Status Code Registry located at <eref target="http://www.iana.org/assignments/http-status-codes"/>
   should be updated with the registrations below:
</t>
<?BEGININC p4-conditional.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>304</c>
   <c>Not Modified</c>
   <c>
      <xref target="status.304"/>
   </c>
   <c>412</c>
   <c>Precondition Failed</c>
   <c>
      <xref target="status.412"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-status-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   The Message Header Field Registry located at <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/> should be updated
   with the permanent registrations below (see <xref target="RFC3864"/>):
</t>
<?BEGININC p4-conditional.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>ETag</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.etag"/>
   </c>
   <c>If-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-match"/>
   </c>
   <c>If-Modified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-modified-since"/>
   </c>
   <c>If-None-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-none-match"/>
   </c>
   <c>If-Unmodified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-unmodified-since"/>
   </c>
   <c>Last-Modified</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.last-modified"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   No additional security considerations have been identified beyond
   those applicable to HTTP in general &messaging;.
</t>
</section>

<section title="Acknowledgments" anchor="ack">
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="Part1">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
  <x:source href="p1-messaging.xml" basename="p1-messaging"/>
</reference>

<reference anchor="Part3">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 3: Message Payload and Content Negotiation</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p3-payload-&ID-VERSION;"/>
  <x:source href="p3-payload.xml" basename="p3-payload"/>
</reference>

<reference anchor="Part5">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
  <x:source href="p5-range.xml" basename="p5-range"/>
</reference>

<reference anchor="Part6">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 6: Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Day Software">Day Software</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe Systems">Adobe Systems, Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="p6-cache.xml" basename="p6-cache"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

</references>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Allow weak entity-tags in all requests except range requests (Sections
  <xref target="weak.and.strong.validators" format="counter"/> and
  <xref target="header.if-none-match" format="counter"/>).
</t>
</section>

<?BEGININC p4-conditional.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p4-conditional.parsed-abnf">
<x:ref>ETag</x:ref> = "ETag:" OWS ETag-v
<x:ref>ETag-v</x:ref> = entity-tag

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part1], Section 6.1&gt;

<x:ref>If-Match</x:ref> = "If-Match:" OWS If-Match-v
<x:ref>If-Match-v</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Modified-Since</x:ref> = "If-Modified-Since:" OWS If-Modified-Since-v
<x:ref>If-Modified-Since-v</x:ref> = HTTP-date
<x:ref>If-None-Match</x:ref> = "If-None-Match:" OWS If-None-Match-v
<x:ref>If-None-Match-v</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Unmodified-Since</x:ref> = "If-Unmodified-Since:" OWS
 If-Unmodified-Since-v
<x:ref>If-Unmodified-Since-v</x:ref> = HTTP-date

<x:ref>Last-Modified</x:ref> = "Last-Modified:" OWS Last-Modified-v
<x:ref>Last-Modified-v</x:ref> = HTTP-date

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>entity-tag</x:ref> = [ weak ] opaque-tag

<x:ref>opaque-tag</x:ref> = quoted-string

<x:ref>quoted-string</x:ref> = &lt;quoted-string, defined in [Part1], Section 1.2.2&gt;

<x:ref>weak</x:ref> = %x57.2F ; W/
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; ETag defined but not used
; If-Match defined but not used
; If-Modified-Since defined but not used
; If-None-Match defined but not used
; If-Unmodified-Since defined but not used
; Last-Modified defined but not used
</artwork></figure></section>
<?ENDINC p4-conditional.abnf-appendix ?>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Move definitions of 304 and 412 condition codes from Part2.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-01">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-02" anchor="changes.since.02">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/116"/>:
      "Weak ETags on non-GET requests"
    </t>
  </list>
</t>
<t>
  Ongoing work on IANA Message Header Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header registrations for headers defined
      in this document.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-03" anchor="changes.since.03">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/71"/>:
      "Examples for ETag matching"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/124"/>:
      "'entity value' undefined"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/126"/>:
      "bogus 2068 Date header reference"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-04" anchor="changes.since.04">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-05" anchor="changes.since.05">
<t>
  Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-06" anchor="changes.since.06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/153"/>:
      "case-sensitivity of etag weakness indicator"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-07" anchor="changes.since.07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/116"/>:
      "Weak ETags on non-GET requests" (If-Match still was defined to require
      strong matching)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/198"/>:
      "move IANA registrations for optional status codes"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-08" anchor="changes.since.08">
<t>
  No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-09" anchor="changes.since.09">
<t>
  No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/69"/>:
      "Clarify 'Requested Variant'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
  </list>
</t>
</section>

</section>

</back>
</rfc>
