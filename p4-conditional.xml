<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "January">
  <!ENTITY ID-YEAR "2012">
  <!ENTITY architecture               "<xref target='Part1' x:rel='#architecture' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation                   "<xref target='Part1' x:rel='#notation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY notation-abnf              "<xref target='Part1' x:rel='#notation.abnf' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY acks                       "<xref target='Part1' x:rel='#acks' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY basic-rules                "<xref target='Part1' x:rel='#basic.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY field-rules                "<xref target='Part1' x:rel='#field.rules' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date                "<xref target='Part2' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY messaging                  "<xref target='Part1' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY caching                    "<xref target='Part6' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-accept-encoding     "<xref target='Part3' x:rel='#header.accept-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-if-range            "<xref target='Part5' x:rel='#header.if-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-range               "<xref target='Part5' x:rel='#header.range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-vary                "<xref target='Part6' x:rel='#header.vary' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY http-date                  "<xref target='Part2' x:rel='#http.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY transfer-codings           "<xref target='Part1' x:rel='#transfer.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-negotiation        "<xref target='Part3' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2616" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p4-conditional-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="prev" basename="p3-payload"/>
<x:link rel="next" basename="p5-range"/>
<front>

  <title abbrev="HTTP/1.1, Part 4">HTTP/1.1, part 4: Conditional Requests</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J." surname="Gettys" fullname="Jim Gettys">
    <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
    <address>
      <postal>
        <street>21 Oak Knoll Road</street>
        <city>Carlisle</city>
        <region>MA</region>
        <code>01741</code>
        <country>USA</country>
      </postal>
      <email>jg@freedesktop.org</email>
      <uri>http://gettys.wordpress.com/</uri>
    </address>
  </author>
  
  <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
    <organization abbrev="HP">Hewlett-Packard Company</organization>
    <address>
      <postal>
        <street>HP Labs, Large Scale Systems Group</street>
        <street>1501 Page Mill Road, MS 1177</street>
        <city>Palo Alto</city>
        <region>CA</region>
        <code>94304</code>
        <country>USA</country>
      </postal>
      <email>JeffMogul@acm.org</email>
    </address>
  </author>

  <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
        <country>USA</country>
      </postal>
      <email>henrikn@microsoft.com</email>
    </address>
  </author>

  <author initials="L." surname="Masinter" fullname="Larry Masinter">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  
  <author initials="P." surname="Leach" fullname="Paul J. Leach">
    <organization abbrev="Microsoft">Microsoft Corporation</organization>
    <address>
      <postal>
        <street>1 Microsoft Way</street>
        <city>Redmond</city>
        <region>WA</region>
        <code>98052</code>
      </postal>
      <email>paulle@microsoft.com</email>
    </address>
  </author>
   
  <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>MIT Computer Science and Artificial Intelligence Laboratory</street>
        <street>The Stata Center, Building 32</street>
        <street>32 Vassar Street</street>
        <city>Cambridge</city>
        <region>MA</region>
        <code>02139</code>
        <country>USA</country>
      </postal>
      <email>timbl@w3.org</email>
      <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>
      <facsimile>+49 251 2807761</facsimile>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. HTTP has been in
   use by the World Wide Web global information initiative since 1990. This
   document is Part 4 of the seven-part specification that defines the protocol
   referred to as "HTTP/1.1" and, taken together, obsoletes RFC 2616.
</t>
<t>
   Part 4 defines request header fields for indicating conditional requests and
   the rules for constructing responses to those requests.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft should take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.18"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   This document defines the HTTP/1.1 conditional request mechanisms,
   including both metadata for indicating/observing changes in resource
   representations and request header fields that specify preconditions
   on that metadata be checked before performing the request method.
   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates &caching;.  Conditionals can also be
   applied to state-changing methods, such as PUT and DELETE, to prevent
   the "lost update" problem: one client accidentally overwriting
   the work of another client that has been acting in parallel.
</t>
<t>
   Conditional request preconditions are based on the state of the target
   resource as a whole (its current value set) or the state as observed
   in a previously obtained representation (one value in that set).
   A resource might have multiple current representations, each with its
   own observable state.  The conditional request mechanisms assume that
   the mapping of requests to corresponding representations will be
   consistent over time if the server intends to take advantage of
   conditionals.  Regardless, if the mapping is inconsistent and
   the server is unable to select the appropriate representation, then
   no harm will result when the precondition evaluates to false.
</t>
<t><iref primary="true" item="selected representation"/>
   We use the term "<x:dfn>selected representation</x:dfn>" to refer to
   the current representation of the target resource that would have been
   selected in a successful response if the same request had used the method
   GET and had excluded all of the conditional request header fields.
   The conditional request preconditions are evaluated by comparing the
   values provided in the request header fields to the current metadata
   for the selected representation.
</t>

<section title="Conformance and Error Handling" anchor="intro.conformance.and.error.handling">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   This document defines conformance criteria for several roles in HTTP
   communication, including Senders, Recipients, Clients, Servers, User-Agents,
   Origin Servers, Intermediaries, Proxies and Gateways. See &architecture;
   for definitions of these terms.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with its role(s). Note that SHOULD-level requirements
   are relevant here, unless one of the documented exceptions is applicable.
</t>
<t>
   This document also uses ABNF to define valid protocol elements
   (<xref target="notation"/>). In addition to the prose requirements placed
   upon them, Senders &MUST-NOT; generate protocol elements that are invalid.
</t>
<t>
   Unless noted otherwise, Recipients &MAY; take steps to recover a usable
   protocol element from an invalid construct. However, HTTP does not define
   specific error handling mechanisms, except in cases where it has direct
   impact on security. This is because different uses of the protocol require
   different error handling strategies; for example, a Web browser may wish to
   transparently recover from a response where the Location header field
   doesn't parse according to the ABNF, whereby in a systems control protocol
   using HTTP, this type of error recovery could lead to dangerous consequences.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="VCHAR"/>
  <x:anchor-alias value="core.rules"/>
  <x:anchor-alias value="obs-text"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="HTTP-date"/>
<t>
  This specification uses the ABNF syntax defined in &notation; (which
  extends the syntax defined in <xref target="RFC5234"/> with a list rule).
  <xref target="collected.abnf"/> shows the collected ABNF, with the list
  rule expanded.
</t>
<t>
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>
<t>
  The ABNF rules below are defined in <xref target="Part1"/> and
  <xref target="Part2"/>:
</t>
<figure><artwork type="abnf2616">
  <x:ref>OWS</x:ref>           = &lt;OWS, defined in &basic-rules;&gt;
  <x:ref>obs-text</x:ref>      = &lt;obs-text, defined in &field-rules;&gt;
  <x:ref>HTTP-date</x:ref>     = &lt;HTTP-date, defined in &http-date;&gt;
</artwork></figure>
</section>
</section>

<section title="Validators" anchor="validators">
   <iref primary="true" item="metadata"/>
   <iref primary="true" item="validator"/>
<t>
   This specification defines two forms of metadata that are commonly used
   to observe resource state and test for preconditions: modification dates
   and opaque entity tags.  Additional metadata that reflects resource state
   has been defined by various extensions of HTTP, such as WebDAV
   <xref target="RFC4918"/>, that are beyond the scope of this specification.
   A resource metadata value is referred to as a "<x:dfn>validator</x:dfn>"
   when it is used within a precondition.
</t>

<section title="Weak versus Strong" anchor="weak.and.strong.validators">
   <iref primary="true" item="validator" subitem="weak"/>
   <iref primary="true" item="validator" subitem="strong"/>
<t>
   Validators come in two flavors: strong or weak.  Weak validators are easy
   to generate but are far less useful for comparisons.  Strong validators
   are ideal for comparisons but can be very difficult (and occasionally
   impossible) to generate efficiently.  Rather than impose that all forms
   of resource adhere to the same strength of validator, HTTP exposes the
   type of validator in use and imposes restrictions on when weak validators
   can be used as preconditions.
</t>
<t>
   A "strong validator" is a representation metadata value that &MUST; be
   changed to a new, previously unused or guaranteed unique, value whenever
   a change occurs to the representation data such that a change would be
   observable in the payload body of a 200 response to GET.  A strong
   validator &MAY; be changed for other reasons, such as when a semantically
   significant part of the representation metadata is changed (e.g.,
   Content-Type), but it is in the best interests of the origin server to only
   change the value when it is necessary to invalidate the stored responses
   held by remote caches and authoring tools.  A strong validator &MUST; be
   unique across all representations of a given resource, such that no two
   representations of that resource share the same validator unless
   their payload body would be identical.
</t>
<t>
   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.
   A strong validator &MUST; be unique across all versions of all
   representations associated with a particular resource over time.
   However, there is no implication of uniqueness across representations
   of different resources (i.e., the same strong validator might be
   in use for representations of multiple resources at the same time
   and does not imply that those representations are equivalent).
</t>
<t>
   There are a variety of strong validators used in practice.  The best are
   based on strict revision control, wherein each change to a representation
   always results in a unique node name and revision identifier being assigned
   before the representation is made accessible to GET.  A cryptographic hash
   function applied to the representation data is also sufficient if the data
   is available prior to the response header fields being sent and the digest
   does not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that differ
   only in their metadata, such as might occur with content negotiation over
   media types that happen to share the same data format, then a server
   &SHOULD; incorporate additional information in the validator to
   distinguish those representations and avoid confusing cache behavior.
</t>
<t>
   In contrast, a "weak validator" is a representation metadata value that
   might not be changed for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated, such
   as clock resolution or an inability to ensure uniqueness for all possible
   representations of the resource, or due to a desire by the resource owner
   to group representations by some self-determined set of equivalency
   rather than unique sequences of data.  A weak entity-tag &SHOULD; change
   whenever the origin server considers prior representations to be
   unacceptable as a substitute for the current representation. In other
   words, a weak entity-tag &SHOULD; change whenever the origin server wants
   caches to invalidate old responses.
</t>
<t>
   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second and
   retrieved between those modifications.
</t>
<t>
   A "use" of a validator occurs when either a client generates a request
   and includes the validator in a precondition or when a server
   compares two validators.
   Weak validators are only usable in contexts that do not depend on exact
   equality of a representation's payload body.
   Strong validators are usable and preferred for all conditional requests,
   including cache validation, partial content ranges, and "lost update"
   avoidance.
</t>
</section>

<section title="Last-Modified" anchor="header.last-modified">
  <iref primary="true" item="Last-Modified header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Last-Modified" x:for-anchor=""/>
  <x:anchor-alias value="Last-Modified"/>
<t>
   The "Last-Modified" header field indicates the date and time at
   which the origin server believes the selected representation was
   last modified.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Last-Modified"/>
  <x:ref>Last-Modified</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of its use is
</t>
<figure><artwork type="example">
  Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</artwork></figure>

<section title="Generation" anchor="lastmod.generation">
<t>
   Origin servers &SHOULD; send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness (&caching;) results in a substantial
   reduction of HTTP traffic on the Internet and can be a significant
   factor in improving service scalability and reliability.
</t>
<t>
   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be
   the most recent time that any of those parts were changed.
   How that value is determined for any given resource is an
   implementation detail beyond the scope of this specification.
   What matters to HTTP is how recipients of the Last-Modified
   header field can use its value to make conditional requests
   and test the validity of locally cached responses.
</t>
<t>
   An origin server &SHOULD; obtain the Last-Modified value of the
   representation as close as possible to the time that it generates
   the Date field-value for its response. This allows a recipient to
   make an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.
</t>
<t>
   An origin server with a clock &MUST-NOT; send a Last-Modified date
   that is later than the server's time of message origination (Date).
   If the last modification time is derived from implementation-specific
   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server &MUST; replace that
   value with the message origination date. This prevents a future
   modification date from having an adverse impact on cache validation.
</t>
<t>
   An origin server without a clock &MUST-NOT; assign Last-Modified
   values to a response unless these values were associated
   with the resource by some other system or user with a reliable clock.
</t>
</section>

<section title="Comparison" anchor="lastmod.comparison">
<t>
   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:
  <list style="symbols">
     <t>The validator is being compared by an origin server to the
        actual current validator for the representation and,</t>
     <t>That origin server reliably knows that the associated representation did
        not change twice during the second covered by the presented
        validator.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is about to be used by a client in an If-Modified-Since,
        If-Unmodified-Since header field, because the client has a cache entry,
        or If-Range for the associated representation, and</t>
     <t>That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   or
  <list style="symbols">
     <t>The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the representation, and</t>
     <t>That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and</t>
     <t>The presented Last-Modified time is at least 60 seconds before
        the Date value.</t>
  </list>
</t>
<t>
   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time. The arbitrary 60-second
   limit guards against the possibility that the Date and Last-Modified
   values are generated from different clocks, or at somewhat
   different times during the preparation of the response. An
   implementation &MAY; use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.
</t>
</section>
</section>

<section title="ETag" anchor="header.etag">
  <iref primary="true" item="ETag header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="ETag" x:for-anchor=""/>
  <x:anchor-alias value="ETag"/>
  <x:anchor-alias value="entity-tag"/>
  <x:anchor-alias value="entity.tags"/>
  <x:anchor-alias value="opaque-tag"/>
  <x:anchor-alias value="weak"/>
  <x:anchor-alias value="etagc"/>
<t>
   The ETag header field provides the current entity-tag for the
   selected representation.
   An entity-tag is an opaque validator for differentiating between
   multiple representations of the same resource, regardless of whether
   those multiple representations are due to resource state changes over
   time, content negotiation resulting in multiple representations being
   valid at the same time, or both. An entity-tag consists of an opaque
   quoted string, possibly prefixed by a weakness indicator.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="ETag"/><iref primary="true" item="Grammar" subitem="entity-tag"/><iref primary="true" item="Grammar" subitem="weak"/><iref primary="true" item="Grammar" subitem="opaque-tag"/><iref primary="true" item="Grammar" subitem="etagc"/>
  <x:ref>ETag</x:ref>       = <x:ref>entity-tag</x:ref>

  <x:ref>entity-tag</x:ref> = [ <x:ref>weak</x:ref> ] <x:ref>opaque-tag</x:ref>
  <x:ref>weak</x:ref>       = <x:abnf-char-sequence>"W/"</x:abnf-char-sequence> ; "W/", case-sensitive
  <x:ref>opaque-tag</x:ref> = <x:ref>DQUOTE</x:ref> *<x:ref>etagc</x:ref> <x:ref>DQUOTE</x:ref>
  <x:ref>etagc</x:ref>      = %x21 / %x23-7E / <x:ref>obs-text</x:ref>
             ; <x:ref>VCHAR</x:ref> except double quotes, plus obs-text
</artwork></figure>
<x:note>
  <t>
    <x:h>Note:</x:h> Previously, opaque-tag was defined to be a quoted-string
    (<xref target="RFC2616" x:fmt="," x:sec="3.11"/>), thus some recipients
    might perform backslash unescaping. Servers therefore ought to avoid
    backslash characters in entity tags.
  </t>
</x:note>
<t>
   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently maintained.
</t>
<figure><preamble>
  Examples:
</preamble>
<artwork type="example">
  ETag: "xyzzy"
  ETag: W/"xyzzy"
  ETag: ""
</artwork></figure>
<t>
   An entity-tag can be either a weak or strong validator, with
   strong being the default.  If an origin server provides an entity-tag
   for a representation and the generation of that entity-tag does not satisfy
   the requirements for a strong validator
   (<xref target="weak.and.strong.validators"/>), then that
   entity-tag &MUST; be marked as weak by prefixing its opaque value
   with "W/" (case-sensitive).
</t>

<section title="Generation" anchor="entity.tag.generation">
<t>
   The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the
   most accurate and efficient validation mechanism for that resource,
   and that any such mechanism can be mapped to a simple sequence of
   octets for easy comparison.  Since the value is opaque, there is no
   need for the client to be aware of how each entity-tag is constructed.
</t>
<t>
   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.
   Other implementations might use a stored hash of representation content,
   a combination of various filesystem attributes, or a modification
   timestamp that has sub-second resolution.
</t>
<t>
   Origin servers &SHOULD; send ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness (&caching;) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.
</t>
</section>

<section title="Comparison" anchor="entity.tag.comparison">
  <x:anchor-alias value="validator.comparison"/>
<t>
   There are two entity-tag comparison functions, depending
   on whether the comparison context allows the use of weak validators
   or not:
  <list style="symbols">
     <t>The strong comparison function: in order to be considered equal,
        both opaque-tags &MUST; be identical character-by-character, and both
        &MUST-NOT; be weak.</t>
     <t>The weak comparison function: in order to be considered equal, both
        opaque-tags &MUST; be identical character-by-character, but
        either or both of them &MAY; be tagged as "weak" without affecting
        the result.</t>
  </list>
</t>
<t>
   The example below shows the results for a set of entity-tag pairs,
   and both the weak and strong comparison function results:
</t>
<texttable align="left">
  <ttcol>ETag 1</ttcol>
  <ttcol>ETag 2</ttcol>
  <ttcol>Strong Comparison</ttcol>
  <ttcol>Weak Comparison</ttcol>

  <c>W/"1"</c>
  <c>W/"1"</c>
  <c>no match</c>
  <c>match</c>
  
  <c>W/"1"</c>
  <c>W/"2"</c>
  <c>no match</c>
  <c>no match</c>

  <c>W/"1"</c>
  <c>"1"</c>
  <c>no match</c>
  <c>match</c>

  <c>"1"</c>
  <c>"1"</c>
  <c>match</c>
  <c>match</c>
</texttable>
</section>

<section title="Example: Entity-tags varying on Content-Negotiated Resources" anchor="example.entity.tag.vs.conneg">
<t>
   Consider a resource that is subject to content negotiation (&content-negotiation;),
   and where the representations returned upon a GET request vary based on
   the Accept-Encoding request header field (&header-accept-encoding;):
</t>
<figure><preamble>>> Request:</preamble><artwork type="message/http; msgtype=&#34;request&#34;"  x:indent-with="  ">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

</artwork></figure>
<t>
   In this case, the response might or might not use the gzip content coding.
   If it does not, the response might look like:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Thu, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</x:span></artwork></figure>
<t>
   An alternative representation that does use gzip content coding would be:
</t>
<figure><preamble>>> Response:</preamble><artwork type="message/http; msgtype=&#34;response&#34;"  x:indent-with="  ">
HTTP/1.1 200 OK
Date: Thu, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

<spanx>...binary data...</spanx></artwork></figure>
<x:note>
  <t>
    <x:h>Note:</x:h> Content codings are a property of the representation,
    so therefore an entity-tag of an encoded representation must be distinct
    from an unencoded representation to prevent conflicts during cache updates
    and range requests.  In contrast, transfer codings (&transfer-codings;)
    apply only during message transfer and do not require distinct entity-tags.
  </t>
</x:note>
</section>
</section>

<section title="Rules for When to Use Entity-tags and Last-Modified Dates" anchor="rules.for.when.to.use.entity.tags.and.last-modified.dates">
<t>
   We adopt a set of rules and recommendations for origin servers,
   clients, and caches regarding when various validator types ought to
   be used, and for what purposes.
</t>
<t>
   HTTP/1.1 origin servers:
  <list style="symbols">
     <t>&SHOULD; send an entity-tag validator unless it is not feasible to
        generate one.</t>

     <t>&MAY; send a weak entity-tag instead of a strong entity-tag, if
        performance considerations support the use of weak entity-tags,
        or if it is unfeasible to send a strong entity-tag.</t>

     <t>&SHOULD; send a Last-Modified value if it is feasible to send one.</t>
  </list>
</t>
<t>
   In other words, the preferred behavior for an HTTP/1.1 origin server
   is to send both a strong entity-tag and a Last-Modified value.
</t>
<t>
   HTTP/1.1 clients:
  <list style="symbols">
     <t>&MUST; use that entity-tag in any cache-conditional request (using
        If-Match or If-None-Match) if an entity-tag has been provided by the
        origin server.</t>

     <t>&SHOULD; use the Last-Modified value in non-subrange cache-conditional
        requests (using If-Modified-Since) if only a Last-Modified value has
        been provided by the origin server. </t>

     <t>&MAY; use the Last-Modified value in subrange cache-conditional
        requests (using If-Unmodified-Since) if only a Last-Modified value has
        been provided by an HTTP/1.0 origin server. The user agent &SHOULD;
        provide a way to disable this, in case of difficulty.</t>

     <t>&SHOULD; use both validators in cache-conditional requests if both an
        entity-tag and a Last-Modified value have been provided by the origin
        server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond
        appropriately.</t>
  </list>
</t>
<t>
   An HTTP/1.1 origin server, upon receiving a conditional request that
   includes both a Last-Modified date (e.g., in an If-Modified-Since or
   If-Unmodified-Since header field) and one or more entity-tags (e.g.,
   in an If-Match, If-None-Match, or If-Range header field) as cache
   validators, &MUST-NOT; return a response status code of 304 (Not Modified)
   unless doing so is consistent with all of the conditional header
   fields in the request.
</t>
<t>
   An HTTP/1.1 caching proxy, upon receiving a conditional request that
   includes both a Last-Modified date and one or more entity-tags as
   cache validators, &MUST-NOT; return a locally cached response to the
   client unless that cached response is consistent with all of the
   conditional header fields in the request.
  <list><t>
      <x:h>Note:</x:h> The general principle behind these rules is that HTTP/1.1
      servers and clients ought to transmit as much non-redundant
      information as is available in their responses and requests.
      HTTP/1.1 systems receiving this information will make the most
      conservative assumptions about the validators they receive.
  </t><t>
      HTTP/1.0 clients and caches might ignore entity-tags. Generally,
      last-modified values received or used by these systems will
      support transparent and efficient caching, and so HTTP/1.1 origin
      servers should provide Last-Modified values. In those rare cases
      where the use of a Last-Modified value as a validator by an
      HTTP/1.0 system could result in a serious problem, then HTTP/1.1
      origin servers should not provide one.
  </t></list>
</t>
</section>
</section>

<section title="Precondition Header Fields" anchor="header.field.definitions">
<t>
   This section defines the syntax and semantics of HTTP/1.1 header fields
   for applying preconditions on requests.
</t>

<section title="If-Match" anchor="header.if-match">
  <iref primary="true" item="If-Match header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="If-Match" x:for-anchor=""/>
  <x:anchor-alias value="If-Match"/>
<t>
   The "If-Match" header field &MAY; be used to make a request method
   conditional on the current existence or value of an entity-tag for
   one or more representations of the target resource.  If-Match is
   generally useful for resource update requests, such as PUT requests,
   as a means for protecting against accidental overwrites when multiple
   clients are acting in parallel on the same resource (i.e., the
   "lost update" problem).  An If-Match field-value of "*" places the
   precondition on the existence of any current representation for the
   target resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Match"/>
  <x:ref>If-Match</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   If any of the entity-tags listed in the If-Match field value match
   (as per <xref target="entity.tag.comparison"/>) the entity-tag of the 
   selected representation for the target resource,
   or if "*" is given and any current representation exists for the
   target resource, then the server &MAY; perform the request method
   as if the If-Match header field was not present.
</t>
<t>
   If none of the entity-tags match, or if "*" is given and no current
   representation exists, the server &MUST-NOT; perform the requested method.
   Instead, the server &MUST; respond with the 412 (Precondition Failed)
   status code.
</t>
<t>
   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status code, then the If-Match header field
   &MUST; be ignored.
</t>
<t>
   Examples:
</t>
<figure><artwork type="example">
  If-Match: "xyzzy"
  If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-Match: *
</artwork></figure>
<t>
   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header field is
   undefined by this specification.
</t>
</section>

<section title="If-None-Match" anchor="header.if-none-match">
  <iref primary="true" item="If-None-Match header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="If-None-Match" x:for-anchor=""/>
  <x:anchor-alias value="If-None-Match"/>
<t>
   The "If-None-Match" header field &MAY; be used to make a request method
   conditional on not matching any of the current entity-tag values for
   representations of the target resource.  If-None-Match is primarily
   used in conditional GET requests to enable efficient updates of cached
   information with a minimum amount of transaction overhead.  A client
   that has one or more representations previously obtained from the
   target resource can send If-None-Match with a list of the associated
   entity-tags in the hope of receiving a 304 response if at least one
   of those representations matches the selected representation.
</t>
<t>
   If-None-Match MAY also be used with a value of "*" to prevent an unsafe
   request method (e.g., PUT) from inadvertently modifying an existing
   representation of the target resource when the client believes that
   the resource does not have a current representation.  This is a variation
   on the "lost update" problem that might arise if more than one client
   attempts to create an initial representation for the target resource.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-None-Match"/>
  <x:ref>If-None-Match</x:ref> = "*" / 1#<x:ref>entity-tag</x:ref>
</artwork></figure>
<t>
   If any of the entity-tags listed in the If-None-Match field-value match
   (as per <xref target="entity.tag.comparison"/>) the entity-tag of the 
   selected representation, or if "*" is
   given and any current representation exists for that resource, then the
   server &MUST-NOT; perform the requested method.
   Instead, if the request method was GET or HEAD, the server &SHOULD;
   respond with a 304 (Not Modified) status code, including the cache-related
   header fields (particularly ETag) of the selected representation that has
   a matching entity-tag.  For all other request methods, the server &MUST;
   respond with a 412 (Precondition Failed) status code.
</t>
<t>
   If none of the entity-tags match, then the server &MAY; perform the
   requested method as if the If-None-Match header field did not exist,
   but &MUST; also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity-tags match, then the server &MUST-NOT;
   return a 304 (Not Modified) response.
</t>
<t>
   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status code, then the If-None-Match
   header field &MUST; be ignored. (See <xref
   target="rules.for.when.to.use.entity.tags.and.last-modified.dates"/> for
   a discussion of server behavior when both If-Modified-Since and
   If-None-Match appear in the same request.)
</t>
<t>
   Examples:
</t>
<figure><artwork type="example">
  If-None-Match: "xyzzy"
  If-None-Match: W/"xyzzy"
  If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
  If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
  If-None-Match: *
</artwork></figure>
<t>
   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header field is
   undefined by this specification.
</t>
</section>

<section title="If-Modified-Since" anchor="header.if-modified-since">
  <iref primary="true" item="If-Modified-Since header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="If-Modified-Since" x:for-anchor=""/>
  <x:anchor-alias value="If-Modified-Since"/>
<t>
   The "If-Modified-Since" header field &MAY; be used to make a request 
   method conditional by modification date: if the selected representation
   has not been modified since the time specified in this field, then
   do not perform the request method; instead, respond as detailed below.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Modified-Since"/>
  <x:ref>If-Modified-Since</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   A GET method with an If-Modified-Since header field and no Range header
   field requests that the selected representation be transferred only if
   it has been modified since the date given by the If-Modified-Since
   header field.
   The algorithm for determining this includes the following cases:
  <list style="numbers">
      <t>If the request would normally result in anything other than a
         200 (OK) status code, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.</t>

      <t>If the selected representation has been modified since the
         If-Modified-Since date, the response is exactly the same as for
         a normal GET.</t>

      <t>If the selected representation has not been modified since a valid
         If-Modified-Since date, the server &SHOULD; return a
         304 (Not Modified) response.</t>
  </list>
</t>
<t>
   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.
  <list><t>
      <x:h>Note:</x:h> The Range header field modifies the meaning of If-Modified-Since;
      see &header-range; for full details.
    </t><t>
      <x:h>Note:</x:h> If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.
    </t><t>
      <x:h>Note:</x:h> When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-Modified-Since
      header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-Modified
      header field whenever possible.
    </t><t>
      <x:h>Note:</x:h> If a client uses an arbitrary date in the If-Modified-Since
      header field instead of a date taken from the Last-Modified header field for
      the same request, the client needs to be aware that this
      date is interpreted in the server's understanding of time.
      Unsynchronized clocks and rounding problems, due to the different
      encodings of time between the client and server, are concerns.
      This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the
      possibility of clock-skew-related problems if the If-Modified-Since
      date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.
    </t>
  </list>
</t>
<t>
   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header field is
   undefined by this specification.
</t>
</section>

<section title="If-Unmodified-Since" anchor="header.if-unmodified-since">
  <iref primary="true" item="If-Unmodified-Since header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="If-Unmodified-Since" x:for-anchor=""/>
  <x:anchor-alias value="If-Unmodified-Since"/>
<t>
   The "If-Unmodified-Since" header field &MAY; be used to make a request
   method conditional by modification date: if the selected representation
   has been modified since the time specified in this field, then the
   server &MUST-NOT; perform the requested operation and &MUST; instead
   respond with the 412 (Precondition Failed) status code.
   If the selected representation has not been modified since the time
   specified in this field, the server &SHOULD; perform the request
   method as if the If-Unmodified-Since header field were not present.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="If-Unmodified-Since"/>
  <x:ref>If-Unmodified-Since</x:ref> = <x:ref>HTTP-date</x:ref>
</artwork></figure>
<t>
   An example of the field is:
</t>
<figure><artwork type="example">
  If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</artwork></figure>
<t>
   If the request normally (i.e., without the If-Unmodified-Since
   header field) would result in anything other than a 2xx or 412 status code,
   the If-Unmodified-Since header field &SHOULD; be ignored.
</t>
<t>
   If the specified date is invalid, the header field &MUST; be ignored.
</t>
<t>
   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   field is undefined by this specification.
</t>
</section>

<section title="If-Range" anchor="header.if-range">
<t>
   The If-Range header field provides a special conditional request
   mechanism that is similar to If-Match and If-Unmodified-Since but
   specific to HTTP range requests. If-Range is defined in &header-if-range;.
</t>
</section>

</section>

<section title="Status Code Definitions" anchor="status.code.definitions">
<section title="304 Not Modified" anchor="status.304">
  <iref primary="true" item="304 Not Modified (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="304 Not Modified" x:for-anchor=""/>
<t>
   The 304 status code indicates that a conditional GET request has been
   received and would have resulted in a 200 (OK) response if it were not
   for the fact that the condition has evaluated to false.  In other words,
   there is no need for the server to transfer a representation of the
   target resource because the client's request indicates that it already
   has a valid representation, as indicated by the 304 response header
   fields, and is therefore redirecting the client to make use of that
   stored representation as if it were the payload of a 200 response.
   The 304 response &MUST-NOT; contain a message-body, and thus is always
   terminated by the first empty line after the header fields.
</t>
<t>
   A 304 response &MUST; include a Date header field (&header-date;)
   unless the origin server does not have a clock that can provide a
   reasonable approximation of the current time.  If a 200 response
   to the same request would have included any of the header fields
   Cache-Control, Content-Location, ETag, Expires, Last-Modified, or
   Vary, then those same header fields &MUST; be sent in a 304 response.
</t>
<t>
   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations,
   the response &SHOULD-NOT; include representation metadata other
   than the above listed fields unless said metadata exists for the
   purpose of guiding cache updates (e.g., future HTTP extensions).
</t>
<t>
   If the recipient of a 304 response does not have a cached representation
   corresponding to the entity-tag indicated by the 304 response, then the
   recipient &MUST-NOT; use the 304 to update its own cache.  If this
   conditional request originated with an outbound client, such as a
   user agent with its own cache sending a conditional GET to a shared
   proxy, then the 304 response &MAY; be forwarded to the outbound client.
   Otherwise, the recipient &MUST; disregard the 304 response and repeat
   the request without any preconditions.
</t>
<t>
   If a cache uses a received 304 response to update a cache entry, the
   cache &MUST; update the entry to reflect any new field values given in
   the response.
</t>
</section>

<section title="412 Precondition Failed" anchor="status.412">
  <iref primary="true" item="412 Precondition Failed (status code)" x:for-anchor=""/>
  <iref primary="true" item="Status Codes" subitem="412 Precondition Failed" x:for-anchor=""/>
<t>
   The 412 status code indicates that one or more preconditions given in
   the request header fields evaluated to false when tested on the server.
   This response code allows the client to place preconditions on the
   current resource state (its current representations and metadata)
   and thus prevent the request method from being applied if the target
   resource is in an unexpected state.
</t>
</section>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Status Code Registration" anchor="status.code.registration">
<t>
   The HTTP Status Code Registry located at <eref target="http://www.iana.org/assignments/http-status-codes"/>
   shall be updated with the registrations below:
</t>
<?BEGININC p4-conditional.iana-status-codes ?>
<!--AUTOGENERATED FROM extract-status-code-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.status.code.registration.table">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>304</c>
   <c>Not Modified</c>
   <c>
      <xref target="status.304"/>
   </c>
   <c>412</c>
   <c>Precondition Failed</c>
   <c>
      <xref target="status.412"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-status-codes ?>
</section>

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   The Message Header Field Registry located at <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/> shall be updated
   with the permanent registrations below (see <xref target="RFC3864"/>):
</t>
<?BEGININC p4-conditional.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>ETag</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.etag"/>
   </c>
   <c>If-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-match"/>
   </c>
   <c>If-Modified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-modified-since"/>
   </c>
   <c>If-None-Match</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-none-match"/>
   </c>
   <c>If-Unmodified-Since</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.if-unmodified-since"/>
   </c>
   <c>Last-Modified</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.last-modified"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p4-conditional.iana-headers ?>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   No additional security considerations have been identified beyond
   those applicable to HTTP in general &messaging;.
</t>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
  See &acks;.
</t>
</section>
</middle>
<back>

<references title="Normative References">

<reference anchor="Part1">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"/>
  <x:source href="p1-messaging.xml" basename="p1-messaging"/>
</reference>

<reference anchor="Part2">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 2: Message Semantics</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="p2-semantics.xml" basename="p2-semantics"/>
</reference>

<reference anchor="Part3">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 3: Message Payload and Content Negotiation</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p3-payload-&ID-VERSION;"/>
  <x:source href="p3-payload.xml" basename="p3-payload"/>
</reference>

<reference anchor="Part5">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 5: Range Requests and Partial Responses</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
  <x:source href="p5-range.xml" basename="p5-range"/>
</reference>

<reference anchor="Part6">
  <front>
    <title abbrev="HTTP/1.1">HTTP/1.1, part 6: Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization abbrev="Alcatel-Lucent">Alcatel-Lucent Bell Labs</organization>
      <address><email>jg@freedesktop.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization abbrev="HP">Hewlett-Packard Company</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>henrikn@microsoft.com</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="Larry Masinter">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>LMM@acm.org</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Rackspace</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="p6-cache.xml" basename="p6-cache"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor='RFC4918'>
  <front>
    <title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title>
    <author initials="L.M." surname="Dusseault" fullname="Lisa Dusseault" role="editor" >
      <organization abbrev="CommerceNet">CommerceNet</organization>
      <address><email>ldusseault@commerce.net</email></address>
    </author>
    <date month="June" year="2007" />
  </front>
  <seriesInfo name='RFC' value='4918' />
</reference>
</references>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Allow weak entity-tags in all requests except range requests (Sections
  <xref target="weak.and.strong.validators" format="counter"/> and
  <xref target="header.if-none-match" format="counter"/>).
</t>
<t>
  Change ETag header field ABNF not to use quoted-string, thus avoiding
  escaping issues.
  (<xref target="header.etag"/>)
</t>
<t>
  Change ABNF productions for header fields to only define the field value.
  (<xref target="header.field.definitions"/>)
</t>
</section>

<?BEGININC p4-conditional.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p4-conditional.parsed-abnf">
<x:ref>ETag</x:ref> = entity-tag

<x:ref>HTTP-date</x:ref> = &lt;HTTP-date, defined in [Part2], Section 8&gt;

<x:ref>If-Match</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Modified-Since</x:ref> = HTTP-date
<x:ref>If-None-Match</x:ref> = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
 entity-tag ] ) )
<x:ref>If-Unmodified-Since</x:ref> = HTTP-date

<x:ref>Last-Modified</x:ref> = HTTP-date

<x:ref>OWS</x:ref> = &lt;OWS, defined in [Part1], Section 1.2.2&gt;

<x:ref>entity-tag</x:ref> = [ weak ] opaque-tag
<x:ref>etagc</x:ref> = "!" / %x23-7E ; '#'-'~'
 / obs-text

<x:ref>obs-text</x:ref> = &lt;obs-text, defined in [Part1], Section 3.2.3&gt;
<x:ref>opaque-tag</x:ref> = DQUOTE *etagc DQUOTE

<x:ref>weak</x:ref> = %x57.2F ; W/
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; ETag defined but not used
; If-Match defined but not used
; If-Modified-Since defined but not used
; If-None-Match defined but not used
; If-Unmodified-Since defined but not used
; Last-Modified defined but not used
</artwork></figure></section>
<?ENDINC p4-conditional.abnf-appendix ?>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC 2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Move definitions of 304 and 412 condition codes from Part2.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-01">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-02" anchor="changes.since.02">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/116"/>:
      "Weak ETags on non-GET requests"
    </t>
  </list>
</t>
<t>
  Ongoing work on IANA Message Header Field Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header field registrations for header fields defined
      in this document.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-03" anchor="changes.since.03">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/71"/>:
      "Examples for ETag matching"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/124"/>:
      "'entity value' undefined"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/126"/>:
      "bogus 2068 Date header reference"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-04" anchor="changes.since.04">
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header field value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-05" anchor="changes.since.05">
<t>
  Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Add appendix containing collected and expanded ABNF, reorganize ABNF introduction.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-06" anchor="changes.since.06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/153"/>:
      "case-sensitivity of etag weakness indicator"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-07" anchor="changes.since.07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/116"/>:
      "Weak ETags on non-GET requests" (If-Match still was defined to require
      strong matching)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/198"/>:
      "move IANA registrations for optional status codes"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-08" anchor="changes.since.08">
<t>
  No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-09" anchor="changes.since.09">
<t>
  No significant changes.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/69"/>:
      "Clarify 'Requested Variant'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-11" anchor="changes.since.11">
<t>
  None.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-12" anchor="changes.since.12">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/224"/>:
      "Header Classification"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-13" anchor="changes.since.13">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/89"/>:
      "If-* and entities"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/101"/>:
      "Definition of validator weakness"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/276"/>:
      "untangle ABNFs for header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/269"/>:
      "ETags and Quotes"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-14" anchor="changes.since.14">
<t>
  None.
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-15" anchor="changes.since.15">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/304"/>:
      "If-Range should be listed when dicussing contexts where L-M can be considered strong"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-16" anchor="changes.since.16">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/186"/>:
      "Document HTTP's error-handling philosophy"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-17" anchor="changes.since.17">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/306"/>:
      "does etag value really use quoted-string"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p4-conditional-18" anchor="changes.since.18">
<t>
  None yet.
</t>
</section>

</section>

</back>
</rfc>
