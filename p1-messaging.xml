<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../myxml2rfc.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "latest">
  <!ENTITY ID-MONTH "July">
  <!ENTITY ID-YEAR "2012">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY caching-overview       "<xref target='Part6' x:rel='#caching.overview' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-incomplete       "<xref target='Part6' x:rel='#response.cacheability' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY payload                "<xref target='Part2' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY media-types            "<xref target='Part2' x:rel='#media.types' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-codings        "<xref target='Part2' x:rel='#content.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY CONNECT                "<xref target='Part2' x:rel='#CONNECT' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content.negotiation    "<xref target='Part2' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY diff-mime              "<xref target='Part2' x:rel='#differences.between.http.and.mime' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY representation         "<xref target='Part2' x:rel='#representation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-cache-control   "<xref target='Part6' x:rel='#header.cache-control' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date            "<xref target='Part2' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expect          "<xref target='Part2' x:rel='#header.expect' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-mime-version    "<xref target='Part2' x:rel='#mime-version' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-pragma          "<xref target='Part6' x:rel='#header.pragma' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-warning         "<xref target='Part6' x:rel='#header.warning' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY idempotent-methods     "<xref target='Part2' x:rel='#idempotent.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY methods                "<xref target='Part2' x:rel='#methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY OPTIONS                "<xref target='Part2' x:rel='#OPTIONS' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes           "<xref target='Part2' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-100             "<xref target='Part2' x:rel='#status.100' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-1xx             "<xref target='Part2' x:rel='#status.1xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-203             "<xref target='Part2' x:rel='#status.203' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-3xx             "<xref target='Part2' x:rel='#status.3xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-304             "<xref target='Part4' x:rel='#status.304' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-4xx             "<xref target='Part2' x:rel='#status.4xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-414             "<xref target='Part2' x:rel='#status.414' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cons-new-header-fields "<xref target='Part2' x:rel='#considerations.for.creating.header.fields' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2145,2616" updates="2817" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="next" basename="p2-semantics"/>
<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
<front>

  <title abbrev="HTTP/1.1, Part 1">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
    <organization abbrev="W3C">World Wide Web Consortium</organization>
    <address>
      <postal>
        <street>W3C / ERCIM</street>
        <street>2004, rte des Lucioles</street>
        <city>Sophia-Antipolis</city>
        <region>AM</region>
        <code>06902</code>
        <country>France</country>
      </postal>
      <email>ylafon@w3.org</email>
      <uri>http://www.raubacapeu.net/people/yves/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. HTTP has been in
   use by the World Wide Web global information initiative since 1990. This
   document is Part 1 of the seven-part specification that defines the protocol
   referred to as "HTTP/1.1" and, taken together, obsoletes
   <xref target="RFC2616" x:fmt="none">RFC 2616</xref> and moves it to historic
   status, along with its predecessor <xref target="RFC2068" x:fmt="none">RFC
   2068</xref>.
</t>
<t>
   Part 1 provides an overview of HTTP and its associated terminology, defines
   the "http" and "https" Uniform Resource Identifier (URI) schemes, defines
   the generic message syntax and parsing requirements for HTTP message frames,
   and describes general security concerns for implementations.
</t>
<t>
   This part also obsoletes RFCs <xref target="RFC2145" x:fmt="none">2145</xref>
   (on HTTP version numbers) and <xref target="RFC2817" x:fmt="none">2817</xref>
   (on using CONNECT for TLS upgrades) and moves them to historic status.
</t>
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft ought to take place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.19"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   request/response protocol that uses extensible semantics and MIME-like
   message payloads for flexible interaction with network-based hypertext
   information systems. HTTP relies upon the Uniform Resource Identifier (URI)
   standard <xref target="RFC3986"/> to indicate the target resource
   (<xref target="target-resource"/>) and relationships between resources.
   Messages are passed in a format similar to that used by Internet mail
   <xref target="RFC5322"/> and the Multipurpose Internet Mail Extensions
   (MIME) <xref target="RFC2045"/> (see &diff-mime; for the differences
   between HTTP and MIME messages).
</t>
<t>
   HTTP is a generic interface protocol for information systems. It is
   designed to hide the details of how a service is implemented by presenting
   a uniform interface to clients that is independent of the types of
   resources provided. Likewise, servers do not need to be aware of each
   client's purpose: an HTTP request can be considered in isolation rather
   than being associated with a specific type of client or a predetermined
   sequence of application steps. The result is a protocol that can be used
   effectively in many different contexts and for which implementations can
   evolve independently over time.
</t>
<t>
   HTTP is also designed for use as an intermediation protocol for translating
   communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative information
   services by translating their diverse protocols into a hypertext
   format that can be viewed and manipulated by clients in the same way
   as HTTP services.
</t>
<t>
   One consequence of HTTP flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface. Instead, we
   are limited to defining the syntax of communication, the intent
   of received communication, and the expected behavior of recipients.
   If the communication is considered in isolation, then successful
   actions ought to be reflected in corresponding changes to the
   observable interface provided by servers. However, since multiple
   clients might act in parallel and perhaps at cross-purposes, we
   cannot require that such changes be observable beyond the scope
   of a single response.
</t>
<t>
   This document is Part 1 of the seven-part specification of HTTP,
   defining the protocol referred to as "HTTP/1.1", obsoleting
   <xref target="RFC2616"/> and <xref target="RFC2145"/>.
   Part 1 describes the architectural elements that are used or
   referred to in HTTP, defines the "http" and "https" URI schemes,
   describes overall network operation and connection management,
   and defines HTTP message framing and forwarding requirements.
   Our goal is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining the
   complete set of requirements for message parsers and
   message-forwarding intermediaries.
</t>

<section title="Requirement Notation" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<iref primary="true" item="Grammar" subitem="ALPHA"/>
<iref primary="true" item="Grammar" subitem="CR"/>
<iref primary="true" item="Grammar" subitem="CRLF"/>
<iref primary="true" item="Grammar" subitem="CTL"/>
<iref primary="true" item="Grammar" subitem="DIGIT"/>
<iref primary="true" item="Grammar" subitem="DQUOTE"/>
<iref primary="true" item="Grammar" subitem="HEXDIG"/>
<iref primary="true" item="Grammar" subitem="HTAB"/>
<iref primary="true" item="Grammar" subitem="LF"/>
<iref primary="true" item="Grammar" subitem="OCTET"/>
<iref primary="true" item="Grammar" subitem="SP"/>
<iref primary="true" item="Grammar" subitem="VCHAR"/>
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation
   of <xref target="RFC5234"/> with the list rule extension defined in
   <xref target="abnf.extension"/>.  <xref target="collected.abnf"/> shows
   the collected ABNF with the list rule expanded.
</t>
<t anchor="core.rules">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CTL"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="CRLF"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="HEXDIG"/>
  <x:anchor-alias value="HTAB"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
   The following core rules are included by
   reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
   ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
   DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
   OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible <xref target="USASCII"/> character).
</t>
<t>
   As a convention, ABNF rule names prefixed with "obs-" denote
   "obsolete" grammar rules that appear for historical reasons.
</t>
</section>
</section>

<section title="Architecture" anchor="architecture">
<t>
   HTTP was created for the World Wide Web architecture
   and has evolved over time to support the scalability needs of a worldwide
   hypertext system. Much of that architecture is reflected in the terminology
   and syntax productions used to define HTTP.
</t>

<section title="Client/Server Messaging" anchor="operation">
<iref primary="true" item="client"/>
<iref primary="true" item="server"/>
<iref primary="true" item="connection"/>
<t>
   HTTP is a stateless request/response protocol that operates by exchanging
   <x:dfn>messages</x:dfn> (<xref target="http.message"/>) across a reliable
   transport or session-layer
   "<x:dfn>connection</x:dfn>". An HTTP "<x:dfn>client</x:dfn>" is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP "<x:dfn>server</x:dfn>" is a
   program that accepts connections in order to service HTTP requests by
   sending HTTP responses.
</t>
<iref primary="true" item="user agent"/>
<iref primary="true" item="origin server"/>
<iref primary="true" item="browser"/>
<iref primary="true" item="spider"/>
<iref primary="true" item="sender"/>
<iref primary="true" item="recipient"/>
<t>
   Note that the terms client and server refer only to the roles that
   these programs perform for a particular connection.  The same program
   might act as a client on some connections and a server on others.  We use
   the term "<x:dfn>user agent</x:dfn>" to refer to the program that initiates a request,
   such as a WWW browser, editor, or spider (web-traversing robot), and
   the term "<x:dfn>origin server</x:dfn>" to refer to the program that can originate
   authoritative responses to a request.  For general requirements, we use
   the term "<x:dfn>sender</x:dfn>" to refer to whichever component sent a given message
   and the term "<x:dfn>recipient</x:dfn>" to refer to any component that receives the
   message.
</t>
<x:note>
  <t>
    &Note; The term 'user agent' covers both those situations where
    there is a user (human) interacting with the software agent (and for which
    user interface or interactive suggestions might be made, e.g., warning the
    user or given the user an option in the case of security or privacy
    options) and also those where the software agent can act autonomously.
  </t>
</x:note>
<t>
   Most HTTP communication consists of a retrieval request (GET) for
   a representation of some resource identified by a URI.  In the
   simplest case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin server (O).
</t>
<figure><artwork type="drawing">
         request   &gt;
    <x:highlight>UA</x:highlight> ======================================= <x:highlight>O</x:highlight>
                                &lt;   response
</artwork></figure>
<iref primary="true" item="message"/>
<iref primary="true" item="request"/>
<iref primary="true" item="response"/>
<t>
   A client sends an HTTP request to the server in the form of a <x:dfn>request</x:dfn>
   message, beginning with a request-line that includes a method, URI, and
   protocol version (<xref target="request.line"/>),
   followed by MIME-like header fields containing
   request modifiers, client information, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   A server responds to the client's request by sending one or more HTTP
   <x:dfn>response</x:dfn>
   messages, each beginning with a status line that
   includes the protocol version, a success or error code, and textual
   reason phrase (<xref target="status.line"/>),
   possibly followed by MIME-like header fields containing server
   information, resource metadata, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   The following example illustrates a typical message exchange for a
   GET request on the URI "http://www.example.com/hello.txt":
</t>
<figure><preamble>
client request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept: */*

</artwork></figure>
<figure><preamble>
server response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World!
</x:span></artwork></figure>
</section>

<section title="Connections and Transport Independence" anchor="transport-independence">
<t>
   HTTP messaging is independent of the underlying transport or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of the underlying transport
   protocol is outside the scope of this specification.
</t>
<t>
   The specific connection protocols to be used for an interaction
   are determined by client configuration and the target URI
   (<xref target="target-resource"/>).
   For example, the "http" URI scheme
   (<xref target="http.uri"/>) indicates a default connection of TCP
   over IP, with a default TCP port of 80, but the client might be
   configured to use a proxy via some other connection port or protocol
   instead of using the defaults.
</t>
<t>
   A connection might be used for multiple HTTP request/response exchanges,
   as defined in <xref target="persistent.connections"/>.
</t>
</section>

<section title="Intermediaries" anchor="intermediaries">
<iref primary="true" item="intermediary"/>
<t>
   HTTP enables the use of intermediaries to satisfy requests through
   a chain of connections.  There are three common forms of HTTP
   <x:dfn>intermediary</x:dfn>: proxy, gateway, and tunnel.  In some cases,
   a single intermediary might act as an origin server, proxy, gateway,
   or tunnel, switching behavior based on the nature of each request.
</t>
<figure><artwork type="drawing">
         &gt;             &gt;             &gt;             &gt;
    <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> =========== <x:highlight>C</x:highlight> =========== <x:highlight>O</x:highlight>
               &lt;             &lt;             &lt;             &lt;
</artwork></figure>
<t>
   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options
   might apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant might
   be engaged in multiple, simultaneous communications. For example, B
   might be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.
</t>
<t>
<iref primary="true" item="upstream"/><iref primary="true" item="downstream"/>
<iref primary="true" item="inbound"/><iref primary="true" item="outbound"/>
   We use the terms "<x:dfn>upstream</x:dfn>" and "<x:dfn>downstream</x:dfn>"
   to describe various requirements in relation to the directional flow of a
   message: all messages flow from upstream to downstream.
   Likewise, we use the terms inbound and outbound to refer to
   directions in relation to the request path:
   "<x:dfn>inbound</x:dfn>" means toward the origin server and
   "<x:dfn>outbound</x:dfn>" means toward the user agent.
</t>
<t><iref primary="true" item="proxy"/>
   A "<x:dfn>proxy</x:dfn>" is a message forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some translations
   are minimal, such as for proxy requests for "http" URIs, whereas
   other requests might require translation to and from entirely different
   application-layer protocols. Proxies are often used to group an
   organization's HTTP requests through a common intermediary for the
   sake of security, annotation services, or shared caching.
</t>
<t>
<iref primary="true" item="transforming proxy"/>
<iref primary="true" item="non-transforming proxy"/>
   An HTTP-to-HTTP proxy is called a "<x:dfn>transforming proxy</x:dfn>" if it is designed
   or configured to modify request or response messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or an intranet-to-Internet privacy filter.  Such
   transformations are presumed to be desired by the client (or client
   organization) that selected the proxy and are beyond the scope of
   this specification.  However, when a proxy is not intended to transform
   a given message, we use the term "<x:dfn>non-transforming proxy</x:dfn>" to target
   requirements that preserve HTTP message semantics. See &status-203; and
   &header-warning; for status and warning codes related to transformations.
</t>
<t><iref primary="true" item="gateway"/><iref primary="true" item="reverse proxy"/>
<iref primary="true" item="accelerator"/>
   A "<x:dfn>gateway</x:dfn>" (a.k.a., "<x:dfn>reverse proxy</x:dfn>")
   is a receiving agent that acts
   as a layer above some other server(s) and translates the received
   requests to the underlying server's protocol.  Gateways are often
   used to encapsulate legacy or untrusted information services, to
   improve server performance through "<x:dfn>accelerator</x:dfn>" caching, and to
   enable partitioning or load-balancing of HTTP services across
   multiple machines.
</t>
<t>
   A gateway behaves as an origin server on its outbound connection and
   as a user agent on its inbound connection.
   All HTTP requirements applicable to an origin server
   also apply to the outbound communication of a gateway.
   A gateway communicates with inbound servers using any protocol that
   it desires, including private extensions to HTTP that are outside
   the scope of this specification.  However, an HTTP-to-HTTP gateway
   that wishes to interoperate with third-party HTTP servers &MUST;
   conform to HTTP user agent requirements on the gateway's inbound
   connection and &MUST; implement the Connection
   (<xref target="header.connection"/>) and Via (<xref target="header.via"/>)
   header fields for both connections.
</t>
<t><iref primary="true" item="tunnel"/>
   A "<x:dfn>tunnel</x:dfn>" acts as a blind relay between two connections
   without changing the messages. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel might
   have been initiated by an HTTP request. A tunnel ceases to exist when
   both ends of the relayed connection are closed. Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   transport-layer security is used to establish private communication
   through a shared firewall proxy.
</t>
<t><iref primary="true" item="interception proxy"/><iref primary="true" item="transparent proxy"/>
<iref primary="true" item="captive portal"/>
   In addition, there might exist network intermediaries that are not
   considered part of the HTTP communication but nevertheless act as
   filters or redirecting agents (usually violating HTTP semantics,
   causing security problems, and otherwise making a mess of things).
   Such a network intermediary, often referred to as an "<x:dfn>interception proxy</x:dfn>"
   <xref target="RFC3040"/>, "<x:dfn>transparent proxy</x:dfn>" <xref target="RFC1919"/>,
   or "<x:dfn>captive portal</x:dfn>",
   differs from an HTTP proxy because it has not been selected by the client.
   Instead, the network intermediary redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic) to an internal HTTP server.
   Interception proxies are commonly found on public network access points,
   as a means of enforcing account subscription prior to allowing use of
   non-local Internet services, and within corporate firewalls to enforce
   network usage policies.
   They are indistinguishable from a man-in-the-middle attack.
</t>
<t>
   HTTP is defined as a stateless protocol, meaning that each request message
   can be understood in isolation.  Many implementations depend on HTTP's
   stateless design in order to reuse proxied connections or dynamically
   load balance requests across multiple servers.  Hence, servers &MUST-NOT;
   assume that two requests on the same connection are from the same user
   agent unless the connection is secured and specific to that agent.
   Some non-standard HTTP extensions (e.g., <xref target="RFC4559"/>) have
   been known to violate this requirement, resulting in security and
   interoperability problems.
</t>
</section>

<section title="Caches" anchor="caches">
<iref primary="true" item="cache"/>
<t>
   A "<x:dfn>cache</x:dfn>" is a local store of previous response messages and the
   subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests. Any client or server &MAY; employ a cache, though a cache
   cannot be used by a server while it is acting as a tunnel.
</t>
<t>
   The effect of a cache is that the request/response chain is shortened
   if one of the participants along the chain has a cached response
   applicable to that request. The following illustrates the resulting
   chain if B has a cached copy of an earlier response from O (via C)
   for a request which has not been cached by UA or A.
</t>
<figure><artwork type="drawing">
            &gt;             &gt;
       <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> - - - - - - <x:highlight>C</x:highlight> - - - - - - <x:highlight>O</x:highlight>
                  &lt;             &lt;
</artwork></figure>
<t><iref primary="true" item="cacheable"/>
   A response is "<x:dfn>cacheable</x:dfn>" if a cache is allowed to store a copy of
   the response message for use in answering subsequent requests.
   Even when a response is cacheable, there might be additional
   constraints placed by the client or by the origin server on when
   that cached response can be used for a particular request. HTTP
   requirements for cache behavior and cacheable responses are
   defined in &caching-overview;.  
</t>
<t>
   There are a wide variety of architectures and configurations
   of caches and proxies deployed across the World Wide Web and
   inside large organizations. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via optical media, and so on.
</t>
</section>

<section title="Conformance and Error Handling" anchor="intro.conformance.and.error.handling">
<t>
   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, HTTP requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP.
</t>
<t>
   Senders &MUST-NOT; generate protocol elements that do not match the grammar
   defined by the ABNF rules for those protocol elements.
</t>
<t>
   Unless noted otherwise, recipients &MUST; be able to parse all protocol
   elements matching the ABNF rules defined for them and &MAY; attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the Location header
   field doesn't parse according to the ABNF, whereas a systems control
   client might consider any form of error recovery to be dangerous.
</t>
</section>

<section title="Protocol Versioning" anchor="http.version">
  <x:anchor-alias value="HTTP-version"/>
  <x:anchor-alias value="HTTP-name"/>
<t>
   HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate
   versions of the protocol. This specification defines version "1.1".
   The protocol version as a whole indicates the sender's conformance
   with the set of requirements laid out in that version's corresponding
   specification of HTTP.
</t>
<t>
   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message. HTTP-version is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-version"/><iref primary="true" item="Grammar" subitem="HTTP-name"/>
  <x:ref>HTTP-version</x:ref>  = <x:ref>HTTP-name</x:ref> "/" <x:ref>DIGIT</x:ref> "." <x:ref>DIGIT</x:ref>
  <x:ref>HTTP-name</x:ref>     = <x:abnf-char-sequence>"HTTP"</x:abnf-char-sequence> ; "HTTP", case-sensitive 
</artwork></figure>
<t>
   The HTTP version number consists of two decimal digits separated by a "."
   (period or decimal point).  The first digit ("major version") indicates the
   HTTP messaging syntax, whereas the second digit ("minor version") indicates
   the highest minor version to which the sender is
   conformant and able to understand for future communication.  The minor
   version advertises the sender's communication capabilities even when the
   sender is only using a backwards-compatible subset of the protocol,
   thereby letting the recipient know that more advanced features can
   be used in response (by servers) or in future requests (by clients).
</t>
<t>
   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient
   <xref target="RFC1945"/> or a recipient whose version is unknown,
   the HTTP/1.1 message is constructed such that it can be interpreted
   as a valid HTTP/1.0 message if all of the newer features are ignored.
   This specification places recipient-version requirements on some
   new features so that a conformant sender will only use compatible
   features until it has determined, through configuration or the
   receipt of a message, that the recipient supports HTTP/1.1.
</t>
<t>
   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default
   behavior of a recipient in the absence of such a field can change.
   Unless specified otherwise, header fields defined in HTTP/1.1 are
   defined for all versions of HTTP/1.x.  In particular, the Host and
   Connection header fields ought to be implemented by all HTTP/1.x
   implementations whether or not they advertise conformance with HTTP/1.1.
</t>
<t>
   New header fields can be defined such that, when they are
   understood by a recipient, they might override or enhance the
   interpretation of previously defined header fields.  When an
   implementation receives an unrecognized header field, the recipient
   &MUST; ignore that header field for local processing regardless of
   the message's HTTP version.  An unrecognized header field received
   by a proxy &MUST; be forwarded downstream unless the header field's
   field-name is listed in the message's Connection header field
   (see <xref target="header.connection"/>).
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.
</t>
<t>
   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) &MUST; send their own HTTP-version
   in forwarded messages.  In other words, they &MUST-NOT; blindly
   forward the first line of an HTTP message without ensuring that the
   protocol version in that message matches a version to which that
   intermediary is conformant for both the receiving and
   sending of messages.  Forwarding an HTTP message without rewriting
   the HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what features
   are safe to use for later communication with that sender.
</t>
<t>
   An HTTP client &SHOULD; send a request version equal to the highest
   version to which the client is conformant and
   whose major version is no higher than the highest version supported
   by the server, if this is known.  An HTTP client &MUST-NOT; send a
   version to which it is not conformant.
</t>
<t>
   An HTTP client &MAY; send a lower request version if it is known that
   the server incorrectly implements the HTTP specification, but only
   after the client has attempted at least one normal request and determined
   from the response status or header fields (e.g., Server) that the
   server improperly handles higher request versions.
</t>
<t>
   An HTTP server &SHOULD; send a response version equal to the highest
   version to which the server is conformant and
   whose major version is less than or equal to the one received in the
   request.  An HTTP server &MUST-NOT; send a version to which it is not
   conformant.  A server &MAY; send a <x:ref>505 (HTTP Version Not
   Supported)</x:ref> response if it cannot send a response using the
   major version used in the client's request.
</t>
<t>
   An HTTP server &MAY; send an HTTP/1.0 response to an HTTP/1.0 request
   if it is known or suspected that the client incorrectly implements the
   HTTP specification and is incapable of correctly processing later
   version responses, such as when a client fails to parse the version
   number correctly or when an intermediary is known to blindly forward
   the HTTP-version even when it doesn't conform to the given minor
   version of the protocol. Such protocol downgrades &SHOULD-NOT; be
   performed unless triggered by specific client attributes, such as when
   one or more of the request header fields (e.g., User-Agent) uniquely
   match the values sent by a client known to be in error.
</t>
<t>
   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.  However,
   the minor version was not incremented for the changes introduced between
   <xref target="RFC2068"/> and <xref target="RFC2616"/>, and this revision
   is specifically avoiding any such changes to the protocol.
</t>
</section>

<section title="Uniform Resource Identifiers" anchor="uri">
<iref primary="true" item="resource"/>
<t>
   Uniform Resource Identifiers (URIs) <xref target="RFC3986"/> are used
   throughout HTTP as the means for identifying resources. URI references
   are used to target requests, indicate redirects, and define relationships.
   HTTP does not limit what a resource might be; it merely defines an interface
   that can be used to interact with a resource via HTTP. More information on
   the scope of URIs and resources can be found in <xref target="RFC3986"/>.
</t>
  <x:anchor-alias value="URI-reference"/>
  <x:anchor-alias value="absolute-URI"/>
  <x:anchor-alias value="relative-part"/>
  <x:anchor-alias value="authority"/>
  <x:anchor-alias value="path-abempty"/>
  <x:anchor-alias value="path-absolute"/>
  <x:anchor-alias value="port"/>
  <x:anchor-alias value="query"/>
  <x:anchor-alias value="uri-host"/>
  <x:anchor-alias value="partial-URI"/>
<t>
   This specification adopts the definitions of "URI-reference",
   "absolute-URI", "relative-part", "port", "host",
   "path-abempty", "path-absolute", "query", and "authority" from the
   URI generic syntax <xref target="RFC3986"/>.
   In addition, we define a partial-URI rule for protocol elements
   that allow a relative URI but not a fragment.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="URI-reference"/><iref primary="true" item="Grammar" subitem="absolute-URI"/><iref primary="true" item="Grammar" subitem="authority"/><iref primary="true" item="Grammar" subitem="path-absolute"/><iref primary="true" item="Grammar" subitem="port"/><iref primary="true" item="Grammar" subitem="query"/><iref primary="true" item="Grammar" subitem="uri-host"/>
  <x:ref>URI-reference</x:ref> = &lt;URI-reference, defined in <xref target="RFC3986" x:fmt="," x:sec="4.1"/>&gt;
  <x:ref>absolute-URI</x:ref>  = &lt;absolute-URI, defined in <xref target="RFC3986" x:fmt="," x:sec="4.3"/>&gt;
  <x:ref>relative-part</x:ref> = &lt;relative-part, defined in <xref target="RFC3986" x:fmt="," x:sec="4.2"/>&gt;
  <x:ref>authority</x:ref>     = &lt;authority, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2"/>&gt;
  <x:ref>path-abempty</x:ref>  = &lt;path-abempty, defined in <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>path-absolute</x:ref> = &lt;path-absolute, defined in <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>port</x:ref>          = &lt;port, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2.3"/>&gt;
  <x:ref>query</x:ref>         = &lt;query, defined in <xref target="RFC3986" x:fmt="," x:sec="3.4"/>&gt;
  <x:ref>uri-host</x:ref>      = &lt;host, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>&gt;
  
  <x:ref>partial-URI</x:ref>   = relative-part [ "?" query ]
</artwork></figure>
<t>
   Each protocol element in HTTP that allows a URI reference will indicate
   in its ABNF production whether the element allows any form of reference
   (URI-reference), only a URI in absolute form (absolute-URI), only the
   path and optional query components, or some combination of the above.
   Unless otherwise indicated, URI references are parsed
   relative to the effective request URI
   (<xref target="effective.request.uri"/>).
</t>

<section title="http URI scheme" anchor="http.uri">
  <x:anchor-alias value="http-URI"/>
  <iref item="http URI scheme" primary="true"/>
  <iref item="URI scheme" subitem="http" primary="true"/>
<t>
   The "http" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP connections on a given port.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="http-URI"/>
  <x:ref>http-URI</x:ref> = "http:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
</artwork></figure>
<t>
   The HTTP origin server is identified by the generic syntax's 
   <x:ref>authority</x:ref> component, which includes a host identifier
   and optional TCP port (<xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>).
   The remainder of the URI, consisting of both the hierarchical path
   component and optional query component, serves as an identifier for
   a potential resource within that origin server's name space.
</t>
<t>
   If the host identifier is provided as an IP literal or IPv4 address,
   then the origin server is any listener on the indicated TCP port at
   that IP address. If host is a registered name, then that name is
   considered an indirect identifier and the recipient might use a name
   resolution service, such as DNS, to find the address of a listener
   for that host.
   The host &MUST-NOT; be empty; if an "http" URI is received with an
   empty host, then it &MUST; be rejected as invalid. 
   If the port subcomponent is empty or not given, then TCP port 80 is
   assumed (the default reserved port for WWW services).
</t>
<t>
   Regardless of the form of host identifier, access to that host is not
   implied by the mere presence of its name or address. The host might or might
   not exist and, even when it does exist, might or might not be running an
   HTTP server or listening to the indicated port. The "http" URI scheme
   makes use of the delegated nature of Internet names and addresses to
   establish a naming authority (whatever entity has the ability to place
   an HTTP server at that Internet name or address) and allows that
   authority to determine which names are valid and how they might be used.
</t>
<t>
   When an "http" URI is used within a context that calls for access to the
   indicated resource, a client &MAY; attempt access by resolving
   the host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (<xref target="http.message"/>) containing the URI's identifying data
   (<xref target="message.routing"/>) to the server.
   If the server responds to that request with a non-interim HTTP response
   message, as described in &status-codes;, then that response
   is considered an authoritative answer to the client's request.
</t>
<t>
   Although HTTP is independent of the transport protocol, the "http"
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.
   An HTTP service based on some other underlying connection protocol
   would presumably be identified using a different URI scheme, just as
   the "https" scheme (below) is used for servers that require an SSL/TLS
   transport layer on a connection. Other protocols might also be used to
   provide access to "http" identified resources &mdash; it is only the
   authoritative interface used for mapping the namespace that is
   specific to TCP.
</t>
<t>
   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (<xref target="RFC3986" x:fmt="," x:sec="3.2.1"/>)
   for including user authentication information in the URI.  Some
   implementations make use of the userinfo component for internal
   configuration of authentication information, such as within command
   invocation options, configuration files, or bookmark lists, even
   though such usage might expose a user identifier or password.
   Senders &MUST-NOT; include a userinfo subcomponent (and its "@"
   delimiter) when transmitting an "http" URI in a message.  Recipients
   of HTTP messages that contain a URI reference &SHOULD; parse for the
   existence of userinfo and treat its presence as an error, likely
   indicating that the deprecated subcomponent is being used to obscure
   the authority for the sake of phishing attacks.
</t>
</section>

<section title="https URI scheme" anchor="https.uri">
   <x:anchor-alias value="https-URI"/>
   <iref item="https URI scheme"/>
   <iref item="URI scheme" subitem="https"/>
<t>
   The "https" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   SSL/TLS-secured connections on a given TCP port.
</t>
<t>
   All of the requirements listed above for the "http" scheme are also
   requirements for the "https" scheme, except that a default TCP port
   of 443 is assumed if the port subcomponent is empty or not given,
   and the TCP connection &MUST; be secured for privacy through the
   use of strong encryption prior to sending the first HTTP request.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="https-URI"/>
  <x:ref>https-URI</x:ref> = "https:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
</artwork></figure>
<t>
   Unlike the "http" scheme, responses to "https" identified requests
   are never "public" and thus &MUST-NOT; be reused for shared caching.
   They can, however, be reused in a private cache if the message is
   cacheable by default in HTTP or specifically indicated as such by
   the Cache-Control header field (&header-cache-control;).
</t>
<t>
   Resources made available via the "https" scheme have no shared
   identity with the "http" scheme even if their resource identifiers
   indicate the same authority (the same host listening to the same
   TCP port).  They are distinct name spaces and are considered to be
   distinct origin servers.  However, an extension to HTTP that is
   defined to apply to entire host domains, such as the Cookie protocol 
   <xref target="RFC6265"/>, can allow information
   set by one service to impact communication with other services
   within a matching group of host domains.
</t>
<t>
   The process for authoritative access to an "https" identified
   resource is defined in <xref target="RFC2818"/>.
</t>
</section>

<section title="http and https URI Normalization and Comparison" anchor="uri.comparison">
<t>
   Since the "http" and "https" schemes conform to the URI generic syntax,
   such URIs are normalized and compared according to the algorithm defined
   in <xref target="RFC3986" x:fmt="," x:sec="6"/>, using the defaults
   described above for each scheme.
</t>
<t>
   If the port is equal to the default port for a scheme, the normal
   form is to elide the port subcomponent. Likewise, an empty path
   component is equivalent to an absolute path of "/", so the normal
   form is to provide a path of "/" instead. The scheme and host
   are case-insensitive and normally provided in lowercase; all
   other components are compared in a case-sensitive manner.
   Characters other than those in the "reserved" set are equivalent
   to their percent-encoded octets (see <xref target="RFC3986"
   x:fmt="," x:sec="2.1"/>): the normal form is to not encode them.
</t>
<t>
   For example, the following three URIs are equivalent:
</t>
<figure><artwork type="example">
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
</artwork></figure>
</section>
</section>
</section>

<section title="Message Format" anchor="http.message">
<x:anchor-alias value="generic-message"/>
<x:anchor-alias value="message.types"/>
<x:anchor-alias value="HTTP-message"/>
<x:anchor-alias value="start-line"/>
<iref item="header section"/>
<iref item="headers"/>
<iref item="header field"/>
<t>
   All HTTP/1.1 messages consist of a start-line followed by a sequence of
   octets in a format similar to the Internet Message Format
   <xref target="RFC5322"/>: zero or more header fields (collectively
   referred to as the "headers" or the "header section"), an empty line
   indicating the end of the header section, and an optional message body.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-message"/>
  <x:ref>HTTP-message</x:ref>   = <x:ref>start-line</x:ref>
                   *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
                   <x:ref>CRLF</x:ref>
                   [ <x:ref>message-body</x:ref> ]
</artwork></figure>
<t>
   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash
   table by field name until the empty line, and then use the parsed
   data to determine if a message body is expected.  If a message body
   has been indicated, then it is read as a stream until an amount
   of octets equal to the message body length is read or the connection
   is closed.
</t>
<t>
   Recipients &MUST; parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII <xref target="USASCII"/>.
   Parsing an HTTP message as a stream of Unicode characters, without regard
   for the specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid multibyte
   character sequences that contain the octet LF (%x0A).  String-based
   parsers can only be safely used within protocol elements after the element
   has been extracted from the message, such as within a header field-value
   after message parsing has delineated the individual fields.
</t>
<t>
   An HTTP message can be parsed as a stream for incremental processing or
   forwarding downstream.  However, recipients cannot rely on incremental
   delivery of partial messages, since some implementations will buffer or
   delay message forwarding for the sake of network efficiency, security
   checks, or payload transformations.
</t>

<section title="Start Line" anchor="start.line">
  <x:anchor-alias value="Start-Line"/>
<t>
   An HTTP message can either be a request from client to server or a
   response from server to client.  Syntactically, the two types of message
   differ only in the start-line, which is either a request-line (for requests)
   or a status-line (for responses), and in the algorithm for determining
   the length of the message body (<xref target="message.body"/>).
   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats,
   but in practice servers are implemented to only expect a request
   (a response is interpreted as an unknown or invalid request method)
   and clients are implemented to only expect a response.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="start-line"/>
  <x:ref>start-line</x:ref>     = <x:ref>request-line</x:ref> / <x:ref>status-line</x:ref>
</artwork></figure>
<t>
</t>
<t>
   Implementations &MUST-NOT; send whitespace between the start-line and
   the first header field. The presence of such whitespace in a request
   might be an attempt to trick a server into ignoring that field or
   processing the line after it as a new request, either of which might
   result in a security vulnerability if other implementations within
   the request chain interpret the same message differently.
   Likewise, the presence of such whitespace in a response might be
   ignored by some clients or cause others to cease parsing.
</t>

<section title="Request Line" anchor="request.line">
  <x:anchor-alias value="Request"/>
  <x:anchor-alias value="request-line"/>
<t>
   A request-line begins with a method token, followed by a single
   space (SP), the request-target, another single space (SP), the
   protocol version, and ending with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-line"/>
  <x:ref>request-line</x:ref>   = <x:ref>method</x:ref> <x:ref>SP</x:ref> <x:ref>request-target</x:ref> <x:ref>SP</x:ref> <x:ref>HTTP-version</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>
<iref primary="true" item="method"/>
<t anchor="method">
   The method token indicates the request method to be performed on the
   target resource. The request method is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="method"/>
  <x:ref>method</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   The methods defined by this specification can be found in
   &methods;, along with information regarding the HTTP method registry
   and considerations for defining new methods.
</t>
<iref item="request-target"/>
<t>
   The request-target identifies the target resource upon which to apply
   the request, as defined in <xref target="request-target"/>.
</t>
<t>
   No whitespace is allowed inside the method, request-target, and
   protocol version.  Hence, recipients typically parse the request-line
   into its component parts by splitting on the SP characters.
</t>
<t>
   Unfortunately, some user agents fail to properly encode hypertext
   references that have embedded whitespace, sending the characters
   directly instead of properly percent-encoding the disallowed characters.
   Recipients of an invalid request-line &SHOULD; respond with either a
   <x:ref>400 (Bad Request)</x:ref> error or a <x:ref>301 (Moved Permanently)</x:ref>
   redirect with the request-target properly encoded.  Recipients &SHOULD-NOT;
   attempt to autocorrect and then process the request without a redirect,
   since the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.
</t>
<t>
   HTTP does not place a pre-defined limit on the length of a request-line.
   A server that receives a method longer than any that it implements
   &SHOULD; respond with either a <x:ref>405 (Method Not Allowed)</x:ref>, if it is an origin
   server, or a <x:ref>501 (Not Implemented)</x:ref> status code.
   A server &MUST; be prepared to receive URIs of unbounded length and
   respond with the <x:ref>414 (URI Too Long)</x:ref> status code if the received
   request-target would be longer than the server wishes to handle
   (see &status-414;).
</t>
<t>
   Various ad-hoc limitations on request-line length are found in practice.
   It is &RECOMMENDED; that all HTTP senders and recipients support, at a
   minimum, request-line lengths of up to 8000 octets.
</t>
</section>

<section title="Status Line" anchor="status.line">
  <x:anchor-alias value="response"/>
  <x:anchor-alias value="status-line"/>
<t>
   The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another space,
   a possibly-empty textual phrase describing the status code, and
   ending with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-line"/>
  <x:ref>status-line</x:ref> = <x:ref>HTTP-version</x:ref> <x:ref>SP</x:ref> <x:ref>status-code</x:ref> <x:ref>SP</x:ref> <x:ref>reason-phrase</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>

<t anchor="status-code">
   The status-code element is a 3-digit integer result code of the attempt to
   understand and satisfy the request. See &status-codes; for
   further information, such as the list of status codes defined by this
   specification, the IANA registry, and considerations for new status codes.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-code"/>
  <x:ref>status-code</x:ref>    = 3<x:ref>DIGIT</x:ref>
</artwork></figure>

<t anchor="reason-phrase">   
   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were more
   frequently used with interactive text clients. A client &SHOULD; ignore
   the reason-phrase content.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="reason-phrase"/>
  <x:ref>reason-phrase</x:ref>  = *( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> )
</artwork></figure>
</section>
</section>

<section title="Header Fields" anchor="header.fields">
  <x:anchor-alias value="header-field"/>
  <x:anchor-alias value="field-content"/>
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="field-value"/>
  <x:anchor-alias value="obs-fold"/>
<t>
   Each HTTP header field consists of a case-insensitive field name
   followed by a colon (":"), optional whitespace, and the field value.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="header-field"/><iref primary="true" item="Grammar" subitem="field-name"/><iref primary="true" item="Grammar" subitem="field-value"/><iref primary="true" item="Grammar" subitem="field-content"/><iref primary="true" item="Grammar" subitem="obs-fold"/>
  <x:ref>header-field</x:ref>   = <x:ref>field-name</x:ref> ":" <x:ref>OWS</x:ref> <x:ref>field-value</x:ref> <x:ref>BWS</x:ref>
  <x:ref>field-name</x:ref>     = <x:ref>token</x:ref>
  <x:ref>field-value</x:ref>    = *( <x:ref>field-content</x:ref> / <x:ref>obs-fold</x:ref> )
  <x:ref>field-content</x:ref>  = *( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> )
  <x:ref>obs-fold</x:ref>       = <x:ref>CRLF</x:ref> ( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; obsolete line folding
                 ; see <xref target="field.parsing"/>
</artwork></figure>
<t>
   The field-name token labels the corresponding field-value as having the
   semantics defined by that header field.  For example, the Date header field
   is defined in &header-date; as containing the origination
   timestamp for the message in which it appears.
</t>
<t>
   HTTP header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new semantics,
   or on the number of header fields used in a given message.  Existing
   fields are defined in each part of this specification and in many other
   specifications outside the standards process.
   New header fields can be introduced without changing the protocol version
   if their defined semantics allow them to be safely ignored by recipients
   that do not recognize them.
</t>
<t>
   New HTTP header fields &SHOULD; be registered with IANA according
   to the procedures in &cons-new-header-fields;.
   Unrecognized header fields &MUST; be forwarded by a proxy unless the
   field-name is listed in the Connection header field
   (<xref target="header.connection"/>) or the proxy is specifically
   configured to block or otherwise transform such fields.
   Unrecognized header fields &SHOULD; be ignored by other recipients.
</t>
<t>
   The order in which header fields with differing field names are
   received is not significant. However, it is "good practice" to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server &MUST;
   wait until the entire header section is received before interpreting
   a request message, since later header fields might include conditionals,
   authentication credentials, or deliberately misleading duplicate
   header fields that would impact request processing.
</t>
<t>
   Multiple header fields with the same field name &MUST-NOT; be
   sent in a message unless the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   Multiple header fields with the same field name can be combined into
   one "field-name: field-value" pair, without changing the semantics of the
   message, by appending each subsequent field value to the combined
   field value in order, separated by a comma. The order in which
   header fields with the same field name are received is therefore
   significant to the interpretation of the combined field value;
   a proxy &MUST-NOT; change the order of these field values when
   forwarding a message.
</t>
<x:note>
  <t>
   &Note; The "Set-Cookie" header field as implemented in
   practice can occur multiple times, but does not use the list syntax, and
   thus cannot be combined into a single line (<xref target="RFC6265"/>). (See Appendix A.2.3 of <xref target="Kri2001"/>
   for details.) Also note that the Set-Cookie2 header field specified in
   <xref target="RFC2965"/> does not share this problem. 
  </t>
</x:note>

<section title="Whitespace" anchor="whitespace">
<t anchor="rule.LWS">
   This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS ("bad" whitespace). 
</t>
<t anchor="rule.OWS">
   The OWS rule is used where zero or more linear whitespace octets might
   appear. OWS &SHOULD; either not be produced or be produced as a single
   SP. Multiple OWS octets that occur within field-content &SHOULD; either
   be replaced with a single SP or transformed to all SP octets (each
   octet other than SP replaced with SP) before interpreting the field value
   or forwarding the message downstream.
</t>
<t anchor="rule.RWS">
   RWS is used when at least one linear whitespace octet is required to
   separate field tokens. RWS &SHOULD; be produced as a single SP.
   Multiple RWS octets that occur within field-content &SHOULD; either
   be replaced with a single SP or transformed to all SP octets before
   interpreting the field value or forwarding the message downstream.
</t>
<t anchor="rule.BWS">
   BWS is used where the grammar allows optional whitespace for historical
   reasons but senders &SHOULD-NOT; produce it in messages. HTTP/1.1
   recipients &MUST; accept such bad optional whitespace and remove it before
   interpreting the field value or forwarding the message downstream.
</t>
<t anchor="rule.whitespace">
  <x:anchor-alias value="BWS"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="RWS"/>
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="OWS"/><iref primary="true" item="Grammar" subitem="RWS"/><iref primary="true" item="Grammar" subitem="BWS"/>
  <x:ref>OWS</x:ref>            = *( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; "optional" whitespace
  <x:ref>RWS</x:ref>            = 1*( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; "required" whitespace
  <x:ref>BWS</x:ref>            = <x:ref>OWS</x:ref>
                 ; "bad" whitespace
</artwork></figure>
</section>

<section title="Field Parsing" anchor="field.parsing">
<t>
   No whitespace is allowed between the header field-name and colon.
   In the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.
   Any received request message that contains whitespace between a header
   field-name and colon &MUST; be rejected with a response code of 400
   (Bad Request).  A proxy &MUST; remove any such whitespace from a response
   message before forwarding the message downstream.
</t>
<t>
   A field value &MAY; be preceded by optional whitespace (OWS); a single SP is
   preferred. The field value does not include any leading or trailing white
   space: OWS occurring before the first non-whitespace octet of the
   field value or after the last non-whitespace octet of the field value
   is ignored and &SHOULD; be removed before further processing (as this does
   not change the meaning of the header field). 
</t>
<t>
   Historically, HTTP header field values could be extended over multiple
   lines by preceding each extra line with at least one space or horizontal
   tab (obs-fold). This specification deprecates such line
   folding except within the message/http media type
   (<xref target="internet.media.type.message.http"/>).
   HTTP senders &MUST-NOT; produce messages that include line folding
   (i.e., that contain any field-value that matches the obs-fold rule) unless
   the message is intended for packaging within the message/http media type.
   HTTP recipients &SHOULD; accept line folding and replace any embedded
   obs-fold whitespace with either a single SP or a matching number of SP
   octets (to avoid buffer copying) prior to interpreting the field value or
   forwarding the message downstream.
</t>
<t>
   Historically, HTTP has allowed field content with text in the ISO-8859-1
   <xref target="ISO-8859-1"/> character encoding and supported other
   character sets only through use of <xref target="RFC2047"/> encoding.
   In practice, most HTTP header field values use only a subset of the
   US-ASCII character encoding <xref target="USASCII"/>. Newly defined
   header fields &SHOULD; limit their field values to US-ASCII octets.
   Recipients &SHOULD; treat other (obs-text) octets in field content as
   opaque data.
</t>
</section>

<section title="Field Length" anchor="field.length">
<t>
   HTTP does not place a pre-defined limit on the length of header fields,
   either in isolation or as a set. A server &MUST; be prepared to receive
   request header fields of unbounded length and respond with a 4xx status
   code if the received header field(s) would be longer than the server wishes
   to handle.
</t>
<t>
   A client that receives response headers that are longer than it wishes to
   handle can only treat it as a server error.
</t>
<t>
   Various ad-hoc limitations on header length are found in practice. It is
   &RECOMMENDED; that all HTTP senders and recipients support messages whose
   combined header fields have 4000 or more octets.
</t>
</section>

<section title="Field value components" anchor="field.components">
<t anchor="rule.token.separators">
  <x:anchor-alias value="tchar"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="special"/>
  <x:anchor-alias value="word"/>
   Many HTTP/1.1 header field values consist of words (token or quoted-string)
   separated by whitespace or special characters. These special characters
   &MUST; be in a quoted string to be used within a parameter value (as defined
   in <xref target="transfer.codings"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="word"/><iref primary="true" item="Grammar" subitem="token"/><iref primary="true" item="Grammar" subitem="tchar"/><iref primary="true" item="Grammar" subitem="special"/>
  <x:ref>word</x:ref>           = <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref>

  <x:ref>token</x:ref>          = 1*<x:ref>tchar</x:ref>
<!--
  IMPORTANT: when editing "tchar" make sure that "special" is updated accordingly!!!
 -->
  <x:ref>tchar</x:ref>          = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" 
                 / <x:ref>DIGIT</x:ref> / <x:ref>ALPHA</x:ref>
                 ; any <x:ref>VCHAR</x:ref>, except <x:ref>special</x:ref>

  <x:ref>special</x:ref>        = "(" / ")" / "&lt;" / ">" / "@" / ","
                 / ";" / ":" / "\" / DQUOTE / "/" / "[" 
                 / "]" / "?" / "=" / "{" / "}"
</artwork></figure>
<t anchor="rule.quoted-string">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="qdtext"/>
  <x:anchor-alias value="obs-text"/>
   A string of text is parsed as a single word if it is quoted using
   double-quote marks.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-string"/><iref primary="true" item="Grammar" subitem="qdtext"/><iref primary="true" item="Grammar" subitem="obs-text"/>
  <x:ref>quoted-string</x:ref>  = <x:ref>DQUOTE</x:ref> *( <x:ref>qdtext</x:ref> / <x:ref>quoted-pair</x:ref> ) <x:ref>DQUOTE</x:ref>
  <x:ref>qdtext</x:ref>         = <x:ref>OWS</x:ref> / %x21 / %x23-5B / %x5D-7E / <x:ref>obs-text</x:ref>
  <x:ref>obs-text</x:ref>       = %x80-FF
</artwork></figure>
<t anchor="rule.quoted-pair">
  <x:anchor-alias value="quoted-pair"/>
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within quoted-string constructs:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-pair"/>
  <x:ref>quoted-pair</x:ref>    = "\" ( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> ) 
</artwork></figure>
<t>
   Recipients that process the value of the quoted-string &MUST; handle a
   quoted-pair as if it were replaced by the octet following the backslash. 
</t>
<t>
   Senders &SHOULD-NOT; escape octets in quoted-strings that do not require
   escaping (i.e., other than DQUOTE and the backslash octet).
</t>
<t anchor="rule.comment">
  <x:anchor-alias value="comment"/>
  <x:anchor-alias value="ctext"/>
   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="comment"/><iref primary="true" item="Grammar" subitem="ctext"/>
  <x:ref>comment</x:ref>        = "(" *( <x:ref>ctext</x:ref> / <x:ref>quoted-cpair</x:ref> / <x:ref>comment</x:ref> ) ")"
  <x:ref>ctext</x:ref>          = <x:ref>OWS</x:ref> / %x21-27 / %x2A-5B / %x5D-7E / <x:ref>obs-text</x:ref>
</artwork></figure>
<t anchor="rule.quoted-cpair">
  <x:anchor-alias value="quoted-cpair"/>
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within comment constructs:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-cpair"/>
  <x:ref>quoted-cpair</x:ref>   = "\" ( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> ) 
</artwork></figure>
<t>
   Senders &SHOULD-NOT; escape octets in comments that do not require escaping
   (i.e., other than the backslash octet "\" and the parentheses "(" and ")").
</t>
</section>

<section title="ABNF list extension: #rule" anchor="abnf.extension">
<t>
  A #rule extension to the ABNF rules of <xref target="RFC5234"/> is used to
  improve readability in the definitions of some header field values.
</t>
<t>
  A construct "#" is defined, similar to "*", for defining comma-delimited
  lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating
  at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single
  comma (",") and optional whitespace (OWS).   
</t>
<figure><preamble>
  Thus,
</preamble><artwork type="example">
  1#element =&gt; element *( OWS "," OWS element )
</artwork></figure>
<figure><preamble>
  and:
</preamble><artwork type="example">
  #element =&gt; [ 1#element ]
</artwork></figure>
<figure><preamble>
  and for n &gt;= 1 and m &gt; 1:
</preamble><artwork type="example">
  &lt;n&gt;#&lt;m&gt;element =&gt; element &lt;n-1&gt;*&lt;m-1&gt;( OWS "," OWS element )
</artwork></figure>
<t>
  For compatibility with legacy list rules, recipients &SHOULD; accept empty
  list elements. In other words, consumers would follow the list productions:
</t>
<figure><artwork type="example">
  #element =&gt; [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
  
  1#element =&gt; *( "," OWS ) element *( OWS "," [ OWS element ] )
</artwork></figure>
<t>
  Note that empty elements do not contribute to the count of elements present,
  though.
</t>
<t>
  For example, given these ABNF productions: 
</t>
<figure><artwork type="example">
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see <xref target="field.components"/> 
</artwork></figure>
<t>
  Then these are valid values for example-list (not including the double
  quotes, which are present for delimitation only):
</t>
<figure><artwork type="example">
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie   "
</artwork></figure>
<t>
  But these values would be invalid, as at least one non-empty element is
  required:
</t>
<figure><artwork type="example">
  ""
  ","
  ",   ,"
</artwork></figure>
<t>
  <xref target="collected.abnf"/> shows the collected ABNF, with the list rules
  expanded as explained above.
</t>
</section>
</section>

<section title="Message Body" anchor="message.body">
  <x:anchor-alias value="message-body"/>
<t>
   The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in <xref target="header.transfer-encoding"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="message-body"/>
  <x:ref>message-body</x:ref> = *OCTET
</artwork></figure>
<t>
   The rules for when a message body is allowed in a message differ for
   requests and responses.
</t>
<t>
   The presence of a message body in a request is signaled by a
   a Content-Length or Transfer-Encoding header field.
   Request message framing is independent of method semantics,
   even if the method does not define any use for a message body.
</t>
<t>
   The presence of a message body in a response depends on both
   the request method to which it is responding and the response
   status code (<xref target="status-code"/>).
   Responses to the HEAD request method never include a message body
   because the associated response header fields (e.g., Transfer-Encoding,
   Content-Length, etc.) only indicate what their values would have been
   if the request method had been GET.
   Successful (2xx) responses to CONNECT switch to tunnel mode instead of
   having a message body.
   All 1xx (Informational), <x:ref>204 (No Content)</x:ref>, and <x:ref>304
   (Not Modified)</x:ref> responses &MUST-NOT; include a message body.
   All other responses do include a message body, although the body
   &MAY; be of zero length. (See &status-codes; and &status-304;.)
</t>

<section title="Transfer-Encoding" anchor="header.transfer-encoding">
  <iref primary="true" item="Transfer-Encoding header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Transfer-Encoding" x:for-anchor=""/>
  <x:anchor-alias value="Transfer-Encoding"/>
<t>
   When one or more transfer codings are applied to a payload body in order
   to form the message body, a Transfer-Encoding header field &MUST; be sent
   in the message and &MUST; contain the list of corresponding
   transfer-coding names in the same order that they were applied.
   Transfer codings are defined in <xref target="transfer.codings"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Transfer-Encoding"/>
  <x:ref>Transfer-Encoding</x:ref> = 1#<x:ref>transfer-coding</x:ref>
</artwork></figure>
<t>
   Transfer-Encoding is analogous to the Content-Transfer-Encoding field of
   MIME, which was designed to enable safe transport of binary data over a
   7-bit transport service (<xref target="RFC2045" x:fmt="," x:sec="6"/>).
   However, safe transport has a different focus for an 8bit-clean transfer
   protocol. In HTTP's case, Transfer-Encoding is primarily intended to
   accurately delimit a dynamically generated payload and to distinguish
   payload encodings that are only applied for transport efficiency or
   security from those that are characteristics of the target resource.
</t>
<t>
   The "chunked" transfer-coding (<xref target="chunked.encoding"/>)
   &MUST; be implemented by all HTTP/1.1 recipients because it plays a
   crucial role in delimiting messages when the payload body size is not
   known in advance.
   When the "chunked" transfer-coding is used, it &MUST; be the last
   transfer-coding applied to form the message body and &MUST-NOT;
   be applied more than once in a message body.
   If any transfer-coding is applied to a request payload body,
   the final transfer-coding applied &MUST; be "chunked".
   If any transfer-coding is applied to a response payload body, then either
   the final transfer-coding applied &MUST; be "chunked" or
   the message &MUST; be terminated by closing the connection.
</t>
<figure><preamble>
   For example,
</preamble><artwork type="example">
  Transfer-Encoding: gzip, chunked
</artwork><postamble>
   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.
</postamble></figure>
<t>
   If more than one Transfer-Encoding header field is present in a message,
   the multiple field-values &MUST; be combined into one field-value,
   according to the algorithm defined in <xref target="header.fields"/>,
   before determining the message body length.
</t>
<t>
   Unlike Content-Encoding (&content-codings;), Transfer-Encoding is a
   property of the message, not of the payload, and thus &MAY; be added or
   removed by any implementation along the request/response chain.
   Additional information about the encoding parameters &MAY; be provided
   by other header fields not defined by this specification.
</t>
<t>
   Transfer-Encoding &MAY; be sent in a response to a HEAD request or in a
   <x:ref>304 (Not Modified)</x:ref> response (&status-304;) to a GET request,
   neither of which includes a message body,
   to indicate that the origin server would have applied a transfer coding
   to the message body if the request had been an unconditional GET.
   This indication is not required, however, because any recipient on
   the response chain (including the origin server) can remove transfer
   codings when they are not needed.
</t>
<t>
   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed that
   implementations advertising only HTTP/1.0 support will not understand
   how to process a transfer-encoded payload.
   A client &MUST-NOT; send a request containing Transfer-Encoding unless it
   knows the server will handle HTTP/1.1 (or later) requests; such knowledge
   might be in the form of specific user configuration or by remembering the
   version of a prior received response.
   A server &MUST-NOT; send a response containing Transfer-Encoding unless
   the corresponding request indicates HTTP/1.1 (or later).
</t>
<t>
   A server that receives a request message with a transfer-coding it does
   not understand &SHOULD; respond with <x:ref>501 (Not Implemented)</x:ref> and then
   close the connection.
</t>
</section>

<section title="Content-Length" anchor="header.content-length">
  <iref primary="true" item="Content-Length header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Content-Length" x:for-anchor=""/>
  <x:anchor-alias value="Content-Length"/>
<t>
   When a message does not have a Transfer-Encoding header field and the
   payload body length can be determined prior to being transferred, a
   Content-Length header field &SHOULD; be sent to indicate the length of the
   payload body that is either present as the message body, for requests
   and non-HEAD responses other than 304, or would have been present had
   the request been an unconditional GET.  The length is expressed as a
   decimal number of octets.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Length"/>
  <x:ref>Content-Length</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   An example is
</t>
<figure><artwork type="example">
  Content-Length: 3495
</artwork></figure>
<t>
   In the case of a response to a HEAD request, Content-Length indicates
   the size of the payload body (without any potential transfer-coding)
   that would have been sent had the request been a GET.
   In the case of a <x:ref>304 (Not Modified)</x:ref> response (&status-304;)
   to a GET request, Content-Length indicates the size of the payload body (without
   any potential transfer-coding) that would have been sent in a <x:ref>200 (OK)</x:ref>
   response.
</t>
<t>
   HTTP's use of Content-Length is significantly different from how it is
   used in MIME, where it is an optional field used only within the
   "message/external-body" media-type.
</t>
<t>
   Any Content-Length field value greater than or equal to zero is valid.
   Since there is no predefined limit to the length of an HTTP payload,
   recipients &SHOULD; anticipate potentially large decimal numerals and
   prevent parsing errors due to integer conversion overflows
   (<xref target="attack.protocol.element.size.overflows"/>).
</t>
<t>
   If a message is received that has multiple Content-Length header fields
   (<xref target="header.content-length"/>) with field-values consisting
   of the same decimal value, or a single Content-Length header field with
   a field value containing a list of identical decimal values (e.g.,
   "Content-Length: 42, 42"), indicating that duplicate Content-Length
   header fields have been generated or combined by an upstream message
   processor, then the recipient &MUST; either reject the message as invalid
   or replace the duplicated field-values with a single valid Content-Length
   field containing that decimal value prior to determining the message body
   length.
</t>
</section>

<section title="Message Body Length" anchor="message.body.length">
<t>
   The length of a message body is determined by one of the following
   (in order of precedence):
</t>
<t>
  <list style="numbers">
    <x:lt><t>
     Any response to a HEAD request and any response with a status
     code of 100-199, 204, or 304 is always terminated by the first
     empty line after the header fields, regardless of the header
     fields present in the message, and thus cannot contain a message body.
    </t></x:lt>
    <x:lt><t>
     Any successful (2xx) response to a CONNECT request implies that the
     connection will become a tunnel immediately after the empty line that
     concludes the header fields.  A client &MUST; ignore any Content-Length
     or Transfer-Encoding header fields received in such a message.
    </t></x:lt>
    <x:lt><t>
     If a Transfer-Encoding header field is present
     and the "chunked" transfer-coding (<xref target="chunked.encoding"/>)
     is the final encoding, the message body length is determined by reading
     and decoding the chunked data until the transfer-coding indicates the
     data is complete.
    </t>
    <t>
     If a Transfer-Encoding header field is present in a response and the
     "chunked" transfer-coding is not the final encoding, the message body
     length is determined by reading the connection until it is closed by
     the server.
     If a Transfer-Encoding header field is present in a request and the
     "chunked" transfer-coding is not the final encoding, the message body
     length cannot be determined reliably; the server &MUST; respond with
     the <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
    </t>
    <t>
     If a message is received with both a Transfer-Encoding header field
     and a Content-Length header field, the Transfer-Encoding overrides
     the Content-Length.
     Such a message might indicate an attempt to perform request or response
     smuggling (bypass of security-related checks on message routing or content)
     and thus ought to be handled as an error.  The provided Content-Length &MUST;
     be removed, prior to forwarding the message downstream, or replaced with
     the real message body length after the transfer-coding is decoded.
    </t></x:lt>
    <x:lt><t>
     If a message is received without Transfer-Encoding and with either
     multiple Content-Length header fields having differing field-values or
     a single Content-Length header field having an invalid value, then the
     message framing is invalid and &MUST; be treated as an error to
     prevent request or response smuggling.
     If this is a request message, the server &MUST; respond with
     a <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
     If this is a response message received by a proxy, the proxy
     &MUST; discard the received response, send a <x:ref>502 (Bad Gateway)</x:ref>
     status code as its downstream response, and then close the connection.
     If this is a response message received by a user-agent, it &MUST; be
     treated as an error by discarding the message and closing the connection.
    </t></x:lt>
    <x:lt><t>
     If a valid Content-Length header field 
     is present without Transfer-Encoding, its decimal value defines the
     message body length in octets.  If the actual number of octets sent in
     the message is less than the indicated Content-Length, the recipient
     &MUST; consider the message to be incomplete and treat the connection
     as no longer usable.
     If the actual number of octets sent in the message is more than the indicated
     Content-Length, the recipient &MUST; only process the message body up to the
     field value's number of octets; the remainder of the message &MUST; either
     be discarded or treated as the next message in a pipeline.  For the sake of
     robustness, a user-agent &MAY; attempt to detect and correct such an error
     in message framing if it is parsing the response to the last request on
     a connection and the connection has been closed by the server.
    </t></x:lt>
    <x:lt><t>
     If this is a request message and none of the above are true, then the
     message body length is zero (no message body is present).
    </t></x:lt>
    <x:lt><t>
     Otherwise, this is a response message without a declared message body
     length, so the message body length is determined by the number of octets
     received prior to the server closing the connection.
    </t></x:lt>
  </list>
</t>
<t>
   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially-received message interrupted
   by network failure, implementations &SHOULD; use encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
</t>
<t>
   A server &MAY; reject a request that contains a message body but
   not a Content-Length by responding with <x:ref>411 (Length Required)</x:ref>.
</t>
<t>
   Unless a transfer-coding other than "chunked" has been applied,
   a client that sends a request containing a message body &SHOULD;
   use a valid Content-Length header field if the message body length
   is known in advance, rather than the "chunked" encoding, since some
   existing services respond to "chunked" with a <x:ref>411 (Length Required)</x:ref>
   status code even though they understand the chunked encoding.  This
   is typically because such services are implemented via a gateway that
   requires a content-length in advance of being called and the server
   is unable or unwilling to buffer the entire request before processing.
</t>
<t>
   A client that sends a request containing a message body &MUST; include a
   valid Content-Length header field if it does not know the server will
   handle HTTP/1.1 (or later) requests; such knowledge can be in the form
   of specific user configuration or by remembering the version of a prior
   received response.
</t>
</section>
</section>

<section anchor="incomplete.messages" title="Handling Incomplete Messages">
<t>
   Request messages that are prematurely terminated, possibly due to a
   cancelled connection or a server-imposed time-out exception, &MUST;
   result in closure of the connection; sending an HTTP/1.1 error response
   prior to closing the connection is &OPTIONAL;.
</t>
<t>
   Response messages that are prematurely terminated, usually by closure
   of the connection prior to receiving the expected number of octets or by
   failure to decode a transfer-encoded message body, &MUST; be recorded
   as incomplete.  A response that terminates in the middle of the header
   block (before the empty line is received) cannot be assumed to convey the
   full semantics of the response and &MUST; be treated as an error.
</t>
<t>
   A message body that uses the chunked transfer encoding is
   incomplete if the zero-sized chunk that terminates the encoding has not
   been received.  A message that uses a valid Content-Length is incomplete
   if the size of the message body received (in octets) is less than the
   value given by Content-Length.  A response that has neither chunked
   transfer encoding nor Content-Length is terminated by closure of the
   connection, and thus is considered complete regardless of the number of
   message body octets received, provided that the header block was received
   intact.
</t>
<t>
   A user agent &MUST-NOT; render an incomplete response message body as if
   it were complete (i.e., some indication needs to be given to the user that an
   error occurred).  Cache requirements for incomplete responses are defined
   in &cache-incomplete;.
</t>
<t>
   A server &MUST; read the entire request message body or close
   the connection after sending its response, since otherwise the
   remaining data on a persistent connection would be misinterpreted
   as the next request.  Likewise,
   a client &MUST; read the entire response message body if it intends
   to reuse the same connection for a subsequent request.  Pipelining
   multiple requests on a connection is described in <xref target="pipelining"/>.
</t>
</section>

<section title="Message Parsing Robustness" anchor="message.robustness">
<t>
   Older HTTP/1.0 client implementations might send an extra CRLF
   after a POST request as a lame workaround for some early server
   applications that failed to read message body content that was
   not terminated by a line-ending. An HTTP/1.1 client &MUST-NOT;
   preface or follow a request with an extra CRLF.  If terminating
   the request message body with a line-ending is desired, then the
   client &MUST; include the terminating CRLF octets as part of the
   message body length. 
</t>
<t>
   In the interest of robustness, servers &SHOULD; ignore at least one
   empty line received where a request-line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it &SHOULD; ignore the CRLF.
   Likewise, although the line terminator for the start-line and header
   fields is the sequence CRLF, we recommend that recipients recognize a
   single LF as a line terminator and ignore any CR.
</t>
<t>
   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the
   server &MUST; respond with an HTTP/1.1 <x:ref>400 (Bad Request)</x:ref> response.  
</t>
</section>
</section>

<section title="Transfer Codings" anchor="transfer.codings">
  <x:anchor-alias value="transfer-coding"/>
  <x:anchor-alias value="transfer-extension"/>
<t>
   Transfer-coding values are used to indicate an encoding
   transformation that has been, can be, or might need to be applied to a
   payload body in order to ensure "safe transport" through the network.
   This differs from a content coding in that the transfer-coding is a
   property of the message rather than a property of the representation
   that is being transferred.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-coding"/><iref primary="true" item="Grammar" subitem="transfer-extension"/>
  <x:ref>transfer-coding</x:ref>    = "chunked" ; <xref target="chunked.encoding"/>
                     / "compress" ; <xref target="compress.coding"/>
                     / "deflate" ; <xref target="deflate.coding"/>
                     / "gzip" ; <xref target="gzip.coding"/>
                     / <x:ref>transfer-extension</x:ref>
  <x:ref>transfer-extension</x:ref> = <x:ref>token</x:ref> *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>transfer-parameter</x:ref> )
</artwork></figure>
<t anchor="rule.parameter">
  <x:anchor-alias value="attribute"/>
  <x:anchor-alias value="transfer-parameter"/>
  <x:anchor-alias value="value"/>
   Parameters are in the form of attribute/value pairs.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-parameter"/><iref primary="true" item="Grammar" subitem="attribute"/><iref primary="true" item="Grammar" subitem="value"/><iref primary="true" item="Grammar" subitem="date2"/><iref primary="true" item="Grammar" subitem="date3"/>
  <x:ref>transfer-parameter</x:ref> = <x:ref>attribute</x:ref> <x:ref>BWS</x:ref> "=" <x:ref>BWS</x:ref> <x:ref>value</x:ref>
  <x:ref>attribute</x:ref>          = <x:ref>token</x:ref>
  <x:ref>value</x:ref>              = <x:ref>word</x:ref>
</artwork></figure>
<t>
   All transfer-coding values are case-insensitive.
   The HTTP Transfer Coding registry is defined in
   <xref target="transfer.coding.registry"/>.
   HTTP/1.1 uses transfer-coding values in the TE header field
   (<xref target="header.te"/>) and in the Transfer-Encoding header field
   (<xref target="header.transfer-encoding"/>).
</t>

<section title="Chunked Transfer Coding" anchor="chunked.encoding">
  <iref item="chunked (Coding Format)"/>
  <iref item="Coding Format" subitem="chunked"/>
  <x:anchor-alias value="chunk"/>
  <x:anchor-alias value="chunked-body"/>
  <x:anchor-alias value="chunk-data"/>
  <x:anchor-alias value="chunk-ext"/>
  <x:anchor-alias value="chunk-ext-name"/>
  <x:anchor-alias value="chunk-ext-val"/>
  <x:anchor-alias value="chunk-size"/>
  <x:anchor-alias value="last-chunk"/>
  <x:anchor-alias value="trailer-part"/>
  <x:anchor-alias value="quoted-str-nf"/>
  <x:anchor-alias value="qdtext-nf"/>
<t>
   The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an &OPTIONAL; trailer containing header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="chunked-body"/><iref primary="true" item="Grammar" subitem="chunk"/><iref primary="true" item="Grammar" subitem="chunk-size"/><iref primary="true" item="Grammar" subitem="last-chunk"/><iref primary="true" item="Grammar" subitem="chunk-ext"/><iref primary="true" item="Grammar" subitem="chunk-ext-name"/><iref primary="true" item="Grammar" subitem="chunk-ext-val"/><iref primary="true" item="Grammar" subitem="chunk-data"/><iref primary="true" item="Grammar" subitem="trailer-part"/><iref primary="true" item="Grammar" subitem="quoted-str-nf"/><iref primary="true" item="Grammar" subitem="qdtext-nf"/>
  <x:ref>chunked-body</x:ref>   = *<x:ref>chunk</x:ref>
                   <x:ref>last-chunk</x:ref>
                   <x:ref>trailer-part</x:ref>
                   <x:ref>CRLF</x:ref>
  
  <x:ref>chunk</x:ref>          = <x:ref>chunk-size</x:ref> [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
                   <x:ref>chunk-data</x:ref> <x:ref>CRLF</x:ref>
  <x:ref>chunk-size</x:ref>     = 1*<x:ref>HEXDIG</x:ref>
  <x:ref>last-chunk</x:ref>     = 1*("0") [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
  
  <x:ref>chunk-ext</x:ref>      = *( ";" <x:ref>chunk-ext-name</x:ref> [ "=" <x:ref>chunk-ext-val</x:ref> ] )
  <x:ref>chunk-ext-name</x:ref> = <x:ref>token</x:ref>
  <x:ref>chunk-ext-val</x:ref>  = <x:ref>token</x:ref> / <x:ref>quoted-str-nf</x:ref>
  <x:ref>chunk-data</x:ref>     = 1*<x:ref>OCTET</x:ref> ; a sequence of chunk-size octets
  <x:ref>trailer-part</x:ref>   = *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
  
  <x:ref>quoted-str-nf</x:ref>  = <x:ref>DQUOTE</x:ref> *( <x:ref>qdtext-nf</x:ref> / <x:ref>quoted-pair</x:ref> ) <x:ref>DQUOTE</x:ref>
                 ; like <x:ref>quoted-string</x:ref>, but disallowing line folding
  <x:ref>qdtext-nf</x:ref>      = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / %x21 / %x23-5B / %x5D-7E / <x:ref>obs-text</x:ref>
</artwork></figure>
<t>
   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.
</t>
<t>
   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   <xref target="header.trailer"/>).
</t>
<t>
   A server using chunked transfer-coding in a response &MUST-NOT; use the
   trailer for any header fields unless at least one of the following is
   true:
  <list style="numbers">
    <t>the request included a TE header field that indicates "trailers" is
     acceptable in the transfer-coding of the  response, as described in
     <xref target="header.te"/>; or,</t>
     
    <t>the trailer fields consist entirely of optional metadata, and the
    recipient could use the message (in a manner acceptable to the server where
    the field originated) without receiving it. In other words, the server that
    generated the header (often but not always the origin server) is willing to
    accept the possibility that the trailer fields might be silently discarded
    along the path to the client.</t>
  </list>
</t>
<t>
   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   conformance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.
</t>
<t>
   A process for decoding the "chunked" transfer-coding
   can be represented in pseudo-code as:
</t>
<figure><artwork type="code">
  length := 0
  read chunk-size, chunk-ext (if any) and CRLF
  while (chunk-size &gt; 0) {
     read chunk-data and CRLF
     append chunk-data to decoded-body
     length := length + chunk-size
     read chunk-size and CRLF
  }
  read header-field
  while (header-field not empty) {
     append header-field to existing header fields
     read header-field
  }
  Content-Length := length
  Remove "chunked" from Transfer-Encoding
</artwork></figure>
<t>
   All HTTP/1.1 applications &MUST; be able to receive and decode the
   "chunked" transfer-coding and &MUST; ignore chunk-ext extensions
   they do not understand.
</t>
<t>
   Use of chunk-ext extensions by senders is deprecated; they &SHOULD-NOT; be
   sent and definition of new chunk-extensions is discouraged. 
</t>
</section>

<section title="Compression Codings" anchor="compression.codings">
<t>
   The codings defined below can be used to compress the payload of a
   message.
</t>
<x:note><t>
   &Note; Use of program names for the identification of encoding formats
   is not desirable and is discouraged for future encodings. Their
   use here is representative of historical practice, not good
   design.
</t></x:note>
<x:note><t>
   &Note; For compatibility with previous implementations of HTTP,
   applications &SHOULD; consider "x-gzip" and "x-compress" to be
   equivalent to "gzip" and "compress" respectively.
</t></x:note>

<section title="Compress Coding" anchor="compress.coding">
<iref item="compress (Coding Format)"/>
<iref item="Coding Format" subitem="compress"/>
<t>
   The "compress" format is produced by the common UNIX file compression
   program "compress". This format is an adaptive Lempel-Ziv-Welch
   coding (LZW).
</t>
</section>

<section title="Deflate Coding" anchor="deflate.coding">
<iref item="deflate (Coding Format)"/>
<iref item="Coding Format" subitem="deflate"/>
<t>
   The "deflate" format is defined as the "deflate" compression mechanism
   (described in <xref target="RFC1951"/>) used inside the "zlib"
   data format (<xref target="RFC1950"/>).
</t>
<x:note>
  <t>
    &Note; Some incorrect implementations send the "deflate" 
    compressed data without the zlib wrapper.
   </t>
</x:note>
</section>

<section title="Gzip Coding" anchor="gzip.coding">
<iref item="gzip (Coding Format)"/>
<iref item="Coding Format" subitem="gzip"/>
<t>
   The "gzip" format is produced by the file compression program
   "gzip" (GNU zip), as described in <xref target="RFC1952"/>. This format is a
   Lempel-Ziv coding (LZ77) with a 32 bit CRC.
</t>
</section>

</section>

<section title="TE" anchor="header.te">
  <iref primary="true" item="TE header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="TE" x:for-anchor=""/>
  <x:anchor-alias value="TE"/>
  <x:anchor-alias value="t-codings"/>
  <x:anchor-alias value="te-params"/>
  <x:anchor-alias value="te-ext"/>
<t>
   The "TE" header field indicates what extension transfer-codings
   the client is willing to accept in the response, and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding.
</t>
<t>
   Its value consists of the keyword "trailers" and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in <xref target="transfer.codings"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="TE"/><iref primary="true" item="Grammar" subitem="t-codings"/><iref primary="true" item="Grammar" subitem="te-params"/><iref primary="true" item="Grammar" subitem="te-ext"/>
  <x:ref>TE</x:ref>        = #<x:ref>t-codings</x:ref>
  <x:ref>t-codings</x:ref> = "trailers" / ( <x:ref>transfer-extension</x:ref> [ <x:ref>te-params</x:ref> ] )
  <x:ref>te-params</x:ref> = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>qvalue</x:ref> *( <x:ref>te-ext</x:ref> )
  <x:ref>te-ext</x:ref>    = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>token</x:ref> [ "=" <x:ref>word</x:ref> ]
</artwork></figure>
<t>
   The presence of the keyword "trailers" indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in <xref target="chunked.encoding"/>. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.
</t>
<t>
   Examples of its use are:
</t>
<figure><artwork type="example">
  TE: deflate
  TE:
  TE: trailers, deflate;q=0.5
</artwork></figure>
<t>
   The TE header field only applies to the immediate connection.
   Therefore, the keyword &MUST; be supplied within a Connection header
   field (<xref target="header.connection"/>) whenever TE is present in an HTTP/1.1 message.
</t>
<t>
   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:
  <list style="numbers">
    <x:lt>
      <t>The "chunked" transfer-coding is always acceptable. If the
         keyword "trailers" is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.
      </t><t>
         &Note; HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.</t>
    </x:lt>
    <x:lt>
      <t>If the transfer-coding being tested is one of the transfer-codings
         listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in <xref target="quality.values"/>, a
         qvalue of 0 means "not acceptable".)</t>
    </x:lt>
    <x:lt>
      <t>If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The "chunked" transfer-coding always has a qvalue
         of 1.</t>
    </x:lt>
  </list>
</t>
<t>
   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer-coding is "chunked". A message with no transfer-coding is
   always acceptable.
</t>

<section title="Quality Values" anchor="quality.values">
  <x:anchor-alias value="qvalue"/>
<t>
   Both transfer codings (TE request header field, <xref target="header.te"/>)
   and content negotiation (&content.negotiation;) use short "floating point"
   numbers to indicate the relative importance ("weight") of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is "not acceptable" for the client. HTTP/1.1
   applications &MUST-NOT; generate more than three digits after the
   decimal point. User configuration of these values &SHOULD; also be
   limited in this fashion.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="qvalue"/>
  <x:ref>qvalue</x:ref>         = ( "0" [ "." 0*3<x:ref>DIGIT</x:ref> ] )
                 / ( "1" [ "." 0*3("0") ] )
</artwork></figure>
<x:note>
  <t>
     &Note; "Quality values" is a misnomer, since these values merely represent
     relative degradation in desired quality.
  </t>
</x:note>
</section>
</section>

<section title="Trailer" anchor="header.trailer">
  <iref primary="true" item="Trailer header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Trailer" x:for-anchor=""/>
  <x:anchor-alias value="Trailer"/>
<t>
   The "Trailer" header field indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Trailer"/>
  <x:ref>Trailer</x:ref> = 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
   An HTTP/1.1 message &SHOULD; include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.
</t>
<t>
   If no Trailer header field is present, the trailer &SHOULD-NOT;  include
   any header fields. See <xref target="chunked.encoding"/> for restrictions on the use of
   trailer fields in a "chunked" transfer-coding.
</t>
<t>
   Message header fields listed in the Trailer header field &MUST-NOT;
   include the following header fields:
  <list style="symbols">
    <t>Transfer-Encoding</t>
    <t>Content-Length</t>
    <t>Trailer</t>
  </list>
</t>
</section>
</section>

<section title="Message Routing" anchor="message.routing">
<t>
   HTTP request message routing is determined by each client based on the
   target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the client.
</t>

<section title="Identifying a Target Resource" anchor="target-resource">
  <iref primary="true" item="target resource"/>
  <iref primary="true" item="target URI"/>
<t>
   HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web browsers.
</t>
<t>
   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined in
   <xref target="Part2"/>, and a target resource upon which to apply those
   semantics.  A URI reference (<xref target="uri"/>) is typically used as
   an identifier for the "target resource", which a user agent would resolve
   to its absolute form in order to obtain the "target URI".  The target URI
   excludes the reference's fragment identifier component, if any,
   since fragment identifiers are reserved for client-side processing
   (<xref target="RFC3986" x:fmt="," x:sec="3.5"/>).
</t>
<t>
   HTTP intermediaries obtain the request semantics and target URI
   from the request-line of an incoming request message.
</t>
</section>

<section title="Connecting Inbound" anchor="connecting.inbound">
<t>
   Once the target URI is determined, a client needs to decide whether
   a network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.
</t>
<t>
   If the client has a response cache and the request semantics can be
   satisfied by a cache (<xref target="Part6"/>), then the request is
   usually directed to the cache first.
</t>
<t>
   If the request is not satisfied by a cache, then a typical client will
   check its configuration to determine whether a proxy is to be used to
   satisfy the request.  Proxy configuration is implementation-dependent,
   but is often based on URI prefix matching, selective authority matching,
   or both, and the proxy itself is usually identified by an "http" or
   "https" URI.  If a proxy is applicable, the client connects inbound by 
   establishing (or reusing) a connection to that proxy.
</t>
<t>
   If no proxy is applicable, a typical client will invoke a handler routine,
   usually specific to the target URI's scheme, to connect directly
   to an authority for the target resource.  How that is accomplished is
   dependent on the target URI scheme and defined by its associated
   specification, similar to how this specification defines origin server
   access for resolution of the "http" (<xref target="http.uri"/>) and
   "https" (<xref target="https.uri"/>) schemes.
</t>
</section>

<section title="Request Target" anchor="request-target">
<t>
   Once an inbound connection is obtained
   (<xref target="connection.management"/>),
   the client sends an HTTP request message (<xref target="http.message"/>)
   with a request-target derived from the target URI.
   There are four distinct formats for the request-target, depending on both
   the method being requested and whether the request is to a proxy.
</t>   
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-target"/><iref primary="true" item="Grammar" subitem="origin-form"/><iref primary="true" item="Grammar" subitem="absolute-form"/><iref primary="true" item="Grammar" subitem="authority-form"/><iref primary="true" item="Grammar" subitem="asterisk-form"/>
  <x:ref>request-target</x:ref> = <x:ref>origin-form</x:ref>
                 / <x:ref>absolute-form</x:ref>
                 / <x:ref>authority-form</x:ref>
                 / <x:ref>asterisk-form</x:ref>

  <x:ref>origin-form</x:ref>    = <x:ref>path-absolute</x:ref> [ "?" <x:ref>query</x:ref> ]
  <x:ref>absolute-form</x:ref>  = <x:ref>absolute-URI</x:ref>
  <x:ref>authority-form</x:ref> = <x:ref>authority</x:ref>
  <x:ref>asterisk-form</x:ref>  = "*"
</artwork></figure>
<t anchor="origin-form"><iref item="origin-form (of request-target)"/>
   The most common form of request-target is the origin-form.
   When making a request directly to an origin server, other than a CONNECT
   or server-wide OPTIONS request (as detailed below),
   a client &MUST; send only the absolute path and query components of
   the target URI as the request-target.
   If the target URI's path component is empty, then the client &MUST; send
   "/" as the path within the origin-form of request-target.
   A Host header field is also sent, as defined in
   <xref target="header.host"/>, containing the target URI's
   authority component (excluding any userinfo).
</t>
<t>
   For example, a client wishing to retrieve a representation of the resource
   identified as
</t>
<figure><artwork x:indent-with="  " type="example">
http://www.example.org/where?q=now
</artwork></figure>
<t>
   directly from the origin server would open (or reuse) a TCP connection
   to port 80 of the host "www.example.org" and send the lines:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /where?q=now HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   followed by the remainder of the request message.
</t>
<t anchor="absolute-form"><iref item="absolute-form (of request-target)"/>
   When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client &MUST; send the target URI
   in absolute-form as the request-target.
   The proxy is requested to either service that request from a valid cache,
   if possible, or make the same request on the client's behalf to either
   the next inbound proxy server or directly to the origin server indicated
   by the request-target.  Requirements on such "forwarding" of messages are
   defined in <xref target="intermediary.forwarding"/>.
</t>
<t>
   An example absolute-form of request-line would be:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</artwork></figure>
<t>
   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, HTTP/1.1 servers &MUST; accept the absolute-form
   in requests, even though HTTP/1.1 clients will only send them in requests
   to proxies.
</t>
<t anchor="authority-form"><iref item="authority-form (of request-target)"/>
   The authority-form of request-target is only used for CONNECT requests
   (&CONNECT;).  When making a CONNECT request to establish a tunnel through
   one or more proxies, a client &MUST; send only the target URI's
   authority component (excluding any userinfo) as the request-target.
   For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
CONNECT www.example.com:80 HTTP/1.1
</artwork></figure>
<t anchor="asterisk-form"><iref item="asterisk-form (of request-target)"/>
   The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&OPTIONS;).  When a client wishes to request OPTIONS
   for the server as a whole, as opposed to a specific named resource of
   that server, the client &MUST; send only "*" (%x2A) as the request-target.
   For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
</artwork></figure>
<t>
   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query component,
   then the last proxy on the request chain &MUST; send a request-target
   of "*" when it forwards the request to the indicated origin server.
</t>
<figure><preamble>   
   For example, the request
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS http://www.example.org:8001 HTTP/1.1
</artwork></figure>
<figure><preamble>   
  would be forwarded by the final proxy as
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</artwork>
<postamble>
   after connecting to port 8001 of host "www.example.org".
</postamble>
</figure>
</section>

<section title="Host" anchor="header.host">
  <iref primary="true" item="Host header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Host" x:for-anchor=""/>
  <x:anchor-alias value="Host"/>
<t>
   The "Host" header field in a request provides the host and port
   information from the target URI, enabling the origin
   server to distinguish among resources while servicing requests
   for multiple host names on a single IP address.  Since the Host
   field-value is critical information for handling a request, it
   &SHOULD; be sent as the first header field following the request-line.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Host"/>
  <x:ref>Host</x:ref> = <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ; <xref target="http.uri"/>
</artwork></figure>
<t>
   A client &MUST; send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then
   the Host field-value &MUST; be identical to that authority component
   after excluding any userinfo (<xref target="http.uri"/>).
   If the authority component is missing or undefined for the target URI,
   then the Host header field &MUST; be sent with an empty field-value.
</t>
<t>
   For example, a GET request to the origin server for
   &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   The Host header field &MUST; be sent in an HTTP/1.1 request even
   if the request-target is in the absolute-form, since this
   allows the Host information to be forwarded through ancient HTTP/1.0
   proxies that might not have implemented Host.
</t>
<t>
   When an HTTP/1.1 proxy receives a request with an absolute-form of
   request-target, the proxy &MUST; ignore the received
   Host header field (if any) and instead replace it with the host
   information of the request-target.  If the proxy forwards the request,
   it &MUST; generate a new Host field-value based on the received
   request-target rather than forward the received Host field-value.
</t>
<t>
   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison
   a shared cache or redirect a request to an unintended server.
   An interception proxy is particularly vulnerable if it relies on
   the Host field-value for redirecting requests to internal
   servers, or for use as a cache key in a shared cache, without
   first verifying that the intercepted connection is targeting a
   valid IP address for that host.
</t>
<t>
   A server &MUST; respond with a <x:ref>400 (Bad Request)</x:ref> status code
   to any HTTP/1.1 request message that lacks a Host header field and
   to any request message that contains more than one Host header field
   or a Host header field with an invalid field-value.
</t>
</section>

<section title="Effective Request URI" anchor="effective.request.uri">
  <iref primary="true" item="effective request URI"/>
<t>
   A server that receives an HTTP request message &MUST; reconstruct
   the user agent's original target URI, based on the pieces of information
   learned from the request-target, Host, and connection context, in order
   to identify the intended target resource and properly service the request.
   The URI derived from this reconstruction process is referred to as the
   "effective request URI".
</t>
<t>
   For a user agent, the effective request URI is the target URI.
</t>
<t>
   If the request-target is in absolute-form, then the effective request URI
   is the same as the request-target.  Otherwise, the effective request URI
   is constructed as follows.
</t>
<t>
   If the request is received over an SSL/TLS-secured TCP connection,
   then the effective request URI's scheme is "https"; otherwise, the
   scheme is "http".
</t>
<t>
   If the request-target is in authority-form, then the effective
   request URI's authority component is the same as the request-target.
   Otherwise, if a Host header field is supplied with a non-empty field-value,
   then the authority component is the same as the Host field-value.
   Otherwise, the authority component is the concatenation of the default
   host name configured for the server, a colon (":"), and the connection's
   incoming TCP port number in decimal form.
</t>
<t>
   If the request-target is in authority-form or asterisk-form, then the
   effective request URI's combined path and query component is empty.
   Otherwise, the combined path and query component is the same as the
   request-target.
</t>
<t>
   The components of the effective request URI, once determined as above,
   can be combined into absolute-URI form by concatenating the scheme,
   "://", authority, and combined path and query component.
</t>
<figure>
<preamble>
   Example 1: the following message received over an insecure TCP connection
</preamble> 
<artwork type="example" x:indent-with="  ">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
http://www.example.org:8080/pub/WWW/TheProject.html
</artwork>
</figure>
<figure>
<preamble>
   Example 2: the following message received over an SSL/TLS-secured TCP
   connection
</preamble> 
<artwork type="example" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
https://www.example.org
</artwork>
</figure>
<t>
   An origin server that does not allow resources to differ by requested
   host &MAY; ignore the Host field-value and instead replace it with a
   configured server name when constructing the effective request URI.
</t>
<t>
   Recipients of an HTTP/1.0 request that lacks a Host header field &MAY;
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.
</t>
</section>

<section title="Intermediary Forwarding" anchor="intermediary.forwarding">
<t>
   As described in <xref target="intermediaries"/>, intermediaries can serve
   a variety of roles in the processing of HTTP requests and responses.
   Some intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.
   Since an HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an intermediary
   can enhance (or interfere) with either direction of the stream.
</t>
<t>
   In order to avoid request loops, a proxy that forwards requests to other
   proxies &MUST; be able to recognize and exclude all of its own server
   names, including any aliases, local variations, or literal IP addresses.
</t>
<t>
   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it &MAY; add its domain to the host name
   it received when forwarding the request.  A proxy &MUST-NOT; change the
   host name if it is a fully qualified domain name.
</t>
<t>
   A non-transforming proxy &MUST-NOT; rewrite the "path-absolute" and "query"
   parts of the received request-target when forwarding it to the next inbound
   server, except as noted above to replace an empty path with "/" or "*".
</t>
<t>
   Intermediaries that forward a message &MUST; implement the
   Connection header field as specified in <xref target="header.connection"/>.
</t>

<section title="End-to-end and Hop-by-hop Header Fields" anchor="end-to-end.and.hop-by-hop.header-fields">
<!--<t>
  <cref anchor="TODO-end-to-end" source="jre">
    Restored from <eref target="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-05#section-7.1"/>.
    See also <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60"/>.
  </cref>
</t>-->
<t>
   For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP header fields into two categories:
  <list style="symbols">
      <t>End-to-end header fields, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end header fields in
        responses &MUST; be stored as part of a cache entry and &MUST; be
        transmitted in any response formed from a cache entry.</t>

      <t>Hop-by-hop header fields, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.</t>
  </list>
</t>
<t>
   The following HTTP/1.1 header fields are hop-by-hop header fields:
  <list style="symbols">
      <t>Connection</t>
      <t>Keep-Alive</t>
      <t>Proxy-Authenticate</t>
      <t>Proxy-Authorization</t>
      <t>TE</t>
      <t>Trailer</t>
      <t>Transfer-Encoding</t>
      <t>Upgrade</t>
  </list>
</t>
<t>
   All other header fields defined by HTTP/1.1 are end-to-end header fields.
</t>
<t>
   Other hop-by-hop header fields &MUST; be listed in a Connection header field
   (<xref target="header.connection"/>).
</t>
</section>

<section title="Non-modifiable Header Fields" anchor="non-modifiable.header-fields">
<!--<t>
  <cref anchor="TODO-non-mod-headers" source="jre">
    Restored from <eref target="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-05#section-7.2"/>.
    See also <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60"/>.
  </cref>
</t>-->
<t>
   Some features of HTTP/1.1, such as Digest Authentication, depend on the
   value of certain end-to-end header fields. A non-transforming proxy &SHOULD-NOT;
   modify an end-to-end header field unless the definition of that header field requires
   or specifically allows that.
</t>
<t>
   A non-transforming proxy &MUST-NOT; modify any of the following fields in a
   request or response, and it &MUST-NOT; add any of these fields if not
   already present:
  <list style="symbols">
    <t>Allow</t>
    <t>Content-Location</t>
    <t>Content-MD5</t>
    <t>ETag</t>
    <t>Last-Modified</t>
    <t>Server</t>
  </list>
</t>
<t>
   A non-transforming proxy &MUST-NOT; modify any of the following fields in a
   response:
  <list style="symbols">
    <t>Expires</t>
  </list>
</t>
<t>
   but it &MAY; add any of these fields if not already present. If an
   Expires header field is added, it &MUST; be given a field-value identical to
   that of the Date header field in that response.
</t>
<t>
   A proxy &MUST-NOT; modify or add any of the following fields in a
   message that contains the no-transform cache-control directive, or in
   any request:
  <list style="symbols">
    <t>Content-Encoding</t>
    <t>Content-Range</t>
    <t>Content-Type</t>
  </list>
</t>
<t>
   A transforming proxy &MAY; modify or add these fields to a message
   that does not include no-transform, but if it does so, it &MUST; add a
   Warning 214 (Transformation applied) if one does not already appear
   in the message (see &header-warning;).
</t>
<x:note>
  <t>
    <x:h>Warning:</x:h> Unnecessary modification of end-to-end header fields might
    cause authentication failures if stronger authentication
    mechanisms are introduced in later versions of HTTP. Such
    authentication mechanisms &MAY; rely on the values of header fields
    not listed here.
  </t>
</x:note>
<t>
   A non-transforming proxy &MUST; preserve the message payload (&payload;),
   though it &MAY; change the message body through application or removal
   of a transfer-coding (<xref target="transfer.codings"/>).
</t>
</section>

</section>

<section title="Associating a Response to a Request" anchor="associating.response.to.request">
<t>
   HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond exactly
   to the order in which requests are made on the same connection.
   More than one response message per request only occurs when one or more
   informational responses (1xx, see &status-1xx;) precede a final response
   to the same request.
</t>
<t>
   A client that uses persistent connections and sends more than one request
   per connection &MUST; maintain a list of outstanding requests in the
   order sent on that connection and &MUST; associate each received response
   message to the highest ordered request that has not yet received a final
   (non-1xx) response.
</t>
</section>
</section>

<section title="Connection Management" anchor="connection.management">

<section title="Connection" anchor="header.connection">
  <iref primary="true" item="Connection header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Connection" x:for-anchor=""/>
  <x:anchor-alias value="Connection"/>
  <x:anchor-alias value="connection-option"/>
<t>
   The "Connection" header field allows the sender to specify
   options that are desired only for that particular connection.
   Such connection options &MUST; be removed or replaced before the
   message can be forwarded downstream by a proxy or gateway.
   This mechanism also allows the sender to indicate which HTTP
   header fields used in the message are only intended for the
   immediate recipient ("hop-by-hop"), as opposed to all recipients
   on the chain ("end-to-end"), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed in HTTP without fear that they will be blindly
   forwarded by previously deployed intermediaries.
</t>
<t>
   The Connection header field's value has the following grammar:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Connection"/><iref primary="true" item="Grammar" subitem="connection-option"/>
  <x:ref>Connection</x:ref>        = 1#<x:ref>connection-option</x:ref>
  <x:ref>connection-option</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Connection options are compared case-insensitively.
</t>
<t>
   A proxy or gateway &MUST; parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself or replace it with the
   sender's own connection options for the forwarded message.
</t>
<t>
   A sender &MUST-NOT; include field-names in the Connection header
   field-value for fields that are defined as expressing constraints
   for all recipients in the request or response chain, such as the
   Cache-Control header field (&header-cache-control;).
</t>
<t>
   The connection options do not have to correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with that
   connection option.  Recipients that trigger certain connection
   behavior based on the presence of connection options &MUST; do so
   based on the presence of the connection-option rather than only the
   presence of the optional header field.  In other words, if the
   connection option is received as a header field but not indicated
   within the Connection field-value, then the recipient &MUST; ignore
   the connection-specific header field because it has likely been
   forwarded by an intermediary that is only partially conformant.
</t>
<t>
   When defining new connection options, specifications ought to
   carefully consider existing deployed header fields and ensure
   that the new connection option does not share the same name as
   an unrelated header field that might already be deployed.
   Defining a new connection option essentially reserves that potential
   field-name for carrying additional information related to the
   connection option, since it would be unwise for senders to use
   that field-name for anything else.
</t>
<t>
   HTTP/1.1 defines the "close" connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,
</t>
<figure><artwork type="example">
  Connection: close
</artwork></figure>
<t>
   in either the request or the response header fields indicates that
   the connection &SHOULD-NOT;  be considered "persistent" (<xref target="persistent.connections"/>)
   after the current request/response is complete.
</t>
<t>
   An HTTP/1.1 client that does not support persistent connections &MUST;
   include the "close" connection option in every request message.
</t>
<t>
   An HTTP/1.1 server that does not support persistent connections &MUST;
   include the "close" connection option in every response message that
   does not have a 1xx (Informational) status code.
</t>
</section>

<section title="Via" anchor="header.via">
  <iref primary="true" item="Via header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Via" x:for-anchor=""/>
  <x:anchor-alias value="pseudonym"/>
  <x:anchor-alias value="received-by"/>
  <x:anchor-alias value="received-protocol"/>
  <x:anchor-alias value="Via"/>
<t>
   The "Via" header field &MUST; be sent by a proxy or gateway to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the "Received" field
   used by email systems (<xref target="RFC5322" x:fmt="of" x:sec="3.6.7"/>)
   and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Via"/><iref primary="true" item="Grammar" subitem="received-protocol"/><iref primary="true" item="Grammar" subitem="protocol-name"/><iref primary="true" item="Grammar" subitem="protocol-version"/><iref primary="true" item="Grammar" subitem="received-by"/><iref primary="true" item="Grammar" subitem="pseudonym"/>
  <x:ref>Via</x:ref>               = 1#( <x:ref>received-protocol</x:ref> <x:ref>RWS</x:ref> <x:ref>received-by</x:ref>
                          [ <x:ref>RWS</x:ref> <x:ref>comment</x:ref> ] )
  <x:ref>received-protocol</x:ref> = [ <x:ref>protocol-name</x:ref> "/" ] <x:ref>protocol-version</x:ref>
  <x:ref>received-by</x:ref>       = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
  <x:ref>pseudonym</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients.
</t>
<t>
   The protocol-name is excluded if and only if it would be "HTTP". The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it &MAY; be replaced by a pseudonym. If the port is not given, it &MAY;
   be assumed to be the default port of the received-protocol.
</t>
<t>
   Multiple Via field values represent each proxy or gateway that has
   forwarded the message. Each recipient &MUST; append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.
</t>
<t>
   Comments &MAY; be used in the Via header field to identify the software
   of each recipient, analogous to the User-Agent and Server header fields.
   However, all comments in the Via field are optional and &MAY; be removed
   by any recipient prior to forwarding the message.
</t>
<t>
   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which completes
   the request by forwarding it to the origin server at www.example.com.
   The request received by www.example.com would then have the following
   Via header field:
</t>
<figure><artwork type="example">
  Via: 1.0 fred, 1.1 p.example.net (Apache/1.1)
</artwork></figure>
<t>
   A proxy or gateway used as a portal through a network firewall
   &SHOULD-NOT; forward the names and ports of hosts within the firewall
   region unless it is explicitly enabled to do so. If not enabled, the
   received-by host of any host behind the firewall &SHOULD; be replaced
   by an appropriate pseudonym for that host.
</t>
<t>
   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy or gateway &MAY; combine an ordered
   subsequence of Via header field entries with identical received-protocol
   values into a single such entry. For example,
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</artwork></figure>
<t>
  could be collapsed to
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</artwork></figure>
<t>
   Senders &SHOULD-NOT; combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Senders &MUST-NOT; combine entries which
   have different received-protocol values.
</t>
</section>

<section title="Persistent Connections" anchor="persistent.connections">

<section title="Purpose" anchor="persistent.purpose">
<t>
   Prior to persistent connections, a separate TCP connection was
   established for each request, increasing the load on HTTP servers
   and causing congestion on the Internet. The use of inline images and
   other associated data often requires a client to make multiple
   requests of the same server in a short amount of time. Analysis of
   these performance problems and results from a prototype
   implementation are available <xref target="Pad1995"/> <xref target="Spe"/>. Implementation experience and
   measurements of actual HTTP/1.1 implementations show good
   results <xref target="Nie1997"/>. Alternatives have also been explored, for example,
   T/TCP <xref target="Tou1998"/>.
</t>
<t>
   Persistent HTTP connections have a number of advantages:
  <list style="symbols">
      <t>
        By opening and closing fewer TCP connections, CPU time is saved
        in routers and hosts (clients, servers, proxies, gateways,
        tunnels, or caches), and memory used for TCP protocol control
        blocks can be saved in hosts.
      </t>
      <t>
        HTTP requests and responses can be pipelined on a connection.
        Pipelining allows a client to make multiple requests without
        waiting for each response, allowing a single TCP connection to
        be used much more efficiently, with much lower elapsed time.
      </t>
      <t>
        Network congestion is reduced by reducing the number of packets
        caused by TCP opens, and by allowing TCP sufficient time to
        determine the congestion state of the network.
      </t>
      <t>
        Latency on subsequent requests is reduced since there is no time
        spent in TCP's connection opening handshake.
      </t>
      <t>
        HTTP can evolve more gracefully, since errors can be reported
        without the penalty of closing the TCP connection. Clients using
        future versions of HTTP might optimistically try a new feature,
        but if communicating with an older server, retry with old
        semantics after an error is reported.
      </t>
    </list>
</t>
<t>
   HTTP implementations &SHOULD; implement persistent connections.
</t>
</section>

<section title="Overall Operation" anchor="persistent.overall">
<t>
   A significant difference between HTTP/1.1 and earlier versions of
   HTTP is that persistent connections are the default behavior of any
   HTTP connection. That is, unless otherwise indicated, the client
   &SHOULD; assume that the server will maintain a persistent connection,
   even after error responses from the server.
</t>
<t>
   Persistent connections provide a mechanism by which a client and a
   server can signal the close of a TCP connection. This signaling takes
   place using the Connection header field (<xref target="header.connection"/>). Once a close
   has been signaled, the client &MUST-NOT; send any more requests on that
   connection.
</t>

<section title="Negotiation" anchor="persistent.negotiation">
<t>
   An HTTP/1.1 server &MAY; assume that a HTTP/1.1 client intends to
   maintain a persistent connection unless a Connection header field including
   the connection option "close" was sent in the request. If the server
   chooses to close the connection immediately after sending the
   response, it &SHOULD; send a Connection header field including the
   connection option "close".
</t>
<t>
   An HTTP/1.1 client &MAY; expect a connection to remain open, but would
   decide to keep it open based on whether the response from a server
   contains a Connection header field with the connection option "close". In case
   the client does not want to maintain a connection for more than that
   request, it &SHOULD; send a Connection header field including the
   connection option "close".
</t>
<t>
   If either the client or the server sends the "close" option in the
   Connection header field, that request becomes the last one for the
   connection.
</t>
<t>
   Clients and servers &SHOULD-NOT;  assume that a persistent connection is
   maintained for HTTP versions less than 1.1 unless it is explicitly
   signaled. See <xref target="compatibility.with.http.1.0.persistent.connections"/> for more information on backward
   compatibility with HTTP/1.0 clients.
</t>
<t>
   Each persistent connection applies to only one transport link.
</t>
<t>
   A proxy server &MUST-NOT; establish a HTTP/1.1 persistent connection
   with an HTTP/1.0 client (but see <xref x:sec="19.7.1" x:fmt="of" target="RFC2068"/>
   for information and discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).
</t>
<t>
   In order to remain persistent, all messages on the connection &MUST;
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in <xref target="message.body"/>.
</t>
</section>

<section title="Pipelining" anchor="pipelining">
<t>
   A client that supports persistent connections &MAY; "pipeline" its
   requests (i.e., send multiple requests without waiting for each
   response). A server &MUST; send its responses to those requests in the
   same order that the requests were received.
</t>
<t>
   Clients which assume persistent connections and pipeline immediately
   after connection establishment &SHOULD; be prepared to retry their
   connection if the first pipelined attempt fails. If a client does
   such a retry, it &MUST-NOT; pipeline before it knows the connection is
   persistent. Clients &MUST; also be prepared to resend their requests if
   the server closes the connection before sending all of the
   corresponding responses.
</t>
<t>
   Clients &SHOULD-NOT; pipeline requests using non-idempotent request methods or
   non-idempotent sequences of request methods (see &idempotent-methods;). Otherwise, a
   premature termination of the transport connection could lead to
   indeterminate results. A client wishing to send a non-idempotent
   request &SHOULD; wait to send that request until it has received the
   response status line for the previous request.
</t>
</section>
</section>

<section title="Practical Considerations" anchor="persistent.practical">
<t>
   Servers will usually have some time-out value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same server. The use of persistent
   connections places no requirements on the length (or existence) of
   this time-out for either the client or the server.
</t>
<t>
   When a client or server wishes to time-out it &SHOULD; issue a graceful
   close on the transport connection. Clients and servers &SHOULD; both
   constantly watch for the other side of the transport close, and
   respond to it as appropriate. If a client or server does not detect
   the other side's close promptly it could cause unnecessary resource
   drain on the network.
</t>
<t>
   A client, server, or proxy &MAY; close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.
</t>
<t>
   Clients (including proxies) &SHOULD; limit the number of simultaneous
   connections that they maintain to a given server (including proxies).
</t>
<t>
   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications. As a
   result, this specification does not mandate a particular maximum number of
   connections, but instead encourages clients to be conservative when opening
   multiple connections.
</t>
<t>
   In particular, while using multiple connections avoids the "head-of-line
   blocking" problem (whereby a request that takes significant server-side
   processing and/or has a large payload can block subsequent requests on the
   same connection), each connection used consumes server resources (sometimes
   significantly), and furthermore using multiple connections can cause
   undesirable side effects in congested networks. 
</t>
<t>
   Note that servers might reject traffic that they deem abusive, including an
   excessive number of connections from a client.
</t>
</section>

<section title="Retrying Requests" anchor="persistent.retrying.requests">
<t>
   Senders can close the transport connection at any time. Therefore, 
   clients, servers, and proxies &MUST; be able to recover
   from asynchronous close events. Client software &MAY; reopen the
   transport connection and retransmit the aborted sequence of requests
   without user interaction so long as the request sequence is
   idempotent (see &idempotent-methods;). Non-idempotent request methods or sequences
   &MUST-NOT; be automatically retried, although user agents &MAY; offer a
   human operator the choice of retrying the request(s). Confirmation by
   user-agent software with semantic understanding of the application
   &MAY; substitute for user confirmation. The automatic retry &SHOULD-NOT; 
   be repeated if the second sequence of requests fails.
</t>
</section>
</section>

<section title="Message Transmission Requirements" anchor="message.transmission.requirements">

<section title="Persistent Connections and Flow Control" anchor="persistent.flow">
<t>
   HTTP/1.1 servers &SHOULD; maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.
</t>
</section>

<section title="Monitoring Connections for Error Status Messages" anchor="persistent.monitor">
<t>
   An HTTP/1.1 (or later) client sending a message body &SHOULD; monitor
   the network connection for an error status code while it is transmitting
   the request. If the client sees an error status code, it &SHOULD;
   immediately cease transmitting the body. If the body is being sent
   using a "chunked" encoding (<xref target="transfer.codings"/>), a zero length chunk and
   empty trailer &MAY; be used to prematurely mark the end of the message.
   If the body was preceded by a Content-Length header field, the client &MUST;
   close the connection.
</t>
</section>

<section title="Use of the 100 (Continue) Status" anchor="use.of.the.100.status">
<t>
   The purpose of the <x:ref>100 (Continue)</x:ref> status code (see &status-100;)
   is to allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request header fields) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.
</t>
<t>
   Requirements for HTTP/1.1 clients:
  <list style="symbols">
    <t>
        If a client will wait for a <x:ref>100 (Continue)</x:ref> response before
        sending the request body, it &MUST; send an Expect header
        field (&header-expect;) with the "100-continue" expectation.
    </t>
    <t>
        A client &MUST-NOT; send an Expect header field (&header-expect;)
        with the "100-continue" expectation if it does not intend
        to send a request body.
    </t>
  </list>
</t>
<t>
   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client might send "Expect: 100-continue"
   without receiving either a <x:ref>417 (Expectation Failed)</x:ref> 
   or a <x:ref>100 (Continue)</x:ref> status code. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a <x:ref>100 (Continue)</x:ref> status code, the client &SHOULD-NOT;  
   wait for an indefinite period before sending the request body.
</t>
<t>
   Requirements for HTTP/1.1 origin servers:
  <list style="symbols">
    <t> Upon receiving a request which includes an Expect header
        field with the "100-continue" expectation, an origin server &MUST;
        either respond with <x:ref>100 (Continue)</x:ref> status code and continue to read
        from the input stream, or respond with a final status code. The
        origin server &MUST-NOT; wait for the request body before sending
        the <x:ref>100 (Continue)</x:ref> response. If it responds with a final status
        code, it &MAY; close the transport connection or it &MAY; continue
        to read and discard the rest of the request.  It &MUST-NOT;
        perform the request method if it returns a final status code.
    </t>
    <t> An origin server &SHOULD-NOT;  send a <x:ref>100 (Continue)</x:ref> response if
        the request message does not include an Expect header
        field with the "100-continue" expectation, and &MUST-NOT; send a
        <x:ref>100 (Continue)</x:ref> response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with <xref target="RFC2068"/>, a server &MAY; send a <x:ref>100 (Continue)</x:ref>
        status code in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect header field with the "100-continue"
        expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for <x:ref>100 (Continue)</x:ref> status code, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-version
        value.
    </t>
    <t> An origin server &MAY; omit a <x:ref>100 (Continue)</x:ref> response if it has
        already received some or all of the request body for the
        corresponding request.
    </t>
    <t> An origin server that sends a <x:ref>100 (Continue)</x:ref> response &MUST;
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.
    </t>
    <t> If an origin server receives a request that does not include an
        Expect header field with the "100-continue" expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server &SHOULD-NOT;  close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement ought not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.
      </t>
    </list>
</t>
<t>
   Requirements for HTTP/1.1 proxies:
  <list style="symbols">
    <t> If a proxy receives a request that includes an Expect header
        field with the "100-continue" expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it &MUST; forward the request, including the Expect header
        field.
    </t>
    <t> If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it &MUST-NOT; forward the request, and it &MUST;
        respond with a <x:ref>417 (Expectation Failed)</x:ref> status code.
    </t>
    <t> Proxies &SHOULD; maintain a record of the HTTP version
        numbers received from recently-referenced next-hop servers.
    </t>
    <t> A proxy &MUST-NOT; forward a <x:ref>100 (Continue)</x:ref> response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect header field with
        the "100-continue" expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &status-1xx;).
    </t>
  </list>
</t>
</section>

<section title="Closing Connections on Error" anchor="closing.connections.on.error">
<t>
   If the client is sending data, a server implementation using TCP
   &SHOULD; be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which might erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.
</t>
</section>

</section>

<section title="Upgrade" anchor="header.upgrade">
  <iref primary="true" item="Upgrade header field" x:for-anchor=""/>
  <iref primary="true" item="Header Fields" subitem="Upgrade" x:for-anchor=""/>
  <x:anchor-alias value="Upgrade"/>
  <x:anchor-alias value="protocol"/>
  <x:anchor-alias value="protocol-name"/>
  <x:anchor-alias value="protocol-version"/>
<t>
   The "Upgrade" header field allows the client to specify what
   additional communication protocols it would like to use, if the server 
   chooses to switch protocols. Servers can use it to indicate what protocols
   they are willing to switch to.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Upgrade"/>
  <x:ref>Upgrade</x:ref>          = 1#<x:ref>protocol</x:ref>

  <x:ref>protocol</x:ref>         = <x:ref>protocol-name</x:ref> ["/" <x:ref>protocol-version</x:ref>]
  <x:ref>protocol-name</x:ref>    = <x:ref>token</x:ref>
  <x:ref>protocol-version</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   For example,
</t>
<figure><artwork type="example">
  Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
</artwork></figure>
<t>
   The Upgrade header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a "better" protocol if available (where "better" is determined
   by the server, possibly according to the nature of the request method
   or target resource).
</t>
<t>
   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol &MUST; be a response to the initial HTTP
   request containing the Upgrade header field.
</t>
<t>
   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword &MUST; be supplied within a Connection
   header field (<xref target="header.connection"/>) whenever Upgrade is present in an
   HTTP/1.1 message.
</t>
<t>
   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 3xx redirection response (&status-3xx;).
</t>
<t>
   Servers &MUST; include the "Upgrade" header field in <x:ref>101 (Switching
   Protocols)</x:ref> responses to indicate which protocol(s) are being switched to,
   and &MUST; include it in <x:ref>426 (Upgrade Required)</x:ref> responses to indicate
   acceptable protocols to upgrade to. Servers &MAY; include it in any other
   response to indicate that they are willing to upgrade to one of the
   specified protocols.
</t>
<t>
   This specification only defines the protocol name "HTTP" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of <xref target="http.version"/> and future updates to this
   specification. Additional tokens can be registered with IANA using the
   registration procedure defined in <xref target="upgrade.token.registry"/>.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the Message Header Field Registry
   <xref target="RFC3864"/> maintained by IANA at
   <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/>.
</t>
<t>
   This document defines the following HTTP header fields, so their
   associated registry entries shall be updated according to the permanent
   registrations below:
</t>
<?BEGININC p1-messaging.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Connection</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.connection"/>
   </c>
   <c>Content-Length</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-length"/>
   </c>
   <c>Host</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.host"/>
   </c>
   <c>TE</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.te"/>
   </c>
   <c>Trailer</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.trailer"/>
   </c>
   <c>Transfer-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.transfer-encoding"/>
   </c>
   <c>Upgrade</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.upgrade"/>
   </c>
   <c>Via</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.via"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p1-messaging.iana-headers ?>
<t>
   Furthermore, the header field-name "Close" shall be registered as
   "reserved", since using that name as an HTTP header field might
   conflict with the "close" connection option of the "Connection"
   header field (<xref target="header.connection"/>).
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Close</c>
   <c>http</c>
   <c>reserved</c>
   <c>
      <xref target="header.field.registration"/>
   </c>
</texttable>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="URI Scheme Registration" anchor="uri.scheme.registration">
<t>
   IANA maintains the registry of URI Schemes <xref target="RFC4395"/> at
   <eref target="http://www.iana.org/assignments/uri-schemes.html"/>.
</t>
<t>
   This document defines the following URI schemes, so their
   associated registry entries shall be updated according to the permanent
   registrations below:
</t>
<texttable align="left" suppress-title="true">
   <ttcol>URI Scheme</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>

   <c>http</c>
   <c>Hypertext Transfer Protocol</c>
   <c><xref target="http.uri"/></c>

   <c>https</c>
   <c>Hypertext Transfer Protocol Secure</c>
   <c><xref target="https.uri"/></c>
</texttable>
</section>

<section title="Internet Media Type Registrations" anchor="internet.media.type.http">
<t>
   This document serves as the specification for the Internet media types
   "message/http" and "application/http". The following is to be registered with
   IANA (see <xref target="RFC4288"/>).
</t>
<section title="Internet Media Type message/http" anchor="internet.media.type.message.http">
<iref item="Media Type" subitem="message/http" primary="true"/>
<iref item="message/http Media Type" primary="true"/>
<t>
   The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for all
   "message" types regarding line length and encodings.
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      message
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      none
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed message
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      only "7bit", "8bit", or "binary" are permitted
    </t>
    <t hangText="Security considerations:">
      none
    </t>
    <t hangText="Interoperability considerations:">
      none
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.message.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">none</t>
        <t hangText="File extension(s):">none</t>
        <t hangText="Macintosh file type code(s):">none</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors Section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      none
    </t>
    <t hangText="Author/Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
<section title="Internet Media Type application/http" anchor="internet.media.type.application.http">
<iref item="Media Type" subitem="application/http" primary="true"/>
<iref item="application/http Media Type" primary="true"/>
<t>
   The application/http type can be used to enclose a pipeline of one or more
   HTTP request or response messages (not intermixed).
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      application
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      none
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed messages
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      HTTP messages enclosed by this type
      are in "binary" format; use of an appropriate
      Content-Transfer-Encoding is required when
      transmitted via E-mail.
    </t>
    <t hangText="Security considerations:">
      none
    </t>
    <t hangText="Interoperability considerations:">
      none
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.application.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">none</t>
        <t hangText="File extension(s):">none</t>
        <t hangText="Macintosh file type code(s):">none</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors Section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      none
    </t>
    <t hangText="Author/Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
</section>

<section title="Transfer Coding Registry" anchor="transfer.coding.registry">
<t>
   The HTTP Transfer Coding Registry defines the name space for transfer
   coding names.
</t>
<t>
   Registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Names of transfer codings &MUST-NOT; overlap with names of content codings
   (&content-codings;) unless the encoding transformation is identical, as it
   is the case for the compression codings defined in
   <xref target="compression.codings"/>.
</t>
<t>
   Values to be added to this name space require IETF Review (see
   <xref target="RFC5226" x:fmt="of" x:sec="4.1"/>), and &MUST;
   conform to the purpose of transfer coding defined in this section.
</t>
<t>
   The registry itself is maintained at
   <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>
</section>

<section title="Transfer Coding Registrations" anchor="transfer.coding.registration">
<t>
   The HTTP Transfer Coding Registry shall be updated with the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.transfer.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>chunked</c>
   <c>Transfer in a series of chunks</c>
   <c>
      <xref target="chunked.encoding"/>
   </c>
   <c>compress</c>
   <c>UNIX "compress" program method</c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>deflate</c>
   <c>"deflate" compression mechanism (<xref target="RFC1951"/>) used inside
   the "zlib" data format (<xref target="RFC1950"/>)
   </c>
   <c>
      <xref target="deflate.coding"/>
   </c>
   <c>gzip</c>
   <c>Same as GNU zip <xref target="RFC1952"/></c>
   <c>
      <xref target="gzip.coding"/>
   </c>
</texttable>
</section>

<section title="Upgrade Token Registry" anchor="upgrade.token.registry">
<t>
   The HTTP Upgrade Token Registry defines the name space for protocol-name
   tokens used to identify protocols in the Upgrade header field.
   Each registered protocol-name is associated with contact information and
   an optional set of specifications that details how the connection
   will be processed after it has been upgraded.
</t>
<t>
   Registrations happen on a "First Come First Served" basis (see
   <xref target="RFC5226" x:sec="4.1" x:fmt="of"/>) and are subject to the
   following rules:
  <list style="numbers">
    <t>A protocol-name token, once registered, stays registered forever.</t>
    <t>The registration &MUST; name a responsible party for the
       registration.</t>
    <t>The registration &MUST; name a point of contact.</t>
    <t>The registration &MAY; name a set of specifications associated with
       that token. Such specifications need not be publicly available.</t>
    <t>The registration &SHOULD; name a set of expected "protocol-version"
       tokens associated with that token at the time of registration.</t>
    <t>The responsible party &MAY; change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.</t>
    <t>The IESG &MAY; reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.</t>
  </list>
</t>
<t>
   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in <xref target="RFC2817" x:fmt="of" x:sec="7.2"/>.
</t>
</section>

<section title="Upgrade Token Registration" anchor="upgrade.token.registration">
<t>
   The HTTP Upgrade Token Registry shall be updated with the registration
   below:
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Expected Version Tokens</ttcol>
   <ttcol>Reference</ttcol>

   <c>HTTP</c>
   <c>Hypertext Transfer Protocol</c>
   <c>any DIGIT.DIGIT (e.g, "2.0")</c>
   <c><xref target="http.version"/></c>
</texttable>
<t>
   The responsible party is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.
</t>

<section title="Personal Information" anchor="personal.information">
<t>
   HTTP clients are often privy to large amounts of personal information
   (e.g., the user's name, location, mail address, passwords, encryption
   keys, etc.), and &SHOULD; be very careful to prevent unintentional
   leakage of this information.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.
</t>
</section>

<section title="Abuse of Server Log Information" anchor="abuse.of.server.log.information">
<t>
   A server is in the position to save personal data about a user's
   requests which might identify their reading patterns or subjects of
   interest.  In particular, log information gathered at an intermediary
   often contains a history of user agent interaction, across a multitude
   of sites, that can be traced to individual users.
</t>
<t>
   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be securely
   stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries helps,
   but is generally not sufficient to prevent real log traces from being
   re-identified based on correlation with other access characteristics.
   As such, access traces that are keyed to a specific client should not
   be published even if the key is pseudonymous.
</t>
<t>
   To minimize the risk of theft or accidental publication, log information
   should be purged of personally identifiable information, including
   user identifiers, IP addresses, and user-provided query parameters,
   as soon as that information is no longer necessary to support operational
   needs for security, auditing, or fraud control.
</t>
</section>

<section title="Attacks Based On File and Path Names" anchor="attack.pathname">
<t>
   Implementations of HTTP origin servers &SHOULD; be careful to restrict
   the documents returned by HTTP requests to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs directly into file system calls, the server &MUST; take
   special care not to serve files that were not intended to be
   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and
   other operating systems use ".." as a path component to indicate a
   directory level above the current one. On such a system, an HTTP
   server &MUST; disallow any such construct in the request-target if it
   would otherwise allow access to a resource outside those intended to
   be accessible via the HTTP server. Similarly, files intended for
   reference only internally to the server (such as access control
   files, configuration files, and script code) &MUST; be protected from
   inappropriate retrieval, since they might contain sensitive
   information. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security risks.
</t>
</section>

<section title="DNS-related Attacks" anchor="dns.related.attacks">
<t>
   HTTP clients rely heavily on the Domain Name Service (DNS), and are thus
   generally prone to security attacks based on the deliberate misassociation
   of IP addresses and DNS names not protected by DNSSec. Clients need to be
   cautious in assuming the validity of an IP number/DNS name association unless
   the response is protected by DNSSec (<xref target="RFC4033"/>).
</t>
</section>

<section title="Intermediaries and Caching" anchor="attack.intermediaries">
<t>
   By their very nature, HTTP intermediaries are men-in-the-middle, and
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the intermediaries run can result in serious security
   and privacy problems. Intermediaries have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised intermediary, or an intermediary
   implemented or configured without regard to security and privacy
   considerations, might be used in the commission of a wide range of
   potential attacks.
</t>
<t>
   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks.
</t>
<t>
   Implementors need to consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to operators (especially the
   default configuration).
</t>
<t>
   Users need to be aware that intermediaries are no more trustworthy than
   the people who run them; HTTP itself cannot solve this problem.
</t>
<t>
   The judicious use of cryptography, when appropriate, might suffice to
   protect against a broad range of security and privacy attacks. Such
   cryptography is beyond the scope of the HTTP/1.1 specification.
</t>
</section>

<section title="Protocol Element Size Overflows" anchor="attack.protocol.element.size.overflows">
<t>
   Because HTTP uses mostly textual, character-delimited fields, attackers can
   overflow buffers in implementations, and/or perform a Denial of Service
   against implementations that accept fields with unlimited lengths.
</t>
<t>
   To promote interoperability, this specification makes specific
   recommendations for minimum size limits on request-line
   (<xref target="request.line"/>)
   and blocks of header fields (<xref target="header.fields"/>). These are
   minimum recommendations, chosen to be supportable even by implementations
   with limited resources; it is expected that most implementations will
   choose substantially higher limits.
</t>
<t>
   This specification also provides a way for servers to reject messages that
   have request-targets that are too long (&status-414;) or request entities
   that are too large (&status-4xx;).
</t>
<t>
   Other fields (including but not limited to request methods, response status
   phrases, header field-names, and body chunks) &SHOULD; be limited by
   implementations carefully, so as to not impede interoperability.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
   This edition of HTTP builds on the many contributions that went into
   <xref target="RFC1945" format="none">RFC 1945</xref>,
   <xref target="RFC2068" format="none">RFC 2068</xref>,
   <xref target="RFC2145" format="none">RFC 2145</xref>, and
   <xref target="RFC2616" format="none">RFC 2616</xref>, including 
   substantial contributions made by the previous authors, editors, and
   working group chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   Paul J. Leach, and Mark Nottingham.
   See <xref target="RFC2616" x:fmt="of" x:sec="16"/> for additional
   acknowledgements from prior revisions.
</t>
<t>
   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:
</t>
<?BEGININC acks ?>
<t>Adam Barth,
Adam Roach,
Addison Phillips,
Adrian Chadd,
Adrien W. de Croy,
Alan Ford,
Alan Ruttenberg,
Albert Lunde,
Alek Storm,
Alex Rousskov,
Alexandre Morgaut,
Alexey Melnikov,
Alisha Smith,
Amichai Rothman,
Amit Klein,
Amos Jeffries,
Andreas Maier,
Andreas Petersson,
Anne van Kesteren,
Anthony Bryan,
Asbjorn Ulsberg,
Balachander Krishnamurthy,
Barry Leiba,
Ben Laurie,
Benjamin Niven-Jenkins,
Bil Corry,
Bill Burke,
Bjoern Hoehrmann,
Bob Scheifler,
Boris Zbarsky,
Brett Slatkin,
Brian Kell,
Brian McBarron,
Brian Pane,
Brian Smith,
Bryce Nesbitt,
Cameron Heavon-Jones,
Carl Kugler,
Carsten Bormann,
Charles Fry,
Chris Newman,
Cyrus Daboo,
Dale Robert Anderson,
Dan Winship,
Daniel Stenberg,
Dave Cridland,
Dave Crocker,
Dave Kristol,
David Booth,
David Singer,
David W. Morris,
Diwakar Shetty,
Dmitry Kurochkin,
Drummond Reed,
Duane Wessels,
Edward Lee,
Eliot Lear,
Eran Hammer-Lahav,
Eric D. Williams,
Eric J. Bowman,
Eric Lawrence,
Eric Rescorla,
Erik Aronesty,
Florian Weimer,
Frank Ellermann,
Fred Bohle,
Geoffrey Sneddon,
Gervase Markham,
Greg Wilkins,
Harald Tveit Alvestrand,
Harry Halpin,
Helge Hess,
Henrik Nordstrom,
Henry S. Thompson,
Henry Story,
Herbert van de Sompel,
Howard Melman,
Hugo Haas,
Ian Hickson,
Ingo Struck,
J. Ross Nicoll,
James H. Manger,
James Lacey,
James M. Snell,
Jamie Lokier,
Jan Algermissen,
Jeff Hodges (who came up with the term 'effective Request-URI'),
Jeff Walden,
Jim Luther,
Joe D. Williams,
Joe Gregorio,
Joe Orton,
John C. Klensin,
John C. Mallery,
John Cowan,
John Kemp,
John Panzer,
John Schneider,
John Stracke,
John Sullivan,
Jonas Sicking,
Jonathan Billington,
Jonathan Moore,
Jonathan Rees,
Jordi Ros,
Joris Dobbelsteen,
Josh Cohen,
Julien Pierre,
Jungshik Shin,
Justin Chapweske,
Justin Erenkrantz,
Justin James,
Kalvinder Singh,
Karl Dubost,
Keith Hoffman,
Keith Moore,
Koen Holtman,
Konstantin Voronkov,
Kris Zyp,
Lisa Dusseault,
Maciej Stachowiak,
Marc Schneider,
Marc Slemko,
Mark Baker,
Mark Pauley,
Mark Watson,
Markus Isomaki,
Markus Lanthaler,
Martin J. Duerst,
Martin Musatov,
Martin Nilsson,
Martin Thomson,
Matt Lynch,
Matthew Cox,
Max Clark,
Michael Burrows,
Michael Hausenblas,
Mike Amundsen,
Mike Belshe,
Mike Kelly,
Mike Schinkel,
Miles Sabin,
Murray S. Kucherawy,
Mykyta Yevstifeyev,
Nathan Rixham,
Nicholas Shanks,
Nico Williams,
Nicolas Alvarez,
Nicolas Mailhot,
Noah Slater,
Pablo Castro,
Pat Hayes,
Patrick R. McManus,
Paul E. Jones,
Paul Hoffman,
Paul Marquess,
Peter Lepeska,
Peter Saint-Andre,
Peter Watkins,
Phil Archer,
Phillip Hallam-Baker,
Poul-Henning Kamp,
Preethi Natarajan,
Ray Polk,
Reto Bachmann-Gmuer,
Richard Cyganiak,
Robert Brewer,
Robert Collins,
Robert O'Callahan,
Robert Olofsson,
Robert Sayre,
Robert Siemer,
Robert de Wilde,
Roberto Javier Godoy,
Roberto Peon,
Ronny Widjaja,
S. Mike Dierken,
Salvatore Loreto,
Sam Johnston,
Sam Ruby,
Scott Lawrence (who maintained the original issues list),
Sean B. Palmer,
Shane McCarron,
Stefan Eissing,
Stefan Tilkov,
Stefanos Harhalakis,
Stephane Bortzmeyer,
Stephen Farrell,
Stuart Williams,
Subbu Allamaraju,
Sylvain Hellegouarch,
Tapan Divekar,
Ted Hardie,
Thomas Broyer,
Thomas Nordin,
Thomas Roessler,
Tim Bray,
Tim Morgan,
Tim Olsen,
Tom Zhou,
Travis Snoozy,
Tyler Close,
Vincent Murphy,
Wenbo Zhu,
Werner Baumann,
Wilbur Streett,
Wilfredo Sanchez Vega,
William A. Rowe Jr.,
William Chan,
Willy Tarreau,
Xiaoshu Wang,
Yaron Goland,
Yngve Nysaeter Pettersen,
Yoav Nir,
Yogesh Bang,
Yutaka Oiwa,
Zed A. Shaw, and 
Zhong Yu.
</t>
<?ENDINC acks ?>
</section>

</middle>
<back>

<references title="Normative References">

<reference anchor="ISO-8859-1">
  <front>
    <title>
     Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1
    </title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
</reference>

<reference anchor="Part2">
  <front>
    <title>HTTP/1.1, part 2: Message Semantics, Payload and Content Negotiation</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="p2-semantics.xml" basename="p2-semantics">
    <x:defines>100 (Continue)</x:defines>
    <x:defines>101 (Switching Protocols)</x:defines>
    <x:defines>200 (OK)</x:defines>
    <x:defines>204 (No Content)</x:defines>
    <x:defines>301 (Moved Permanently)</x:defines>
    <x:defines>400 (Bad Request)</x:defines>
    <x:defines>405 (Method Not Allowed)</x:defines>
    <x:defines>411 (Length Required)</x:defines>
    <x:defines>414 (URI Too Long)</x:defines>
    <x:defines>417 (Expectation Failed)</x:defines>
    <x:defines>426 (Upgrade Required)</x:defines>
    <x:defines>501 (Not Implemented)</x:defines>
    <x:defines>502 (Bad Gateway)</x:defines>
    <x:defines>505 (HTTP Version Not Supported)</x:defines>
  </x:source>
</reference>

<reference anchor="Part4">
  <front>
    <title>HTTP/1.1, part 4: Conditional Requests</title>
    <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author fullname="Yves Lafon" initials="Y." role="editor" surname="Lafon">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;" />
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;" />
  <x:source basename="p4-conditional" href="p4-conditional.xml">
    <x:defines>304 (Not Modified)</x:defines>
  </x:source>
</reference>

<reference anchor="Part6">
  <front>
    <title>HTTP/1.1, part 6: Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Rackspace</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="p6-cache.xml" basename="p6-cache"/>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC3986">
 <front>
  <title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
  <author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
       <email>timbl@w3.org</email>
       <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>
  <author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>
  <author initials='L.' surname='Masinter' fullname='Larry Masinter'>
    <organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
    <address>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  <date month='January' year='2005'></date>
 </front>
 <seriesInfo name="STD" value="66"/>
 <seriesInfo name="RFC" value="3986"/>
</reference>

<reference anchor="USASCII">
  <front>
    <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
    <author>
      <organization>American National Standards Institute</organization>
    </author>
    <date year="1986"/>
  </front>
  <seriesInfo name="ANSI" value="X3.4"/>
</reference>

<reference anchor="RFC1950">
  <front>
    <title>ZLIB Compressed Data Format Specification version 3.3</title>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly"/>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1950"/>
  <!--<annotation>
    RFC 1950 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1951">
  <front>
    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1951"/>
  <!--<annotation>
    RFC 1951 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1952">
  <front>
    <title>GZIP file format specification version 4.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
      <address><email>gzip@prep.ai.mit.edu</email></address>
    </author>
    <author initials="M." surname="Adler" fullname="Mark Adler">
      <address><email>madler@alumni.caltech.edu</email></address>
    </author>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
      <address><email>randeg@alumni.rpi.edu</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1952"/>
  <!--<annotation>
    RFC 1952 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

</references>

<references title="Informative References">

<reference anchor="Nie1997" target="http://doi.acm.org/10.1145/263105.263157">
  <front>
    <title>Network Performance Effects of HTTP/1.1, CSS1, and PNG</title>
    <author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen"/>
    <author initials="J." surname="Gettys" fullname="J. Gettys"/>
    <author initials="E." surname="Prud'hommeaux" fullname="E. Prud'hommeaux"/>
    <author initials="H." surname="Lie" fullname="H. Lie"/>
    <author initials="C." surname="Lilley" fullname="C. Lilley"/>
    <date year="1997" month="September"/>
  </front>
  <seriesInfo name="ACM" value="Proceedings of the ACM SIGCOMM '97 conference on Applications, technologies, architectures, and protocols for computer communication SIGCOMM '97"/>
</reference>

<reference anchor="Pad1995" target="http://portal.acm.org/citation.cfm?id=219094">
  <front>
    <title>Improving HTTP Latency</title>
    <author initials="V.N." surname="Padmanabhan" fullname="Venkata N. Padmanabhan"/>
    <author initials="J.C." surname="Mogul" fullname="Jeffrey C. Mogul"/>
    <date year="1995" month="December"/>
  </front>
  <seriesInfo name="Computer Networks and ISDN Systems" value="v. 28, pp. 25-35"/>
</reference>

<reference anchor='RFC1919'>
  <front>
    <title>Classical versus Transparent IP Proxies</title>
    <author initials='M.' surname='Chatel' fullname='Marc Chatel'>
      <address><email>mchatel@pax.eunet.ch</email></address>
    </author>
    <date year='1996' month='March' />
  </front>
  <seriesInfo name='RFC' value='1919' />
</reference>

<reference anchor="RFC1945">
  <front>
    <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT, Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1945"/>
</reference>

<reference anchor="RFC2045">
  <front>
    <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC2047">
  <front>
    <title abbrev="Message Header Extensions">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</title>
    <author initials="K." surname="Moore" fullname="Keith Moore">
      <organization>University of Tennessee</organization>
      <address><email>moore@cs.utk.edu</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2047"/>
</reference>

<reference anchor="RFC2068">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="January" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor="RFC2145">
  <front>
    <title abbrev="HTTP Version Numbers">Use and Interpretation of HTTP Version Numbers</title>
    <author initials="J.C." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2145"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC2817'>
  <front>
    <title>Upgrading to TLS Within HTTP/1.1</title>
    <author initials='R.' surname='Khare' fullname='R. Khare'>
      <organization>4K Associates / UC Irvine</organization>
      <address><email>rohit@4K-associates.com</email></address>
    </author>
    <author initials='S.' surname='Lawrence' fullname='S. Lawrence'>
      <organization>Agranat Systems, Inc.</organization>
      <address><email>lawrence@agranat.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2817' />
</reference>

<reference anchor='RFC2818'>
  <front>
    <title>HTTP Over TLS</title>
    <author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
      <organization>RTFM, Inc.</organization>
      <address><email>ekr@rtfm.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2818' />
</reference>

<reference anchor='RFC2965'>
  <front>
    <title>HTTP State Management Mechanism</title>
    <author initials='D. M.' surname='Kristol' fullname='David M. Kristol'>
      <organization>Bell Laboratories, Lucent Technologies</organization>
      <address><email>dmk@bell-labs.com</email></address>
    </author>
    <author initials='L.' surname='Montulli' fullname='Lou Montulli'>
      <organization>Epinions.com, Inc.</organization>
      <address><email>lou@montulli.org</email></address>
    </author>
    <date year='2000' month='October' />
  </front>
  <seriesInfo name='RFC' value='2965' />
</reference>

<reference anchor='RFC3040'>
  <front>
    <title>Internet Web Replication and Caching Taxonomy</title>
    <author initials='I.' surname='Cooper' fullname='I. Cooper'>
      <organization>Equinix, Inc.</organization>
    </author>
    <author initials='I.' surname='Melve' fullname='I. Melve'>
      <organization>UNINETT</organization>
    </author>
    <author initials='G.' surname='Tomlinson' fullname='G. Tomlinson'>
      <organization>CacheFlow Inc.</organization>
    </author>
    <date year='2001' month='January' />
  </front>
  <seriesInfo name='RFC' value='3040' />
</reference>

<reference anchor='RFC3864'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor='RFC4033'>
  <front>
    <title>DNS Security Introduction and Requirements</title>
    <author initials='R.' surname='Arends' fullname='R. Arends'/>
    <author initials='R.' surname='Austein' fullname='R. Austein'/>
    <author initials='M.' surname='Larson' fullname='M. Larson'/>
    <author initials='D.' surname='Massey' fullname='D. Massey'/>
    <author initials='S.' surname='Rose' fullname='S. Rose'/>
    <date year='2005' month='March' />
  </front>
  <seriesInfo name='RFC' value='4033' />
</reference>

<reference anchor="RFC4288">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="N. Freed">
      <organization>Sun Microsystems</organization>
      <address>
        <email>ned.freed@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="J. Klensin">
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <date year="2005" month="December"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="4288"/>
</reference>

<reference anchor='RFC4395'>
  <front>
    <title>Guidelines and Registration Procedures for New URI Schemes</title>
    <author initials='T.' surname='Hansen' fullname='T. Hansen'>
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+urireg@maillennium.att.com</email>
      </address>
    </author>
    <author initials='T.' surname='Hardie' fullname='T. Hardie'>
      <organization>Qualcomm, Inc.</organization>
      <address>
        <email>hardie@qualcomm.com</email>
      </address>
    </author>
    <author initials='L.' surname='Masinter' fullname='L. Masinter'>
      <organization>Adobe Systems</organization>
      <address>
        <email>LMM@acm.org</email>
      </address>
    </author>
    <date year='2006' month='February' />
  </front>
  <seriesInfo name='BCP' value='115' />
  <seriesInfo name='RFC' value='4395' />
</reference>

<reference anchor='RFC4559'>
  <front>
    <title>SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</title>
    <author initials='K.' surname='Jaganathan' fullname='K. Jaganathan'/>
    <author initials='L.' surname='Zhu' fullname='L. Zhu'/>
    <author initials='J.' surname='Brezak' fullname='J. Brezak'/>
    <date year='2006' month='June' />
  </front>
  <seriesInfo name='RFC' value='4559' />
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

<reference anchor="RFC5322">
  <front>
    <title>Internet Message Format</title>
    <author initials="P." surname="Resnick" fullname="P. Resnick">
      <organization>Qualcomm Incorporated</organization>
    </author>
    <date year="2008" month="October"/>
  </front> 
  <seriesInfo name="RFC" value="5322"/>
</reference>

<reference anchor="RFC6265">
  <front>
    <title>HTTP State Management Mechanism</title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address><email>abarth@eecs.berkeley.edu</email></address>
    </author>
    <date year="2011" month="April" />
  </front>
  <seriesInfo name="RFC" value="6265"/>
</reference>

<!--<reference anchor='BCP97'>
  <front>
    <title>Handling Normative References to Standards-Track Documents</title>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <author initials='S.' surname='Hartman' fullname='S. Hartman'>
      <organization>MIT</organization>
      <address>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <date year='2007' month='June' />
  </front>
  <seriesInfo name='BCP' value='97' />
  <seriesInfo name='RFC' value='4897' />
</reference>-->

<reference anchor="Kri2001" target="http://arxiv.org/abs/cs.SE/0105018">
  <front>
    <title>HTTP Cookies: Standards, Privacy, and Politics</title>
    <author initials="D." surname="Kristol" fullname="David M. Kristol"/>
    <date year="2001" month="November"/>
  </front>
  <seriesInfo name="ACM Transactions on Internet Technology" value="Vol. 1, #2"/>
</reference>

<reference anchor="Spe" target="http://sunsite.unc.edu/mdma-release/http-prob.html">
  <front>
    <title>Analysis of HTTP Performance Problems</title>
    <author initials="S." surname="Spero" fullname="Simon E. Spero"/>
    <date/>
  </front>
</reference>

<reference anchor="Tou1998" target="http://www.isi.edu/touch/pubs/http-perf96/">
  <front>
  <title>Analysis of HTTP Performance</title>
  <author initials="J." surname="Touch" fullname="Joe Touch">
    <organization>USC/Information Sciences Institute</organization>
    <address><email>touch@isi.edu</email></address>
  </author>
  <author initials="J." surname="Heidemann" fullname="John Heidemann">
    <organization>USC/Information Sciences Institute</organization>
    <address><email>johnh@isi.edu</email></address>
  </author>
  <author initials="K." surname="Obraczka" fullname="Katia Obraczka">
    <organization>USC/Information Sciences Institute</organization>
    <address><email>katia@isi.edu</email></address>
  </author>
  <date year="1998" month="Aug"/>
  </front>
  <seriesInfo name="ISI Research Report" value="ISI/RR-98-463"/>
  <annotation>(original report dated Aug. 1996)</annotation>
</reference>

</references>


<section title="HTTP Version History" anchor="compatibility">
<t>
   HTTP has been in use by the World-Wide Web global information initiative
   since 1990. The first version of HTTP, later referred to as HTTP/0.9,
   was a simple protocol for hypertext data transfer across the Internet
   with only a single request method (GET) and no metadata.
   HTTP/1.0, as defined by <xref target="RFC1945"/>, added a range of request
   methods and MIME-like messaging that could include metadata about the data
   transferred and modifiers on the request/response semantics. However,
   HTTP/1.0 did not sufficiently take into consideration the effects of
   hierarchical proxies, caching, the need for persistent connections, or
   name-based virtual hosts. The proliferation of incompletely-implemented
   applications calling themselves "HTTP/1.0" further necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.
</t>
<t>
   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only
   those new features that will either be safely ignored by an HTTP/1.0
   recipient or only sent when communicating with a party advertising
   conformance with HTTP/1.1.
</t>
<t>
   It is beyond the scope of a protocol specification to mandate
   conformance with previous versions. HTTP/1.1 was deliberately
   designed, however, to make supporting previous versions easy.
   We would expect a general-purpose HTTP/1.1 server to understand
   any valid request in the format of HTTP/1.0 and respond appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, we would expect
   an HTTP/1.1 client to understand any valid HTTP/1.0 response.
</t>
<t>
   Since HTTP/0.9 did not support header fields in a request,
   there is no mechanism for it to support name-based virtual
   hosts (selection of resource by inspection of the Host header
   field).  Any server that implements name-based virtual hosts
   ought to disable support for HTTP/0.9.  Most requests that
   appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x
   requests wherein a buggy client failed to properly encode
   linear whitespace found in a URI reference and placed in
   the request-target.
</t>

<section title="Changes from HTTP/1.0" anchor="changes.from.1.0">
<t>
   This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.
</t>

<section title="Multi-homed Web Servers" anchor="changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses">
<t>
   The requirements that clients and servers support the Host header
   field (<xref target="header.host"/>), report an error if it is
   missing from an HTTP/1.1 request, and accept absolute URIs (<xref target="request-target"/>)
   are among the most important changes defined by HTTP/1.1.
</t>
<t>
   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional requirements
   were placed on all HTTP/1.1 requests in order to ensure complete
   adoption.  At the time of this writing, most HTTP-based services
   are dependent upon the Host header field for targeting requests.
</t>
</section>

<section title="Keep-Alive Connections" anchor="compatibility.with.http.1.0.persistent.connections">
<t>
   In HTTP/1.0, each connection is established by the client prior to the
   request and closed by the server after sending the response. However, some
   implementations implement the explicitly negotiated ("Keep-Alive") version
   of persistent connections described in <xref x:sec="19.7.1" x:fmt="of"
   target="RFC2068"/>.
</t>
<t>
   Some clients and servers might wish to be compatible with these previous
   approaches to persistent connections, by explicitly negotiating for them
   with a "Connection: keep-alive" request header field. However, some
   experimental implementations of HTTP/1.0 persistent connections are faulty;
   for example, if a HTTP/1.0 proxy server doesn't understand Connection, it
   will erroneously forward that header to the next inbound server, which
   would result in a hung connection.
</t>
<t>
   One attempted solution was the introduction of a Proxy-Connection header,
   targeted specifically at proxies. In practice, this was also unworkable,
   because proxies are often deployed in multiple layers, bringing about the
   same problem discussed above.
</t>
<t>
   As a result, clients are encouraged not to send the Proxy-Connection header 
   in any requests.
</t>
<t>
   Clients are also encouraged to consider the use of Connection: keep-alive
   in requests carefully; while they can enable persistent connections with
   HTTP/1.0 servers, clients using them need will need to monitor the
   connection for "hung" requests (which indicate that the client ought stop
   sending the header), and this mechanism ought not be used by clients at all
   when a proxy is being used.
</t>
</section>
</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  Clarify that the string "HTTP" in the HTTP-version ABFN production is case
  sensitive. Restrict the version numbers to be single digits due to the fact
  that implementations are known to handle multi-digit version numbers
  incorrectly.
  (<xref target="http.version"/>)
</t>
<t>
  Update use of abs_path production from RFC 1808 to the path-absolute + query
  components of RFC 3986. State that the asterisk form is allowed for the OPTIONS
  request method only.
  (<xref target="request-target"/>)
</t>
<t>
  Require that invalid whitespace around field-names be rejected.
  (<xref target="header.fields"/>)
</t>
<t>
  Rules about implicit linear whitespace between certain grammar productions
  have been removed; now whitespace is only allowed where specifically
  defined in the ABNF.
  (<xref target="whitespace"/>)
</t>
<t>  
  The NUL octet is no longer allowed in comment and quoted-string
  text. The quoted-pair rule no longer allows escaping control characters other than HTAB.
  Non-ASCII content in header fields and reason phrase has been obsoleted and
  made opaque (the TEXT rule was removed).
  (<xref target="field.components"/>)
</t>
<t>
  Empty list elements in list productions have been deprecated.
  (<xref target="abnf.extension"/>)
</t>
<t>
  Require recipients to handle bogus Content-Length header fields as errors.
  (<xref target="message.body"/>)
</t>
<t>
  Remove reference to non-existent identity transfer-coding value tokens.
  (Sections <xref format="counter" target="message.body"/> and
  <xref format="counter" target="transfer.codings"/>)
</t>
<t>
  Clarification that the chunk length does not include the count of the octets
  in the chunk header and trailer. Furthermore disallowed line folding
  in chunk extensions, and deprecate their use.
  (<xref target="chunked.encoding"/>)
</t>
<t>
  Registration of Transfer Codings now requires IETF Review
  (<xref target="transfer.coding.registry"/>)
</t>
<t>
  Remove hard limit of two connections per server.
  Remove requirement to retry a sequence of requests as long it was idempotent.
  Remove requirements about when servers are allowed to close connections
  prematurely.
  (<xref target="persistent.practical"/>)
</t>
<t>
  Remove requirement to retry requests under certain cirumstances when the
  server prematurely closes the connection.
  (<xref target="message.transmission.requirements"/>)
</t>
<t>
  Change ABNF productions for header fields to only define the field value.
</t>
<t>
  Clarify exactly when "close" connection options have to be sent.
  (<xref target="header.connection"/>)
</t>
<t>
  Define the semantics of the "Upgrade" header field in responses other than
  101 (this was incorporated from <xref target="RFC2817"/>).
  (<xref target="header.upgrade"/>)
</t>
</section>
</section>

<?BEGININC p1-messaging.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p1-messaging.parsed-abnf">
<x:ref>BWS</x:ref> = OWS

<x:ref>Connection</x:ref> = *( "," OWS ) connection-option *( OWS "," [ OWS
 connection-option ] )
<x:ref>Content-Length</x:ref> = 1*DIGIT

<x:ref>HTTP-message</x:ref> = start-line *( header-field CRLF ) CRLF [ message-body
 ]
<x:ref>HTTP-name</x:ref> = %x48.54.54.50 ; HTTP
<x:ref>HTTP-version</x:ref> = HTTP-name "/" DIGIT "." DIGIT
<x:ref>Host</x:ref> = uri-host [ ":" port ]

<x:ref>OWS</x:ref> = *( SP / HTAB )

<x:ref>RWS</x:ref> = 1*( SP / HTAB )

<x:ref>TE</x:ref> = [ ( "," / t-codings ) *( OWS "," [ OWS t-codings ] ) ]
<x:ref>Trailer</x:ref> = *( "," OWS ) field-name *( OWS "," [ OWS field-name ] )
<x:ref>Transfer-Encoding</x:ref> = *( "," OWS ) transfer-coding *( OWS "," [ OWS
 transfer-coding ] )

<x:ref>URI-reference</x:ref> = &lt;URI-reference, defined in [RFC3986], Section 4.1&gt;
<x:ref>Upgrade</x:ref> = *( "," OWS ) protocol *( OWS "," [ OWS protocol ] )

<x:ref>Via</x:ref> = *( "," OWS ) ( received-protocol RWS received-by [ RWS comment
 ] ) *( OWS "," [ OWS ( received-protocol RWS received-by [ RWS
 comment ] ) ] )

<x:ref>absolute-URI</x:ref> = &lt;absolute-URI, defined in [RFC3986], Section 4.3&gt;
<x:ref>absolute-form</x:ref> = absolute-URI
<x:ref>asterisk-form</x:ref> = "*"
<x:ref>attribute</x:ref> = token
<x:ref>authority</x:ref> = &lt;authority, defined in [RFC3986], Section 3.2&gt;
<x:ref>authority-form</x:ref> = authority

<x:ref>chunk</x:ref> = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
<x:ref>chunk-data</x:ref> = 1*OCTET
<x:ref>chunk-ext</x:ref> = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
<x:ref>chunk-ext-name</x:ref> = token
<x:ref>chunk-ext-val</x:ref> = token / quoted-str-nf
<x:ref>chunk-size</x:ref> = 1*HEXDIG
<x:ref>chunked-body</x:ref> = *chunk last-chunk trailer-part CRLF
<x:ref>comment</x:ref> = "(" *( ctext / quoted-cpair / comment ) ")"
<x:ref>connection-option</x:ref> = token
<x:ref>ctext</x:ref> = OWS / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

<x:ref>field-content</x:ref> = *( HTAB / SP / VCHAR / obs-text )
<x:ref>field-name</x:ref> = token
<x:ref>field-value</x:ref> = *( field-content / obs-fold )

<x:ref>header-field</x:ref> = field-name ":" OWS field-value BWS
<x:ref>http-URI</x:ref> = "http://" authority path-abempty [ "?" query ]
<x:ref>https-URI</x:ref> = "https://" authority path-abempty [ "?" query ]

<x:ref>last-chunk</x:ref> = 1*"0" [ chunk-ext ] CRLF

<x:ref>message-body</x:ref> = *OCTET
<x:ref>method</x:ref> = token

<x:ref>obs-fold</x:ref> = CRLF ( SP / HTAB )
<x:ref>obs-text</x:ref> = %x80-FF
<x:ref>origin-form</x:ref> = path-absolute [ "?" query ]

<x:ref>partial-URI</x:ref> = relative-part [ "?" query ]
<x:ref>path-abempty</x:ref> = &lt;path-abempty, defined in [RFC3986], Section 3.3&gt;
<x:ref>path-absolute</x:ref> = &lt;path-absolute, defined in [RFC3986], Section 3.3&gt;
<x:ref>port</x:ref> = &lt;port, defined in [RFC3986], Section 3.2.3&gt;
<x:ref>protocol</x:ref> = protocol-name [ "/" protocol-version ]
<x:ref>protocol-name</x:ref> = token
<x:ref>protocol-version</x:ref> = token
<x:ref>pseudonym</x:ref> = token

<x:ref>qdtext</x:ref> = OWS / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
<x:ref>qdtext-nf</x:ref> = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
<x:ref>query</x:ref> = &lt;query, defined in [RFC3986], Section 3.4&gt;
<x:ref>quoted-cpair</x:ref> = "\" ( HTAB / SP / VCHAR / obs-text )
<x:ref>quoted-pair</x:ref> = "\" ( HTAB / SP / VCHAR / obs-text )
<x:ref>quoted-str-nf</x:ref> = DQUOTE *( qdtext-nf / quoted-pair ) DQUOTE
<x:ref>quoted-string</x:ref> = DQUOTE *( qdtext / quoted-pair ) DQUOTE
<x:ref>qvalue</x:ref> = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

<x:ref>reason-phrase</x:ref> = *( HTAB / SP / VCHAR / obs-text )
<x:ref>received-by</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>received-protocol</x:ref> = [ protocol-name "/" ] protocol-version
<x:ref>relative-part</x:ref> = &lt;relative-part, defined in [RFC3986], Section 4.2&gt;
<x:ref>request-line</x:ref> = method SP request-target SP HTTP-version CRLF
<x:ref>request-target</x:ref> = origin-form / absolute-form / authority-form /
 asterisk-form

<x:ref>special</x:ref> = "(" / ")" / "&lt;" / "&gt;" / "@" / "," / ";" / ":" / "\" /
 DQUOTE / "/" / "[" / "]" / "?" / "=" / "{" / "}"
<x:ref>start-line</x:ref> = request-line / status-line
<x:ref>status-code</x:ref> = 3DIGIT
<x:ref>status-line</x:ref> = HTTP-version SP status-code SP reason-phrase CRLF

<x:ref>t-codings</x:ref> = "trailers" / ( transfer-extension [ te-params ] )
<x:ref>tchar</x:ref> = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
 "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
<x:ref>te-ext</x:ref> = OWS ";" OWS token [ "=" word ]
<x:ref>te-params</x:ref> = OWS ";" OWS "q=" qvalue *te-ext
<x:ref>token</x:ref> = 1*tchar
<x:ref>trailer-part</x:ref> = *( header-field CRLF )
<x:ref>transfer-coding</x:ref> = "chunked" / "compress" / "deflate" / "gzip" /
 transfer-extension
<x:ref>transfer-extension</x:ref> = token *( OWS ";" OWS transfer-parameter )
<x:ref>transfer-parameter</x:ref> = attribute BWS "=" BWS value

<x:ref>uri-host</x:ref> = &lt;host, defined in [RFC3986], Section 3.2.2&gt;

<x:ref>value</x:ref> = word

<x:ref>word</x:ref> = token / quoted-string
</artwork>
</figure>
<figure><preamble>ABNF diagnostics:</preamble><artwork type="inline">
; Connection defined but not used
; Content-Length defined but not used
; HTTP-message defined but not used
; Host defined but not used
; TE defined but not used
; Trailer defined but not used
; Transfer-Encoding defined but not used
; URI-reference defined but not used
; Upgrade defined but not used
; Via defined but not used
; chunked-body defined but not used
; http-URI defined but not used
; https-URI defined but not used
; partial-URI defined but not used
; special defined but not used
</artwork></figure></section>
<?ENDINC p1-messaging.abnf-appendix ?>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC 2616">
<t>
  Extracted relevant partitions from <xref target="RFC2616"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-00">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/1"/>:
      "HTTP Version should be case sensitive"
      (<eref target="http://purl.org/NET/http-errata#verscase"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/2"/>:
      "'unsafe' characters"
      (<eref target="http://purl.org/NET/http-errata#unsafe-uri"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/3"/>:
      "Chunk Size Definition"
      (<eref target="http://purl.org/NET/http-errata#chunk-size"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/4"/>:
      "Message Length"
      (<eref target="http://purl.org/NET/http-errata#msg-len-chars"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/8"/>:
      "Media Type Registrations"
      (<eref target="http://purl.org/NET/http-errata#media-reg"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/11"/>:
      "URI includes query"
      (<eref target="http://purl.org/NET/http-errata#uriquery"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/15"/>:
      "No close on 1xx responses"
      (<eref target="http://purl.org/NET/http-errata#noclose1xx"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/16"/>:
      "Remove 'identity' token references"
      (<eref target="http://purl.org/NET/http-errata#identity"/>)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/26"/>:
      "Import query BNF"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/31"/>:
      "qdtext BNF"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/35"/>:
      "Normative and Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/42"/>:
      "RFC2606 Compliance"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/45"/>:
      "RFC977 reference"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/46"/>:
      "RFC1700 references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/47"/>:
      "inconsistency in date format explanation"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/48"/>:
      "Date reference typo"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/65"/>:
      "Informative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/66"/>:
      "ISO-8859-1 Reference"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/86"/>:
      "Normative up-to-date references"
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Update media type registrations to use RFC4288 template.
    </t>
    <t>
      Use names of RFC4234 core rules DQUOTE and HTAB,
      fix broken ABNF for chunk-data
      (work in progress on <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>)
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-01">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/19"/>:
      "Bodies on GET (and other) requests"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/55"/>:
      "Updating to RFC4288"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/57"/>:
      "Status Code and Reason Phrase"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/82"/>:
      "rel_path not used"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Get rid of duplicate BNF rule names ("host" -> "uri-host", "trailer" ->
      "trailer-part").
    </t>
    <t>
      Avoid underscore character in rule names ("http_URL" ->
      "http-URL", "abs_path" -> "path-absolute").
    </t>
    <t>
      Add rules for terms imported from URI spec ("absoluteURI", "authority",
      "path-absolute", "port", "query", "relativeURI", "host) &mdash; these will
      have to be updated when switching over to RFC3986.
    </t>
    <t>
      Synchronize core rules with RFC5234.
    </t>
    <t>
      Get rid of prose rules that span multiple lines.
    </t>
    <t>
      Get rid of unused rules LOALPHA and UPALPHA.
    </t>
    <t>
      Move "Product Tokens" section (back) into Part 1, as "token" is used
      in the definition of the Upgrade header field.
    </t>
    <t>
      Add explicit references to BNF syntax and rules imported from other parts of the specification.
    </t>
    <t>
      Rewrite prose rule "token" in terms of "tchar", rewrite prose rule "TEXT".
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-02" anchor="changes.since.02">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/51"/>:
      "HTTP-date vs. rfc1123-date"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/64"/>:
      "WS in quoted-pair"
    </t>
  </list>
</t>
<t>
  Ongoing work on IANA Message Header Field Registration (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/40"/>):
  <list style="symbols"> 
    <t>
      Reference RFC 3984, and update header field registrations for headers defined
      in this document.
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Replace string literals when the string really is case-sensitive (HTTP-version).
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-03" anchor="changes.since.03">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/28"/>:
      "Connection closing"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/97"/>:
      "Move registrations and registry information to IANA Considerations"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/120"/>:
      "need new URL for PAD1995 reference"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/127"/>:
      "IANA Considerations: update HTTP URI scheme registration"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/128"/>:
      "Cite HTTPS URI scheme definition"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/129"/>:
      "List-type headers vs Set-Cookie"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Replace string literals when the string really is case-sensitive (HTTP-Date).
    </t>
    <t>
      Replace HEX by HEXDIG for future consistence with RFC 5234's core rules. 
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-04" anchor="changes.since.04">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/34"/>:
      "Out-of-date reference for URIs"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/132"/>:
      "RFC 2822 is updated by RFC 5322"
    </t>
  </list>
</t>
<t>
  Ongoing work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Use "/" instead of "|" for alternatives.
    </t>
    <t>
      Get rid of RFC822 dependency; use RFC5234 plus extensions instead.
    </t>
    <t>
      Only reference RFC 5234's core rules.
    </t>
    <t>
      Introduce new ABNF rules for "bad" whitespace ("BWS"), optional
      whitespace ("OWS") and required whitespace ("RWS").
    </t>
    <t>
      Rewrite ABNFs to spell out whitespace rules, factor out
      header field value format definitions.
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-05" anchor="changes.since.05">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/30"/>:
      "Header LWS"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/52"/>:
      "Sort 1.3 Terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/63"/>:
      "RFC2047 encoded words"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/74"/>:
      "Character Encodings in TEXT"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/77"/>:
      "Line Folding"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/83"/>:
      "OPTIONS * and proxies"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/94"/>:
      "reason-phrase BNF"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/111"/>:
      "Use of TEXT"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/118"/>:
      "Join "Differences Between HTTP Entities and RFC 2045 Entities"?"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/134"/>:
      "RFC822 reference left in discussion of date formats"
    </t>
  </list>
</t>
<t>
  Final work on ABNF conversion (<eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/36"/>):
  <list style="symbols"> 
    <t>
      Rewrite definition of list rules, deprecate empty list elements.
    </t>
    <t>
      Add appendix containing collected and expanded ABNF.
    </t>
  </list>
</t>
<t>
  Other changes:
  <list style="symbols"> 
    <t>
      Rewrite introduction; add mostly new Architecture Section.
    </t>
    <t>
      Move definition of quality values from Part 3 into Part 1;
      make TE request header field grammar independent of accept-params (defined in Part 3).
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-06" anchor="changes.since.06">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/161"/>:
      "base for numeric protocol elements"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/162"/>:
      "comment ABNF"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/88"/>:
      "205 Bodies" (took out language that implied that there might be
      methods for which a request body MUST NOT be included)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/163"/>:
      "editorial improvements around HTTP-date"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-07" anchor="changes.since.07">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/93"/>:
      "Repeating single-value headers"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/131"/>:
      "increase connection limit"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/157"/>:
      "IP addresses in URLs"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/172"/>:
      "take over HTTP Upgrade Token Registry"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/173"/>:
      "CR and LF in chunk extension values"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/184"/>:
      "HTTP/0.9 support"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/188"/>:
      "pick IANA policy (RFC5226) for Transfer Coding / Content Coding"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/189"/>:
      "move definitions of gzip/deflate/compress to part 1"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/194"/>:
      "disallow control characters in quoted-pair"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/148"/>:
      "update IANA requirements wrt Transfer-Coding values" (add the
      IANA Considerations subsection)
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-08" anchor="changes.since.08">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/201"/>:
      "header parsing, treatment of leading and trailing OWS"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/60"/>:
      "Placement of 13.5.1 and 13.5.2"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/200"/>:
      "use of term "word" when talking about header structure"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-09" anchor="changes.since.09">
<t>
  Closed issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/73"/>:
      "Clarification of the term 'deflate'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/83"/>:
      "OPTIONS * and proxies"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/122"/>:
      "MIME-Version not listed in P1, general header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/143"/>:
      "IANA registry for content/transfer encodings"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/165"/>:
      "Case-sensitivity of HTTP-date"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/200"/>:
      "use of term "word" when talking about header structure"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/196"/>:
      "Term for the requested resource's URI"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-10" anchor="changes.since.10">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/28"/>:
      "Connection Closing"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/90"/>:
      "Delimiting messages with multipart/byteranges"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/95"/>:
      "Handling multiple Content-Length headers"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/109"/>:
      "Clarify entity / representation / variant terminology"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/220"/>:
      "consider removing the 'changes from 2068' sections"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/159"/>:
      "HTTP(s) URI scheme definitions"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-11" anchor="changes.since.11">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/193"/>:
      "Trailer requirements"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/204"/>:
      "Text about clock requirement for caches belongs in p6"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/221"/>:
      "effective request URI: handling of missing host in HTTP/1.0"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/248"/>:
      "confusing Date requirements for clients"
    </t>
  </list>
</t>
<t>
  Partly resolved issues:
  <list style="symbols"> 
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/95"/>:
      "Handling multiple Content-Length headers"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-12" anchor="changes.since.12">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/75"/>:
      "RFC2145 Normative"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/159"/>:
      "HTTP(s) URI scheme definitions" (tune the requirements on userinfo)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/210"/>:
      "define 'transparent' proxy"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/224"/>:
      "Header Classification"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/233"/>:
      "Is * usable as a request-uri for new methods?"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/240"/>:
      "Migrate Upgrade details from RFC2817"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/276"/>:
      "untangle ABNFs for header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/279"/>:
      "update RFC 2109 reference"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-13" anchor="changes.since.13">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/53"/>:
      "Allow is not in 13.5.2"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/95"/>:
      "Handling multiple Content-Length headers"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/276"/>:
      "untangle ABNFs for header fields"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/286"/>:
      "Content-Length ABNF broken"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-14" anchor="changes.since.14">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/273"/>:
      "HTTP-version should be redefined as fixed length pair of DIGIT . DIGIT"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/282"/>:
      "Recommend minimum sizes for protocol elements"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/283"/>:
      "Set expectations around buffering"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/288"/>:
      "Considering messages in isolation"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-15" anchor="changes.since.15">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/100"/>:
      "DNS Spoofing / DNS Binding advice"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/254"/>:
      "move RFCs 2145, 2616, 2817 to Historic status"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/270"/>:
      "\-escaping in quoted strings"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/305"/>:
      "'Close' should be reserved in the HTTP header field registry"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-16" anchor="changes.since.16">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/186"/>:
      "Document HTTP's error-handling philosophy"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/215"/>:
      "Explain header registration"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/219"/>:
      "Revise Acknowledgements Sections"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/297"/>:
      "Retrying Requests"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/318"/>:
      "Closing the connection on server error"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-17" anchor="changes.since.17">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/158"/>:
      "Proxy-Connection and Keep-Alive"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/166"/>:
      "Clarify 'User Agent'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/300"/>:
      "Define non-final responses"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/323"/>:
      "intended maturity level vs normative references"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/324"/>:
      "Intermediary rewriting of queries"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-18" anchor="changes.since.18">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/250"/>:
      "message-body in CONNECT response"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/302"/>:
      "Misplaced text on connection handling in p2"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/335"/>:
      "wording of line folding rule"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/343"/>:
      "chunk-extensions"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/346"/>:
      "make IANA policy definitions consistent"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-19" anchor="changes.since.19">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/346"/>:
      "make IANA policy definitions consistent"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/359"/>:
      "clarify connection header field values are case-insensitive"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/361"/>:
      "ABNF requirements for recipients"
    </t>
  </list>
</t>
</section>

</section>

</back>
</rfc>
